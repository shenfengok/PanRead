2020-11-25 10:10:49.035 INFO  jdbc.sqltiming Line:373 - update book_check set fsid='619261117652869', got=1, name='net_content', parse_fail='', parsed=1, 
path='12-Linux性能优化实战/05-网络性能篇 (13讲)/45丨答疑（五）：网络收发过程中，缓冲区位置在哪里？.html', title='45丨答疑（五）：网络收发过程中，缓冲区位置在哪里？', 
vid=1078 where item_id=1078 
 {executed in 0 msec}
2020-11-25 10:10:49.044 INFO  jdbc.sqltiming Line:373 - select nodebodyen0_.entity_id as entity_i1_4_, nodebodyen0_.body_value as body_val2_4_, nodebodyen0_.body_summary 
as body_sum3_4_, nodebodyen0_.bundle as bundle4_4_, nodebodyen0_.delta as delta5_4_, nodebodyen0_.body_format 
as body_for6_4_, nodebodyen0_.langcode as langcode7_4_, nodebodyen0_.revision_id as revision8_4_ 
from node__body nodebodyen0_ where nodebodyen0_.entity_id=1078 
 {executed in 0 msec}
2020-11-25 10:10:49.045 INFO  jdbc.resultsettable Line:610 - 
|----------|-----------|-------------|-------|------|------------|---------|------------|
|entity_id |body_value |body_summary |bundle |delta |body_format |langcode |revision_id |
|----------|-----------|-------------|-------|------|------------|---------|------------|
|1078      |           |             |book   |0     |full_html   |zh-hans  |1078        |
|----------|-----------|-------------|-------|------|------------|---------|------------|

2020-11-25 10:10:49.046 INFO  jdbc.sqltiming Line:373 - select nodebodyre0_.entity_id as entity_i1_13_0_, nodebodyre0_.body_value as body_val2_13_0_, 
nodebodyre0_.body_summary as body_sum3_13_0_, nodebodyre0_.bundle as bundle4_13_0_, nodebodyre0_.delta 
as delta5_13_0_, nodebodyre0_.body_format as body_for6_13_0_, nodebodyre0_.langcode as langcode7_13_0_, 
nodebodyre0_.revision_id as revision8_13_0_ from node_revision__body nodebodyre0_ where nodebodyre0_.entity_id=1078 
 {executed in 1 msec}
2020-11-25 10:10:49.046 INFO  jdbc.resultsettable Line:610 - 
|----------|-----------|-------------|-------|------|------------|---------|------------|
|entity_id |body_value |body_summary |bundle |delta |body_format |langcode |revision_id |
|----------|-----------|-------------|-------|------|------------|---------|------------|
|[unread]  |           |             |book   |0     |full_html   |zh-hans  |1078        |
|----------|-----------|-------------|-------|------|------------|---------|------------|

2020-11-25 10:10:49.048 INFO  jdbc.sqltiming Line:373 - update node__body set body_value='<p>你好，我是倪朋飞。</p> <p>专栏更新至今，四大基础模块的最后一个模块——网络篇，我们就已经学完了。很开心你还没有掉队，仍然在积极学习思考和实践操作，热情地留言和互动。还有不少同学分享了在实际生产环境中，碰到各种性能问题的分析思路和优化方法，这里也谢谢你们。</p> 
<p>今天是性能优化答疑的第五期。照例，我从网络模块的留言中，摘出了一些典型问题，作为今天的答疑内容，集中回复。同样的，为了便于你学习理解，它们并不是严格按照文章顺序排列的。</p> 
<p>每个问题，我都附上了留言区提问的截屏。如果你需要回顾内容原文，可以扫描每个问题右下方的二维码查看。</p> <h2>问题 1：网络收发过程中缓冲区的位置</h2> <p><img 
src="https://static001.geekbang.org/resource/image/49/28/49649598767b9ef537169558ee6be128.png" 
alt=""></p> <p>第一点，是网络收发过程中，收发队列和缓冲区位置的疑问。</p> <p>在 <a href="https://time.geekbang.org/column/article/80898">关于 
Linux 网络，你必须要知道这些</a> 中，我曾介绍过 Linux 网络的收发流程。这个流程涉及到了多个队列和缓冲区，包括：</p> <ul> <li> <p>网卡收发网络包时，通过 
DMA 方式交互的<strong>环形缓冲区</strong>；</p> </li> <li> <p>网卡中断处理程序为网络帧分配的，内核数据结构 <strong>sk_buff 缓冲区</strong>；</p> 
</li> <li> <p>应用程序通过套接字接口，与网络协议栈交互时的<strong>套接字缓冲区。</strong></p> </li> </ul> <p>不过相应的，就会有两个问题。</p> 
<p>首先，这些缓冲区的位置在哪儿？是在网卡硬件中，还是在内存中？这个问题其实仔细想一下，就很容易明白——这些缓冲区都处于内核管理的内存中。</p><!-- [[[read_end]]] 
--> <p>其中，<strong>环形缓冲区</strong>，由于需要 DMA 与网卡交互，理应属于网卡设备驱动的范围。</p> <p><strong>sk_buff 缓冲区</strong>，是一个维护网络帧结构的双向链表，链表中的每一个元素都是一个网络帧（Packet）。虽然 
TCP/IP 协议栈分了好几层，但上下不同层之间的传递，实际上只需要操作这个数据结构中的指针，而无需进行数据复制。</p> <p><strong>套接字缓冲区</strong>，则允许应用程序，给每个套接字配置不同大小的接收或发送缓冲区。应用程序发送数据，实际上就是将数据写入缓冲区；而接收数据，其实就是从缓冲区中读取。至于缓冲区中数据的进一步处理，则由传输层的 
TCP 或 UDP 协议来完成。</p> <p>其次，这些缓冲区，跟前面内存部分讲到的 Buffer 和 Cache 有什么关联吗？</p> <p>这个问题其实也不难回答。我在内存模块曾提到过，内存中提到的 
Buffer ，都跟块设备直接相关；而其他的都是 Cache。</p> <p>实际上，sk_buff、套接字缓冲、连接跟踪等，都通过 slab 分配器来管理。你可以直接通过 /proc/slabinfo，来查看它们占用的内存大小。</p> 
<h2>问题 2：内核协议栈，是通过一个内核线程的方式来运行的吗</h2> <p>第二个问题，内核协议栈的运行，是按照一个内核线程的方式吗？在内核中，又是如何执行网络协议栈的呢？</p> 
<p><img src="https://static001.geekbang.org/resource/image/9b/1c/9bea298bcc349e80f46c1a406472381c.png" 
alt=""></p> <p>说到网络收发，在中断处理文章中我曾讲过，其中的软中断处理，就有专门的内核线程 ksoftirqd。每个 CPU 都会绑定一个 ksoftirqd 内核线程，比如， 
2 个 CPU 时，就会有 ksoftirqd/0 和 ksoftirqd/1 这两个内核线程。</p> <p>不过要注意，并非所有网络功能，都在软中断内核线程中处理。内核中还有很多其他机制（比如硬中断、kworker、slab 
等），这些机制一起协同工作，才能保证整个网络协议栈的正常运行。</p> <p>关于内核中网络协议栈的工作原理，以及如何动态跟踪内核的执行流程，专栏后续还有专门的文章来讲。如果对这部分感兴趣，你可以先用我们提到过的 
perf、systemtap、bcc-tools 等，试着来分析一下。</p> <h2>问题 3：最大连接数是不是受限于 65535 个端口</h2> <p><img src="https://static001.geekbang.org/resource/image/50/8c/504ddb710169cb247b349d0d8a32818c.png" 
alt=""><img src="https://static001.geekbang.org/resource/image/0a/70/0a5cb5d25a4b09c5f46ca8941e9fca70.png" 
alt=""></p> <p>我们知道，无论 TCP 还是 UDP，端口号都只占 16 位，也就说其最大值也只有 65535。那是不是说，如果使用 TCP 协议，在单台机器、单个 IP 
地址时，并发连接数最大也只有 65535 呢？</p> <p>对于这个问题，首先你要知道，Linux 协议栈，通过五元组来标志一个连接（即协议，源 IP、源端口、目的 IP、目的端口)。</p> 
<p>明白了这一点，这个问题其实就有了思路。我们应该分客户端和服务器端，这两种场景来分析。</p> <p>对客户端来说，每次发起 TCP 连接请求时，都需要分配一个空闲的本地端口，去连接远端的服务器。由于这个本地端口是独占的，所以客户端最多只能发起 
65535 个连接。</p> <p>对服务器端来说，其通常监听在固定端口上（比如 80 端口），等待客户端的连接。根据五元组结构，我们知道，客户端的 IP 和端口都是可变的。如果不考虑 
IP 地址分类以及资源限制，服务器端的理论最大连接数，可以达到 2 的 48 次方（IP 为 32 位，端口号为 16 位），远大于 65535。</p> <p>所以，综合来看，客户端最大支持 
65535 个连接，而服务器端可支持的连接数是海量的。当然，由于 Linux 协议栈本身的性能，以及各种物理和软件的资源限制等，这么大的连接数，还是远远达不到的（实际上，C10M 就已经很难了）。</p> 
<h2>问题 4： “如何优化 NAT 性能”课后思考</h2> <p><img src="https://static001.geekbang.org/resource/image/c6/a0/c623453e2e054d2f4407ab1e4a87f5a0.png" 
alt=""></p> <p>在 <a href="https://time.geekbang.org/column/article/83189">如何优化 NAT 性能</a> 的最后， 
我给你留了两个思考题。</p> <p>MASQUERADE 是最常用的 SNAT 规则之一，通常用来为多个内网 IP 地址，提供共享的出口 IP。假设现在有一台 Linux 服务器，用了 
MASQUERADE 方式，为内网所有 IP 提供出口访问功能。那么，</p> <ul> <li> <p>当多个内网 IP 地址的端口号相同时，MASQUERADE 还能正常工作吗？</p> 
</li> <li> <p>内网 IP 地址数量或者请求数比较多的时候，这种使用方式有没有什么潜在问题呢？</p> </li> </ul> <p>对于这两个思考题，我来也、ninuxer 
等同学，都给出了不错的答案：</p> <p><img src="https://static001.geekbang.org/resource/image/24/52/245ba322ff2975e56db18206f0797d52.png" 
alt=""><img src="https://static001.geekbang.org/resource/image/f4/55/f41d8ad99120f22a7967e3afffe97555.png" 
alt=""></p> <p>先看第一点，当多个内网 IP 地址的端口号相同时，MASQUERADE 当然仍可以正常工作。不过，你肯定也听说过，配置 MASQUERADE 后，需要各个应用程序去手动配置修改端口号。</p> 
<p>实际上，MASQUERADE 通过 conntrack 机制，记录了每个连接的信息。而在刚才第三个问题 中，我提到过，标志一个连接需要五元组，只要这五元组不是同时相同，网络连接就可以正常进行。</p> 
<p>再看第二点，在内网 IP 地址和连接数比较小时，这种方式的问题不大。但在 IP 地址或并发连接数特别大的情况下，就可能碰到各种各样的资源限制。</p> <p>比如，MASQUERADE 
既然把内部多个 IP ，转换成了相同的外网 IP（即 SNAT），那么，为了确保发送出去的源端口不重复，原来网络包的源端口也可能会被重新分配。这样的话，转换后的外网 IP 的端口号，就成了限制连接数的一个重要因素。</p> 
<p>除此之外，连接跟踪、MASQUERADE 机器的网络带宽等，都是潜在的瓶颈，并且还存在单点的问题。这些情况，在我们实际使用中都需要特别注意。</p> <p>今天主要回答这些问题，同时也欢迎你继续在留言区写下疑问和感想，我会持续不断地解答。希望借助每一次的答疑，可以和你一起，把文章知识内化为你的能力，我们不仅在实战中演练，也要在交流中进步。</p> 
<p><img src="https://static001.geekbang.org/resource/image/a3/e9/a396aed4116c2c989771c1295736abe9.jpg" 
alt=""></p>', body_summary='', bundle='book', delta=0, body_format='full_html', langcode='zh-hans', 
revision_id=1078 where entity_id=1078 
 {executed in 0 msec}
2020-11-25 10:10:49.048 INFO  jdbc.sqltiming Line:373 - update node_revision__body set body_value='<p>你好，我是倪朋飞。</p> <p>专栏更新至今，四大基础模块的最后一个模块——网络篇，我们就已经学完了。很开心你还没有掉队，仍然在积极学习思考和实践操作，热情地留言和互动。还有不少同学分享了在实际生产环境中，碰到各种性能问题的分析思路和优化方法，这里也谢谢你们。</p> 
<p>今天是性能优化答疑的第五期。照例，我从网络模块的留言中，摘出了一些典型问题，作为今天的答疑内容，集中回复。同样的，为了便于你学习理解，它们并不是严格按照文章顺序排列的。</p> 
<p>每个问题，我都附上了留言区提问的截屏。如果你需要回顾内容原文，可以扫描每个问题右下方的二维码查看。</p> <h2>问题 1：网络收发过程中缓冲区的位置</h2> <p><img 
src="https://static001.geekbang.org/resource/image/49/28/49649598767b9ef537169558ee6be128.png" 
alt=""></p> <p>第一点，是网络收发过程中，收发队列和缓冲区位置的疑问。</p> <p>在 <a href="https://time.geekbang.org/column/article/80898">关于 
Linux 网络，你必须要知道这些</a> 中，我曾介绍过 Linux 网络的收发流程。这个流程涉及到了多个队列和缓冲区，包括：</p> <ul> <li> <p>网卡收发网络包时，通过 
DMA 方式交互的<strong>环形缓冲区</strong>；</p> </li> <li> <p>网卡中断处理程序为网络帧分配的，内核数据结构 <strong>sk_buff 缓冲区</strong>；</p> 
</li> <li> <p>应用程序通过套接字接口，与网络协议栈交互时的<strong>套接字缓冲区。</strong></p> </li> </ul> <p>不过相应的，就会有两个问题。</p> 
<p>首先，这些缓冲区的位置在哪儿？是在网卡硬件中，还是在内存中？这个问题其实仔细想一下，就很容易明白——这些缓冲区都处于内核管理的内存中。</p><!-- [[[read_end]]] 
--> <p>其中，<strong>环形缓冲区</strong>，由于需要 DMA 与网卡交互，理应属于网卡设备驱动的范围。</p> <p><strong>sk_buff 缓冲区</strong>，是一个维护网络帧结构的双向链表，链表中的每一个元素都是一个网络帧（Packet）。虽然 
TCP/IP 协议栈分了好几层，但上下不同层之间的传递，实际上只需要操作这个数据结构中的指针，而无需进行数据复制。</p> <p><strong>套接字缓冲区</strong>，则允许应用程序，给每个套接字配置不同大小的接收或发送缓冲区。应用程序发送数据，实际上就是将数据写入缓冲区；而接收数据，其实就是从缓冲区中读取。至于缓冲区中数据的进一步处理，则由传输层的 
TCP 或 UDP 协议来完成。</p> <p>其次，这些缓冲区，跟前面内存部分讲到的 Buffer 和 Cache 有什么关联吗？</p> <p>这个问题其实也不难回答。我在内存模块曾提到过，内存中提到的 
Buffer ，都跟块设备直接相关；而其他的都是 Cache。</p> <p>实际上，sk_buff、套接字缓冲、连接跟踪等，都通过 slab 分配器来管理。你可以直接通过 /proc/slabinfo，来查看它们占用的内存大小。</p> 
<h2>问题 2：内核协议栈，是通过一个内核线程的方式来运行的吗</h2> <p>第二个问题，内核协议栈的运行，是按照一个内核线程的方式吗？在内核中，又是如何执行网络协议栈的呢？</p> 
<p><img src="https://static001.geekbang.org/resource/image/9b/1c/9bea298bcc349e80f46c1a406472381c.png" 
alt=""></p> <p>说到网络收发，在中断处理文章中我曾讲过，其中的软中断处理，就有专门的内核线程 ksoftirqd。每个 CPU 都会绑定一个 ksoftirqd 内核线程，比如， 
2 个 CPU 时，就会有 ksoftirqd/0 和 ksoftirqd/1 这两个内核线程。</p> <p>不过要注意，并非所有网络功能，都在软中断内核线程中处理。内核中还有很多其他机制（比如硬中断、kworker、slab 
等），这些机制一起协同工作，才能保证整个网络协议栈的正常运行。</p> <p>关于内核中网络协议栈的工作原理，以及如何动态跟踪内核的执行流程，专栏后续还有专门的文章来讲。如果对这部分感兴趣，你可以先用我们提到过的 
perf、systemtap、bcc-tools 等，试着来分析一下。</p> <h2>问题 3：最大连接数是不是受限于 65535 个端口</h2> <p><img src="https://static001.geekbang.org/resource/image/50/8c/504ddb710169cb247b349d0d8a32818c.png" 
alt=""><img src="https://static001.geekbang.org/resource/image/0a/70/0a5cb5d25a4b09c5f46ca8941e9fca70.png" 
alt=""></p> <p>我们知道，无论 TCP 还是 UDP，端口号都只占 16 位，也就说其最大值也只有 65535。那是不是说，如果使用 TCP 协议，在单台机器、单个 IP 
地址时，并发连接数最大也只有 65535 呢？</p> <p>对于这个问题，首先你要知道，Linux 协议栈，通过五元组来标志一个连接（即协议，源 IP、源端口、目的 IP、目的端口)。</p> 
<p>明白了这一点，这个问题其实就有了思路。我们应该分客户端和服务器端，这两种场景来分析。</p> <p>对客户端来说，每次发起 TCP 连接请求时，都需要分配一个空闲的本地端口，去连接远端的服务器。由于这个本地端口是独占的，所以客户端最多只能发起 
65535 个连接。</p> <p>对服务器端来说，其通常监听在固定端口上（比如 80 端口），等待客户端的连接。根据五元组结构，我们知道，客户端的 IP 和端口都是可变的。如果不考虑 
IP 地址分类以及资源限制，服务器端的理论最大连接数，可以达到 2 的 48 次方（IP 为 32 位，端口号为 16 位），远大于 65535。</p> <p>所以，综合来看，客户端最大支持 
65535 个连接，而服务器端可支持的连接数是海量的。当然，由于 Linux 协议栈本身的性能，以及各种物理和软件的资源限制等，这么大的连接数，还是远远达不到的（实际上，C10M 就已经很难了）。</p> 
<h2>问题 4： “如何优化 NAT 性能”课后思考</h2> <p><img src="https://static001.geekbang.org/resource/image/c6/a0/c623453e2e054d2f4407ab1e4a87f5a0.png" 
alt=""></p> <p>在 <a href="https://time.geekbang.org/column/article/83189">如何优化 NAT 性能</a> 的最后， 
我给你留了两个思考题。</p> <p>MASQUERADE 是最常用的 SNAT 规则之一，通常用来为多个内网 IP 地址，提供共享的出口 IP。假设现在有一台 Linux 服务器，用了 
MASQUERADE 方式，为内网所有 IP 提供出口访问功能。那么，</p> <ul> <li> <p>当多个内网 IP 地址的端口号相同时，MASQUERADE 还能正常工作吗？</p> 
</li> <li> <p>内网 IP 地址数量或者请求数比较多的时候，这种使用方式有没有什么潜在问题呢？</p> </li> </ul> <p>对于这两个思考题，我来也、ninuxer 
等同学，都给出了不错的答案：</p> <p><img src="https://static001.geekbang.org/resource/image/24/52/245ba322ff2975e56db18206f0797d52.png" 
alt=""><img src="https://static001.geekbang.org/resource/image/f4/55/f41d8ad99120f22a7967e3afffe97555.png" 
alt=""></p> <p>先看第一点，当多个内网 IP 地址的端口号相同时，MASQUERADE 当然仍可以正常工作。不过，你肯定也听说过，配置 MASQUERADE 后，需要各个应用程序去手动配置修改端口号。</p> 
<p>实际上，MASQUERADE 通过 conntrack 机制，记录了每个连接的信息。而在刚才第三个问题 中，我提到过，标志一个连接需要五元组，只要这五元组不是同时相同，网络连接就可以正常进行。</p> 
<p>再看第二点，在内网 IP 地址和连接数比较小时，这种方式的问题不大。但在 IP 地址或并发连接数特别大的情况下，就可能碰到各种各样的资源限制。</p> <p>比如，MASQUERADE 
既然把内部多个 IP ，转换成了相同的外网 IP（即 SNAT），那么，为了确保发送出去的源端口不重复，原来网络包的源端口也可能会被重新分配。这样的话，转换后的外网 IP 的端口号，就成了限制连接数的一个重要因素。</p> 
<p>除此之外，连接跟踪、MASQUERADE 机器的网络带宽等，都是潜在的瓶颈，并且还存在单点的问题。这些情况，在我们实际使用中都需要特别注意。</p> <p>今天主要回答这些问题，同时也欢迎你继续在留言区写下疑问和感想，我会持续不断地解答。希望借助每一次的答疑，可以和你一起，把文章知识内化为你的能力，我们不仅在实战中演练，也要在交流中进步。</p> 
<p><img src="https://static001.geekbang.org/resource/image/a3/e9/a396aed4116c2c989771c1295736abe9.jpg" 
alt=""></p>', body_summary='', bundle='book', delta=0, body_format='full_html', langcode='zh-hans', 
revision_id=1078 where entity_id=1078 
 {executed in 0 msec}
2020-11-25 10:10:49.053 INFO  jdbc.sqltiming Line:373 - select nodefiledd0_.nid as nid1_10_, nodefiledd0_.changed as changed2_10_, nodefiledd0_.created 
as created3_10_, nodefiledd0_.default_langcode as default_4_10_, nodefiledd0_.langcode as langcode5_10_, 
nodefiledd0_.promote as promote6_10_, nodefiledd0_.revision_translation_affected as revision7_10_, 
nodefiledd0_.status as status8_10_, nodefiledd0_.sticky as sticky9_10_, nodefiledd0_.title 
as title10_10_, nodefiledd0_.type as type11_10_, nodefiledd0_.uid as uid12_10_, nodefiledd0_.vid 
as vid13_10_ from node_field_data nodefiledd0_ where nodefiledd0_.nid=1078 
 {executed in 1 msec}
2020-11-25 10:10:49.053 INFO  jdbc.resultsettable Line:610 - 
|-----|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|---------------------------|-----|----|-----|
|nid  |changed    |created    |default_langcode |langcode |promote |revision_translation_affected |status |sticky |title                      |type |uid |vid  |
|-----|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|---------------------------|-----|----|-----|
|1078 |1606114961 |1606114961 |1                |zh-hans  |0       |1                             |1      |0      |45丨答疑（五）：网络收发过程中，缓冲区位置在哪里？ |book |1   |1078 |
|-----|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|---------------------------|-----|----|-----|

2020-11-25 10:10:49.054 INFO  jdbc.sqltiming Line:373 - select nodefieldr0_.nid as nid1_11_0_, nodefieldr0_.changed as changed2_11_0_, nodefieldr0_.created 
as created3_11_0_, nodefieldr0_.default_langcode as default_4_11_0_, nodefieldr0_.langcode 
as langcode5_11_0_, nodefieldr0_.promote as promote6_11_0_, nodefieldr0_.revision_translation_affected 
as revision7_11_0_, nodefieldr0_.status as status8_11_0_, nodefieldr0_.sticky as sticky9_11_0_, 
nodefieldr0_.title as title10_11_0_, nodefieldr0_.uid as uid11_11_0_, nodefieldr0_.vid as vid12_11_0_ 
from node_field_revision nodefieldr0_ where nodefieldr0_.nid=1078 
 {executed in 0 msec}
2020-11-25 10:10:49.054 INFO  jdbc.resultsettable Line:610 - 
|---------|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|---------------------------|----|-----|
|nid      |changed    |created    |default_langcode |langcode |promote |revision_translation_affected |status |sticky |title                      |uid |vid  |
|---------|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|---------------------------|----|-----|
|[unread] |1606114961 |1606114961 |1                |zh-hans  |0       |1                             |1      |0      |45丨答疑（五）：网络收发过程中，缓冲区位置在哪里？ |1   |1078 |
|---------|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|---------------------------|----|-----|

2020-11-25 10:10:49.056 INFO  jdbc.sqltiming Line:373 - update node_field_data set changed=1606270249, created=1606270249, default_langcode=1, langcode='zh-hans', 
promote=0, revision_translation_affected=1, status=1, sticky=0, title='45丨答疑（五）：网络收发过程中，缓冲区位置在哪里？', 
type='book', uid=1, vid=1078 where nid=1078 
 {executed in 0 msec}
2020-11-25 10:10:49.056 INFO  jdbc.sqltiming Line:373 - update node_field_revision set changed=1606270249, created=1606270249, default_langcode=1, 
langcode='zh-hans', promote=0, revision_translation_affected=1, status=1, sticky=0, title='45丨答疑（五）：网络收发过程中，缓冲区位置在哪里？', 
uid=1, vid=1078 where nid=1078 
 {executed in 0 msec}
2020-11-25 10:10:49.063 INFO  jdbc.sqltiming Line:373 - select bookfieldm0_.entity_id as entity_i1_8_, bookfieldm0_.bundle as bundle2_8_, bookfieldm0_.delta 
as delta3_8_, bookfieldm0_.langcode as langcode4_8_, bookfieldm0_.field_media_value as field_me5_8_, 
bookfieldm0_.revision_id as revision6_8_ from node__field_media bookfieldm0_ where bookfieldm0_.entity_id=1078 
 {executed in 0 msec}
2020-11-25 10:10:49.064 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------------|------------|
|entity_id |bundle |delta |langcode |field_media_value |revision_id |
|----------|-------|------|---------|------------------|------------|
|1078      |book   |0     |zh-hans  |                  |1078        |
|----------|-------|------|---------|------------------|------------|

2020-11-25 10:10:49.066 INFO  jdbc.sqltiming Line:373 - select nodefieldm0_.entity_id as entity_i1_17_0_, nodefieldm0_.bundle as bundle2_17_0_, nodefieldm0_.delta 
as delta3_17_0_, nodefieldm0_.langcode as langcode4_17_0_, nodefieldm0_.field_media_value as 
field_me5_17_0_, nodefieldm0_.revision_id as revision6_17_0_ from node_revision__field_media 
nodefieldm0_ where nodefieldm0_.entity_id=1078 
 {executed in 0 msec}
2020-11-25 10:10:49.066 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------------|------------|
|entity_id |bundle |delta |langcode |field_media_value |revision_id |
|----------|-------|------|---------|------------------|------------|
|[unread]  |book   |0     |zh-hans  |                  |1078        |
|----------|-------|------|---------|------------------|------------|

2020-11-25 10:10:49.068 INFO  jdbc.sqltiming Line:373 - select bookfieldc0_.entity_id as entity_i1_5_, bookfieldc0_.bundle as bundle2_5_, bookfieldc0_.field_comment_value 
as field_co3_5_, bookfieldc0_.delta as delta4_5_, bookfieldc0_.field_comment_format as field_co5_5_, 
bookfieldc0_.langcode as langcode6_5_, bookfieldc0_.revision_id as revision7_5_ from node__field_comment 
bookfieldc0_ where bookfieldc0_.entity_id=1078 
 {executed in 0 msec}
2020-11-25 10:10:49.069 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|--------------------|------|---------------------|---------|------------|
|entity_id |bundle |field_comment_value |delta |field_comment_format |langcode |revision_id |
|----------|-------|--------------------|------|---------------------|---------|------------|
|1078      |book   |                    |0     |full_html            |zh-hans  |1078        |
|----------|-------|--------------------|------|---------------------|---------|------------|

2020-11-25 10:10:49.074 INFO  jdbc.sqltiming Line:373 - update node__field_comment set bundle='book', field_comment_value='<li class="reJj6Thl_0"><img 
src="https://static001.geekbang.org/account/avatar/00/14/17/4a/d8fd5563.jpg" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>记忆</span> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-14 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> </div> <!----> 
<!----> </div> </div> <div class="_3M6kV3zb_0"> 老师你好，如果sk_buff 缓冲区 （socket buffer）不是套接字缓冲器区,那是不是还要进行一次数据的copy到套接字缓冲区，再通知应用程序有某个套接字数据可读了？那一帧数据到来，需要收包队列--&gt;sk_buff--&gt;套接字缓冲区--&gt;应用程序空间内存里，拷贝了3次呢？ 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 这是两个不同的概念，具体到数据上，内核协议栈都是操作指针，并不会在不同协议层之间复制数据</p> </div> </div></li> 
<li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/11/52/c3/896f3410.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>kissingers</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-10 </div> </div> <div 
class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> 
</div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> sk_buff 缓冲区 （socket 
buffer）不是套接字缓冲器区吗？ </div> <!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 不是的，文中有介绍他们的含义</p> 
</div> </div></li> <li class="reJj6Thl_0"><img src="" class="_2273kGdT_0"> <div class="_2CG0SquK_0"> 
<div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>腾达</span> <!----> </div> <div 
class="_1H1Z49Dr_0"> 2019-03-06 </div> </div> <div class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> 
<i class="iconfont"></i> <span class="">1</span> </div> <!----> <!----> </div> </div> <div 
class="_3M6kV3zb_0"> 能不能再出一个有关TIME_WAIT、peer reset、socket read timeout、socket connect timeout 
方面有关的案例？ 类似java、php、nginx，做应用开发的会遇到很多这类问题。之前有网友提问：期待结合生产环境对这几个内核参数的讲解。目前生产环境下php服务器time_wait特别多，网络包的流程： 
NGINX代理&lt;——&gt;PHP服务器——&gt;redis/mysql.. <br>高峰时期php服务器一共50k+的连接。49k+的time_wait。 我看到老师回复”后面会有的“。难道是《案例篇：如何优化NAT性能》里一笔带过的有关TIME_WAIT的东西？ 
能否专门出一个偏开发人员方面的网络案例？ 网络篇里的案例大部分人都说不太跟的上，基础都不好，可能大部分人都是偏开发，网络接触的少，像NAT更是很少人接触了。希望再出一个偏开发人员适用的网络的案例 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 后面的案例还会讲到timeout的</p> </div> </div></li> <li class="reJj6Thl_0"><img 
src="http://thirdwx.qlogo.cn/mmopen/vi_32/2o1Izf2YyJSnnI0ErZ51pYRlnrmibqUTaia3tCU1PjMxuwyXSKOLUYiac2TQ5pd5gNGvS81fVqKWGvDsZLTM8zhWg/132" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>划时代</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-06 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> </div> <!----> 
<!----> </div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 最近在广泛收集资料学习老师讲的C10K到C1000K的问题，打卡总结。 
</div> <!----> <!----> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>我来也</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-06 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> </div> <!----> 
<!----> </div> </div> <div class="_3M6kV3zb_0"> 试着回答下同学的提问。 <br>nginx fork出来的子进程数是可以配置的。 <br>有连接请求时，可能是选一个子进程响应连接请求（这个不太确定，也可能是主进程建立连接了交给子进程）。 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 这是可配置的，也可以开启reuseport交给你系统来选择</p> </div> </div></li> <li class="reJj6Thl_0"><img 
src="https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>我来也</span> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-06 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> </div> <!----> 
<!----> </div> </div> <div class="_3M6kV3zb_0"> [D45打卡] <br>四大模块学完了，接下来就是融会贯通了。😄 <br> <br>以前也知道socket连接是通过五元组唯一确定的，但实际写服务端程序时，还是会根据经验限定到65530。 
<br>现在想来，当时还是理解的不够透彻。 <br>这个经验值当时是根据压力测试得来的，当时只用了一台机器去测连接数。🤦‍♂️如果用多个机器测可能好点。 <br>另一个是服务器端单进程同时打开的文件数限制，平常限制的也是65535（可以继续调大）。一个进程默认还会打开2个文件，stdout 
stderr，所以需要再减2，如果有监听一个端口，还需要再减1。 <br>有一次在生产环境中，同时连接数限制的是65535，结果到65533个连接时，把监听的端口给关闭了。（可能是所用框架导致的）虽然已有的连接未受影响，但之后就无法再接受新连接了。 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 嗯，谢谢分享。不过线上环境也不推荐一直运行在达到资源极限的场景，最好是预留一些资源以便应对异常情况</p> </div> </div></li> 
<li class="reJj6Thl_0"><img src="https://wx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEKQMM4m7NHuicr55aRiblTSEWIYe0QqbpyHweaoAbG7j2v7UUElqqeP3Ihrm3UfDPDRb1Hv8LvPwXqA/132" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>ninuxer</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-06 </div> </div> <div 
class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> 
</div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 打卡day47 <br>很高兴一直没掉队，网络一直是我的短板，得补补 
</div> <!----> <!----> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/0f/67/77/c1310aad.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>剑衣清风</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-04-28 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> 老师你好，对于问题3我有个疑问 <br> <br>“对客户端来说，每次发起 TCP 连接请求时，都需要分配一个空闲的本地端口，去连接远端的服务器。由于这个本地端口是独占的，所以客户端最多只能发起 
65535 个连接。” <br> <br>那像 ab 这样的压测工具，是如何做到并发对服务端接口压测的？ </div> <div class="_2r3UB1GX_0"> <span>展开</span><i 
class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 为客户端分配不同的端口去连接服务端，请求量大的时候还需要多机或多IP增大请求数</p> 
</div> </div></li> <li class="reJj6Thl_0"><img src="" class="_2273kGdT_0"> <div class="_2CG0SquK_0"> 
<div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>如果</span> <!----> </div> <div 
class="_1H1Z49Dr_0"> 2019-04-11 </div> </div> <div class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> 
<i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> </div> </div> <div 
class="_3M6kV3zb_0"> DAY45，打卡 <br> </div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> 
</div> <!----> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/10/95/58/95e9507d.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>我不吃甜食</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-23 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 老师好，能不能讲一下select，poll和epoll的本质区别？ </div> 
<!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: C10K篇里面已经讲过了</p> </div> </div></li> 
<li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/12/8c/2b/3ab96998.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>青石</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-21 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> @记忆的问题“老师你好，如果sk_buff 缓冲区 （socket buffer）不是套接字缓冲器区,那是不是还要进行一次数据的copy到套接字缓冲区，再通知应用程序有某个套接字数据可读了？那一帧数据到来，需要收包队列--&gt;sk_buff--&gt;套接字缓冲区--&gt;应用程序空间内存里，拷贝了3次呢？” 
<br> <br>老师的回复是“这是两个不同的概念，具体到数据上，内核协议栈都是操作指针，并不会在不同协议层之间复制数据”。 <br> <br>我的理解是，收包队列、sk_buff、套接字缓冲区、应用程序空间内存，都是链接表结构，收保队列-&gt;sk_buff的过程，是sk_buff的指针指向收保队列的链头，再重新给收包队列分配空链表，内存上只是单纯的指针移动，并不涉及数据迁移。 
<br> <br>不知道理解对不对，还请老师指正。 </div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> 
</div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 可以简单这么理解，但实际上也不准确，对同一个网络报文来说，不同协议栈层处理的是同一个pkt不同位置的数据（同一个struct内部），而不是链表中的不同item。真要理解的话，还是推荐去看一下内核源码</p> 
</div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/13/57/6e/dd0eee5f.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>夜空中最亮...</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-06 </div> </div> <div 
class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> 
</div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0"> 有一篇收获满满 </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <!----> </div></li> <li class="reJj6Thl_0"><img 
src="https://static001.geekbang.org/account/avatar/00/14/11/4b/fa64f061.jpg" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>xfan</span> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-06 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> 这一张满满干货， </div> <div class="_2r3UB1GX_0"> <span>展开</span><i 
class="iconfont"></i> </div> <!----> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/15/91/b4/d5d9e4fb.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>爱学习的小...</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-06 </div> </div> <div 
class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> 
</div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 客户端和服务端nginx连接80端口时，nginx会fork出一个子进程选一个随机端口与客户端建立连接吗？ 
</div> <!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 正好反正，客户端会随机一个端口去连接80端口</p> 
</div> </div></li>', delta=0, field_comment_format='full_html', langcode='zh-hans', revision_id=1078 
where entity_id=1078 
 {executed in 4 msec}
2020-11-25 10:10:49.077 INFO  jdbc.sqltiming Line:373 - select nodefieldc0_.entity_id as entity_i1_14_0_, nodefieldc0_.bundle as bundle2_14_0_, nodefieldc0_.field_comment_value 
as field_co3_14_0_, nodefieldc0_.delta as delta4_14_0_, nodefieldc0_.field_comment_format as 
field_co5_14_0_, nodefieldc0_.langcode as langcode6_14_0_, nodefieldc0_.revision_id as revision7_14_0_ 
from node_revision__field_comment nodefieldc0_ where nodefieldc0_.entity_id=1078 
 {executed in 0 msec}
2020-11-25 10:10:49.077 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|--------------------|------|---------------------|---------|------------|
|entity_id |bundle |field_comment_value |delta |field_comment_format |langcode |revision_id |
|----------|-------|--------------------|------|---------------------|---------|------------|
|[unread]  |book   |                    |0     |full_html            |zh-hans  |1078        |
|----------|-------|--------------------|------|---------------------|---------|------------|

2020-11-25 10:10:49.079 INFO  jdbc.sqltiming Line:373 - update node_revision__field_comment set bundle='book', field_comment_value='<li class="reJj6Thl_0"><img 
src="https://static001.geekbang.org/account/avatar/00/14/17/4a/d8fd5563.jpg" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>记忆</span> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-14 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> </div> <!----> 
<!----> </div> </div> <div class="_3M6kV3zb_0"> 老师你好，如果sk_buff 缓冲区 （socket buffer）不是套接字缓冲器区,那是不是还要进行一次数据的copy到套接字缓冲区，再通知应用程序有某个套接字数据可读了？那一帧数据到来，需要收包队列--&gt;sk_buff--&gt;套接字缓冲区--&gt;应用程序空间内存里，拷贝了3次呢？ 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 这是两个不同的概念，具体到数据上，内核协议栈都是操作指针，并不会在不同协议层之间复制数据</p> </div> </div></li> 
<li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/11/52/c3/896f3410.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>kissingers</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-10 </div> </div> <div 
class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> 
</div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> sk_buff 缓冲区 （socket 
buffer）不是套接字缓冲器区吗？ </div> <!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 不是的，文中有介绍他们的含义</p> 
</div> </div></li> <li class="reJj6Thl_0"><img src="" class="_2273kGdT_0"> <div class="_2CG0SquK_0"> 
<div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>腾达</span> <!----> </div> <div 
class="_1H1Z49Dr_0"> 2019-03-06 </div> </div> <div class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> 
<i class="iconfont"></i> <span class="">1</span> </div> <!----> <!----> </div> </div> <div 
class="_3M6kV3zb_0"> 能不能再出一个有关TIME_WAIT、peer reset、socket read timeout、socket connect timeout 
方面有关的案例？ 类似java、php、nginx，做应用开发的会遇到很多这类问题。之前有网友提问：期待结合生产环境对这几个内核参数的讲解。目前生产环境下php服务器time_wait特别多，网络包的流程： 
NGINX代理&lt;——&gt;PHP服务器——&gt;redis/mysql.. <br>高峰时期php服务器一共50k+的连接。49k+的time_wait。 我看到老师回复”后面会有的“。难道是《案例篇：如何优化NAT性能》里一笔带过的有关TIME_WAIT的东西？ 
能否专门出一个偏开发人员方面的网络案例？ 网络篇里的案例大部分人都说不太跟的上，基础都不好，可能大部分人都是偏开发，网络接触的少，像NAT更是很少人接触了。希望再出一个偏开发人员适用的网络的案例 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 后面的案例还会讲到timeout的</p> </div> </div></li> <li class="reJj6Thl_0"><img 
src="http://thirdwx.qlogo.cn/mmopen/vi_32/2o1Izf2YyJSnnI0ErZ51pYRlnrmibqUTaia3tCU1PjMxuwyXSKOLUYiac2TQ5pd5gNGvS81fVqKWGvDsZLTM8zhWg/132" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>划时代</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-06 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> </div> <!----> 
<!----> </div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 最近在广泛收集资料学习老师讲的C10K到C1000K的问题，打卡总结。 
</div> <!----> <!----> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>我来也</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-06 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> </div> <!----> 
<!----> </div> </div> <div class="_3M6kV3zb_0"> 试着回答下同学的提问。 <br>nginx fork出来的子进程数是可以配置的。 <br>有连接请求时，可能是选一个子进程响应连接请求（这个不太确定，也可能是主进程建立连接了交给子进程）。 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 这是可配置的，也可以开启reuseport交给你系统来选择</p> </div> </div></li> <li class="reJj6Thl_0"><img 
src="https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>我来也</span> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-06 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> </div> <!----> 
<!----> </div> </div> <div class="_3M6kV3zb_0"> [D45打卡] <br>四大模块学完了，接下来就是融会贯通了。😄 <br> <br>以前也知道socket连接是通过五元组唯一确定的，但实际写服务端程序时，还是会根据经验限定到65530。 
<br>现在想来，当时还是理解的不够透彻。 <br>这个经验值当时是根据压力测试得来的，当时只用了一台机器去测连接数。🤦‍♂️如果用多个机器测可能好点。 <br>另一个是服务器端单进程同时打开的文件数限制，平常限制的也是65535（可以继续调大）。一个进程默认还会打开2个文件，stdout 
stderr，所以需要再减2，如果有监听一个端口，还需要再减1。 <br>有一次在生产环境中，同时连接数限制的是65535，结果到65533个连接时，把监听的端口给关闭了。（可能是所用框架导致的）虽然已有的连接未受影响，但之后就无法再接受新连接了。 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 嗯，谢谢分享。不过线上环境也不推荐一直运行在达到资源极限的场景，最好是预留一些资源以便应对异常情况</p> </div> </div></li> 
<li class="reJj6Thl_0"><img src="https://wx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEKQMM4m7NHuicr55aRiblTSEWIYe0QqbpyHweaoAbG7j2v7UUElqqeP3Ihrm3UfDPDRb1Hv8LvPwXqA/132" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>ninuxer</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-06 </div> </div> <div 
class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> 
</div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 打卡day47 <br>很高兴一直没掉队，网络一直是我的短板，得补补 
</div> <!----> <!----> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/0f/67/77/c1310aad.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>剑衣清风</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-04-28 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> 老师你好，对于问题3我有个疑问 <br> <br>“对客户端来说，每次发起 TCP 连接请求时，都需要分配一个空闲的本地端口，去连接远端的服务器。由于这个本地端口是独占的，所以客户端最多只能发起 
65535 个连接。” <br> <br>那像 ab 这样的压测工具，是如何做到并发对服务端接口压测的？ </div> <div class="_2r3UB1GX_0"> <span>展开</span><i 
class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 为客户端分配不同的端口去连接服务端，请求量大的时候还需要多机或多IP增大请求数</p> 
</div> </div></li> <li class="reJj6Thl_0"><img src="" class="_2273kGdT_0"> <div class="_2CG0SquK_0"> 
<div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>如果</span> <!----> </div> <div 
class="_1H1Z49Dr_0"> 2019-04-11 </div> </div> <div class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> 
<i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> </div> </div> <div 
class="_3M6kV3zb_0"> DAY45，打卡 <br> </div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> 
</div> <!----> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/10/95/58/95e9507d.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>我不吃甜食</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-23 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 老师好，能不能讲一下select，poll和epoll的本质区别？ </div> 
<!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: C10K篇里面已经讲过了</p> </div> </div></li> 
<li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/12/8c/2b/3ab96998.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>青石</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-21 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> @记忆的问题“老师你好，如果sk_buff 缓冲区 （socket buffer）不是套接字缓冲器区,那是不是还要进行一次数据的copy到套接字缓冲区，再通知应用程序有某个套接字数据可读了？那一帧数据到来，需要收包队列--&gt;sk_buff--&gt;套接字缓冲区--&gt;应用程序空间内存里，拷贝了3次呢？” 
<br> <br>老师的回复是“这是两个不同的概念，具体到数据上，内核协议栈都是操作指针，并不会在不同协议层之间复制数据”。 <br> <br>我的理解是，收包队列、sk_buff、套接字缓冲区、应用程序空间内存，都是链接表结构，收保队列-&gt;sk_buff的过程，是sk_buff的指针指向收保队列的链头，再重新给收包队列分配空链表，内存上只是单纯的指针移动，并不涉及数据迁移。 
<br> <br>不知道理解对不对，还请老师指正。 </div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> 
</div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 可以简单这么理解，但实际上也不准确，对同一个网络报文来说，不同协议栈层处理的是同一个pkt不同位置的数据（同一个struct内部），而不是链表中的不同item。真要理解的话，还是推荐去看一下内核源码</p> 
</div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/13/57/6e/dd0eee5f.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>夜空中最亮...</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-06 </div> </div> <div 
class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> 
</div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0"> 有一篇收获满满 </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <!----> </div></li> <li class="reJj6Thl_0"><img 
src="https://static001.geekbang.org/account/avatar/00/14/11/4b/fa64f061.jpg" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>xfan</span> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-06 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> 这一张满满干货， </div> <div class="_2r3UB1GX_0"> <span>展开</span><i 
class="iconfont"></i> </div> <!----> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/15/91/b4/d5d9e4fb.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>爱学习的小...</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-06 </div> </div> <div 
class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> 
</div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 客户端和服务端nginx连接80端口时，nginx会fork出一个子进程选一个随机端口与客户端建立连接吗？ 
</div> <!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 正好反正，客户端会随机一个端口去连接80端口</p> 
</div> </div></li>', delta=0, field_comment_format='full_html', langcode='zh-hans', revision_id=1078 
where entity_id=1078 
 {executed in 0 msec}
2020-11-25 10:10:49.082 INFO  jdbc.sqltiming Line:373 - select bookfieldt0_.entity_id as entity_i1_9_, bookfieldt0_.bundle as bundle2_9_, bookfieldt0_.delta 
as delta3_9_, bookfieldt0_.langcode as langcode4_9_, bookfieldt0_.revision_id as revision5_9_, 
bookfieldt0_.field_thumb_value as field_th6_9_ from node__field_thumb bookfieldt0_ where bookfieldt0_.entity_id=1078 
 {executed in 0 msec}
2020-11-25 10:10:49.083 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------|------------------|
|entity_id |bundle |delta |langcode |revision_id |field_thumb_value |
|----------|-------|------|---------|------------|------------------|
|1078      |book   |0     |zh-hans  |1078        |                  |
|----------|-------|------|---------|------------|------------------|

2020-11-25 10:10:49.084 INFO  jdbc.sqltiming Line:373 - update node__field_thumb set bundle='book', delta=0, langcode='zh-hans', revision_id=1078, 
field_thumb_value='https://static001.geekbang.org/resource/image/83/6e/83ecbb10ffd51d6a9bfd2c01b719716e.jpg' 
where entity_id=1078 
 {executed in 0 msec}
2020-11-25 10:10:49.087 INFO  jdbc.sqltiming Line:373 - select nodefieldt0_.entity_id as entity_i1_18_0_, nodefieldt0_.bundle as bundle2_18_0_, nodefieldt0_.delta 
as delta3_18_0_, nodefieldt0_.langcode as langcode4_18_0_, nodefieldt0_.revision_id as revision5_18_0_, 
nodefieldt0_.field_thumb_value as field_th6_18_0_ from node_revision__field_thumb nodefieldt0_ 
where nodefieldt0_.entity_id=1078 
 {executed in 0 msec}
2020-11-25 10:10:49.087 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------|------------------|
|entity_id |bundle |delta |langcode |revision_id |field_thumb_value |
|----------|-------|------|---------|------------|------------------|
|[unread]  |book   |0     |zh-hans  |1078        |                  |
|----------|-------|------|---------|------------|------------------|

2020-11-25 10:10:49.089 INFO  jdbc.sqltiming Line:373 - update node_revision__field_thumb set bundle='book', delta=0, langcode='zh-hans', revision_id=1078, 
field_thumb_value='https://static001.geekbang.org/resource/image/83/6e/83ecbb10ffd51d6a9bfd2c01b719716e.jpg' 
where entity_id=1078 
 {executed in 1 msec}
2020-11-25 10:10:49.091 INFO  jdbc.sqltiming Line:373 - select bookfieldf0_.entity_id as entity_i1_6_0_, bookfieldf0_.bundle as bundle2_6_0_, bookfieldf0_.delta 
as delta3_6_0_, bookfieldf0_.field_fenlei_target_id as field_fe4_6_0_, bookfieldf0_.langcode 
as langcode5_6_0_, bookfieldf0_.revision_id as revision6_6_0_ from node__field_fenlei bookfieldf0_ 
where bookfieldf0_.entity_id=1078 
 {executed in 0 msec}
2020-11-25 10:10:49.092 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|-----------------------|---------|------------|
|entity_id |bundle |delta |field_fenlei_target_id |langcode |revision_id |
|----------|-------|------|-----------------------|---------|------------|
|[unread]  |book   |0     |1                      |zh-hans  |1078        |
|----------|-------|------|-----------------------|---------|------------|

2020-11-25 10:10:49.093 INFO  jdbc.sqltiming Line:373 - select nodefieldf0_.entity_id as entity_i1_15_0_, nodefieldf0_.bundle as bundle2_15_0_, nodefieldf0_.delta 
as delta3_15_0_, nodefieldf0_.field_fenlei_target_id as field_fe4_15_0_, nodefieldf0_.langcode 
as langcode5_15_0_, nodefieldf0_.revision_id as revision6_15_0_ from node_revision__field_fenlei 
nodefieldf0_ where nodefieldf0_.entity_id=1078 
 {executed in 0 msec}
2020-11-25 10:10:49.094 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|-----------------------|---------|------------|
|entity_id |bundle |delta |field_fenlei_target_id |langcode |revision_id |
|----------|-------|------|-----------------------|---------|------------|
|[unread]  |book   |0     |1                      |zh-hans  |1078        |
|----------|-------|------|-----------------------|---------|------------|

2020-11-25 10:10:49.095 INFO  jdbc.sqltiming Line:373 - select bookchecke0_.item_id as item_id1_2_, bookchecke0_.fsid as fsid2_2_, bookchecke0_.got 
as got3_2_, bookchecke0_.name as name4_2_, bookchecke0_.parse_fail as parse_fa5_2_, bookchecke0_.parsed 
as parsed6_2_, bookchecke0_.path as path7_2_, bookchecke0_.title as title8_2_, bookchecke0_.vid 
as vid9_2_ from book_check bookchecke0_ where bookchecke0_.fsid='87870143026819' and bookchecke0_.name='net_content' 
 {executed in 0 msec}
2020-11-25 10:10:49.096 INFO  jdbc.resultsettable Line:610 - 
|--------|---------|---------|---------|-----------|---------|---------|---------|---------|
|item_id |fsid     |got      |name     |parse_fail |parsed   |path     |title    |vid      |
|--------|---------|---------|---------|-----------|---------|---------|---------|---------|
|1079    |[unread] |[unread] |[unread] |[unread]   |[unread] |[unread] |[unread] |[unread] |
|--------|---------|---------|---------|-----------|---------|---------|---------|---------|

2020-11-25 10:11:25.934 INFO  jdbc.sqltiming Line:373 - update book_check set fsid='87870143026819', got=1, name='net_content', parse_fail='', parsed=1, 
path='12-Linux性能优化实战/06-综合实战篇 (13讲)/46丨案例篇：为什么应用容器化后，启动慢了很多？.html', title='46丨案例篇：为什么应用容器化后，启动慢了很多？', 
vid=1079 where item_id=1079 
 {executed in 1 msec}
2020-11-25 10:11:25.942 INFO  jdbc.sqltiming Line:373 - select nodebodyen0_.entity_id as entity_i1_4_, nodebodyen0_.body_value as body_val2_4_, nodebodyen0_.body_summary 
as body_sum3_4_, nodebodyen0_.bundle as bundle4_4_, nodebodyen0_.delta as delta5_4_, nodebodyen0_.body_format 
as body_for6_4_, nodebodyen0_.langcode as langcode7_4_, nodebodyen0_.revision_id as revision8_4_ 
from node__body nodebodyen0_ where nodebodyen0_.entity_id=1079 
 {executed in 0 msec}
2020-11-25 10:11:25.942 INFO  jdbc.resultsettable Line:610 - 
|----------|-----------|-------------|-------|------|------------|---------|------------|
|entity_id |body_value |body_summary |bundle |delta |body_format |langcode |revision_id |
|----------|-----------|-------------|-------|------|------------|---------|------------|
|1079      |           |             |book   |0     |full_html   |zh-hans  |1079        |
|----------|-----------|-------------|-------|------|------------|---------|------------|

2020-11-25 10:11:25.943 INFO  jdbc.sqltiming Line:373 - select nodebodyre0_.entity_id as entity_i1_13_0_, nodebodyre0_.body_value as body_val2_13_0_, 
nodebodyre0_.body_summary as body_sum3_13_0_, nodebodyre0_.bundle as bundle4_13_0_, nodebodyre0_.delta 
as delta5_13_0_, nodebodyre0_.body_format as body_for6_13_0_, nodebodyre0_.langcode as langcode7_13_0_, 
nodebodyre0_.revision_id as revision8_13_0_ from node_revision__body nodebodyre0_ where nodebodyre0_.entity_id=1079 
 {executed in 0 msec}
2020-11-25 10:11:25.944 INFO  jdbc.resultsettable Line:610 - 
|----------|-----------|-------------|-------|------|------------|---------|------------|
|entity_id |body_value |body_summary |bundle |delta |body_format |langcode |revision_id |
|----------|-----------|-------------|-------|------|------------|---------|------------|
|[unread]  |           |             |book   |0     |full_html   |zh-hans  |1079        |
|----------|-----------|-------------|-------|------|------------|---------|------------|

2020-11-25 10:11:25.948 INFO  jdbc.sqltiming Line:373 - update node__body set body_value='<p>你好，我是倪朋飞。</p> <p>不知不觉，我们已经学完了整个专栏的四大基础模块，即 CPU、内存、文件系统和磁盘 
I/O、以及网络的性能分析和优化。相信你已经掌握了这些基础模块的基本分析、定位思路，并熟悉了相关的优化方法。</p> <p>接下来，我们将进入最后一个重要模块—— 综合实战篇。这部分实战内容，也将是我们对前面所学知识的复习和深化。</p> 
<p>我们都知道，随着 Kubernetes、Docker 等技术的普及，越来越多的企业，都已经走上了应用程序容器化的道路。我相信，你在了解学习这些技术的同时，一定也听说过不少，基于 
Docker 的微服务架构带来的各种优势，比如：</p> <ul> <li> <p>使用 Docker ，把应用程序以及相关依赖打包到镜像中后，部署和升级更快捷；</p> </li> 
<li> <p>把传统的单体应用拆分成多个更小的微服务应用后，每个微服务的功能都更简单，并且可以单独管理和维护；</p> </li> <li> <p>每个微服务都可以根据需求横向扩展。即使发生故障，也只是局部服务不可用，而不像以前那样，导致整个服务不可用。</p> 
</li> </ul> <p>不过，任何技术都不是银弹。这些新技术，在带来诸多便捷功能之外，也带来了更高的复杂性，比如性能降低、架构复杂、排错困难等等。</p> <p>今天，我就通过一个 
Tomcat 案例，带你一起学习，如何分析应用程序容器化后的性能问题。</p><!-- [[[read_end]]] --> <h2>案例准备</h2> <p>今天的案例，我们只需要一台虚拟机。还是基于 
Ubuntu 18.04，同样适用于其他的 Linux 系统。我使用的案例环境如下所示：</p> <ul> <li> <p>机器配置：2 CPU，8GB 内存。</p> </li> 
<li> <p>预先安装 docker、curl、jq、pidstat 等工具，如 apt install docker.io curl jq sysstat。</p> </li> 
</ul> <p>其中，jq 工具专门用来在命令行中处理 json。为了更好的展示 json 数据，我们用这个工具，来格式化 json 输出。</p> <p>你需要打开两个终端，登录到同一台虚拟机中，并安装上述工具。</p> 
<p>注意，以下所有命令都默认以 root 用户运行，如果你用普通用户身份登陆系统，请运行 sudo su root 命令切换到 root 用户。</p> <blockquote> 
<p>如果安装过程有问题，你可以先上网搜索解决，实在解决不了的，记得在留言区向我提问。</p> </blockquote> <p>到这里，准备工作就完成了。接下来，我们正式进入操作环节。</p> 
<h2>案例分析</h2> <p>我们今天要分析的案例，是一个 Tomcat 应用。Tomcat 是 Apache 基金会旗下，Jakarta 项目开发的轻量级应用服务器，它基于 Java 
语言开发。Docker 社区也维护着 Tomcat 的<a href="https://hub.docker.com/_/tomcat">官方镜像</a>，你可以直接使用这个镜像，来启动一个 
Tomcat 应用。</p> <p>我们的案例，也基于 Tomcat 的官方镜像构建，其核心逻辑很简单，就是分配一点儿内存，并输出 “Hello, world!”。</p> <pre 
style="position: relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> &lt;% </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
byte data[] = new byte[256*1024*1024]; </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> out.println("Hello, wolrd!"); </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> %&gt; </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <p>为了方便你运行，我已经将它打包成了一个 <a href="https://github.com/feiskyer/linux-perf-examples/tree/master/tomcat">Docker 
镜像</a> feisky/tomcat:8，并推送到了 Docker Hub 中。你可以直接按照下面的步骤来运行它。</p> <p>在终端一中，执行下面的命令，启动 Tomcat 
应用，并监听 8080 端口。如果一切正常，你应该可以看到如下的输出：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> 
<tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> # -m 表示设置内存为 512MB </div></td> </tr> <tr> 
<td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ docker run --name tomcat --cpus 0.1 
-m 512M -p 8080:8080 -itd feisky/tomcat:8 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> Unable to find image ''feisky/tomcat:8'' locally </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 8: Pulling from feisky/tomcat </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 741437d97401: Pull complete </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> ... </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 22cd96a25579: Pull complete </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> Digest: sha256:71871cff17b9043842c2ec99f370cc9f1de7bc121cd2c02d8e2092c6e268f7e2 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> Status: Downloaded newer image for feisky/tomcat:8 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> WARNING: Your kernel does not support 
swap limit capabilities or the cgroup is not mounted. Memory limited without swap. </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 2df259b752db334d96da26f19166d662a82283057411f6332f3cbdbcab452249 
</div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>从输出中，你可以看到，docker run 命令，会自动拉取镜像并启动容器。</p> <p>这里顺便提一下，之前很多同学留言问，到底要怎么下载 Docker 
镜像。其实，上面的 docker run，就是自动下载镜像到本地后，才开始运行的。</p> <p>由于 Docker 镜像分多层管理，所以在下载时，你会看到每层的下载进度。除了像 docker 
run 这样自动下载镜像外，你也可以分两步走，先下载镜像，然后再运行容器。</p> <p>比如，你可以先运行下面的 docker pull 命令，下载镜像：</p> <pre style="position: 
relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
$ docker pull feisky/tomcat:8 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
8: Pulling from feisky/tomcat </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
Digest: sha256:71871cff17b9043842c2ec99f370cc9f1de7bc121cd2c02d8e2092c6e268f7e2 </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> Status: Image is up to date for feisky/tomcat:8 
</div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>显然，在我的机器中，镜像已存在，所以就不需要再次下载，直接返回成功就可以了。</p> <p>接着，在终端二中使用 curl，访问 Tomcat 监听的 
8080 端口，确认案例已经正常启动：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ curl localhost:8080 </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> curl: (56) Recv failure: Connection reset 
by peer </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span 
class="iconfont"></span>复制代码 </div></pre> <p>不过，很不幸，curl 返回了 “Connection reset by peer” 的错误，说明 
Tomcat 服务，并不能正常响应客户端请求。</p> <p>是不是 Tomcat 启动出问题了呢？我们切换到终端一中，执行 docker logs 命令，查看容器的日志。这里注意，需要加上 
-f 参数，表示跟踪容器的最新日志输出：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ docker logs -f tomcat </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> Using CATALINA_BASE: /usr/local/tomcat 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> Using CATALINA_HOME: /usr/local/tomcat 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> Using CATALINA_TMPDIR: /usr/local/tomcat/temp 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> Using JRE_HOME: /docker-java-home/jre 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> Using CLASSPATH: /usr/local/tomcat/bin/bootstrap.jar:/usr/local/tomcat/bin/tomcat-juli.jar 
</div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>从这儿你可以看到，Tomcat 容器只打印了环境变量，还没有应用程序初始化的日志。也就是说，Tomcat 还在启动过程中，这时候去访问它，当然没有响应。</p> 
<p>为了观察 Tomcat 的启动过程，我们在终端一中，继续保留 docker logs -f 命令，并在终端二中执行下面的命令，多次尝试访问 Tomcat：</p> <pre style="position: 
relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
$ for ((i=0;i&lt;30;i++)); do curl localhost:8080; sleep 1; done </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> curl: (56) Recv failure: Connection reset 
by peer </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="3"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> curl: 
(56) Recv failure: Connection reset by peer </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> # 这儿会阻塞一会 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> <td class="hljs-ln-code"> <div 
class="hljs-ln-line"> Hello, wolrd! </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> <td class="hljs-ln-code"> <div 
class="hljs-ln-line"> curl: (52) Empty reply from server </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> curl: (7) Failed to connect to localhost port 8080: Connection refused 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> curl: (7) Failed to connect to localhost 
port 8080: Connection refused </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <p>观察一会儿，可以看到，一段时间后，curl 终于给出了我们想要的结果 “Hello, 
wolrd!”。但是，随后又出现了 “Empty reply from server” ，和一直持续的 “Connection refused” 错误。换句话说，Tomcat 响应一次请求后，就再也不响应了。</p> 
<p>这是怎么回事呢？我们回到终端一中，观察 Tomcat 的日志，看看能不能找到什么线索。</p> <p>从终端一中，你应该可以看到下面的输出：</p> <pre style="position: 
relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
18-Feb-2019 12:43:32.719 INFO [localhost-startStop-1] org.apache.catalina.startup.HostConfig.deployDirectory 
Deploying web application directory [/usr/local/tomcat/webapps/docs] </div></td> </tr> <tr> 
<td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 18-Feb-2019 12:43:33.725 INFO [localhost-startStop-1] 
org.apache.catalina.startup.HostConfig.deployDirectory Deployment of web application directory 
[/usr/local/tomcat/webapps/docs] has finished in [1,006] ms </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 18-Feb-2019 12:43:33.726 INFO [localhost-startStop-1] org.apache.catalina.startup.HostConfig.deployDirectory 
Deploying web application directory [/usr/local/tomcat/webapps/manager] </div></td> </tr> <tr> 
<td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 18-Feb-2019 12:43:34.521 INFO [localhost-startStop-1] 
org.apache.catalina.startup.HostConfig.deployDirectory Deployment of web application directory 
[/usr/local/tomcat/webapps/manager] has finished in [795] ms </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 18-Feb-2019 12:43:34.722 INFO [main] org.apache.coyote.AbstractProtocol.start 
Starting ProtocolHandler ["http-nio-8080"] </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 18-Feb-2019 12:43:35.319 INFO [main] org.apache.coyote.AbstractProtocol.start 
Starting ProtocolHandler ["ajp-nio-8009"] </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 18-Feb-2019 12:43:35.821 INFO [main] org.apache.catalina.startup.Catalina.start 
Server startup in 24096 ms </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="8"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
root@ubuntu:~# </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <p>从内容上可以看到，Tomcat 在启动 24s 后完成初始化，并且正常启动。从日志上来看，没有什么问题。</p> 
<p>不过，细心的你肯定注意到了最后一行，明显是回到了 Linux 的 SHELL 终端中，而没有继续等待 Docker 输出的容器日志。</p> <p>输出重新回到 SHELL 终端，通常表示上一个命令已经结束。而我们的上一个命令，是 
docker logs -f 命令。那么，它的退出就只有两种可能了，要么是容器退出了，要么就是 dockerd 进程退出了。</p> <p>究竟是哪种情况呢？这就需要我们进一步确认了。我们可以在终端一中，执行下面的命令，查看容器的状态：</p> 
<pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> $ docker ps -a </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 0f2b3fcdd257 feisky/tomcat:8 "catalina.sh 
run" 2 minutes ago Exited (137) About a minute ago tomcat </div></td> </tr> </tbody> </table></code> 
<div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 </div></pre> <p>你会看到，容器处于 
Exited 状态，说明是第一种情况，容器已经退出。不过为什么会这样呢？显然，在前面容器的日志里，我们并没有发现线索，那就只能从 Docker 本身入手了。</p> <p>我们可以调用 
Docker 的 API，查询容器的状态、退出码以及错误信息，然后确定容器退出的原因。这些可以通过 docker inspect 命令来完成，比如，你可以继续执行下面的命令，通过 -f 
选项设置只输出容器的状态：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> <tr> 
<td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> # 显示容器状态，jq 用来格式化 json 输出 </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ docker inspect tomcat -f ''{{json .State}}'' 
| jq </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="3"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> { </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> "Status": "exited", </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> "Running": false, </div></td> </tr> <tr> 
<td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> "Paused": false, </div></td> </tr> <tr> 
<td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> "Restarting": false, </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> "OOMKilled": true, </div></td> </tr> <tr> 
<td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> "Dead": false, </div></td> </tr> <tr> 
<td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> "Pid": 0, </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> "ExitCode": 137, </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> "Error": "", </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="13"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> ... </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="14"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
} </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>这次你可以看到，容器已经处于 exited 状态，OOMKilled 是 true，ExitCode 是 137。这其中，OOMKilled 表示容器被 
OOM 杀死了。</p> <p>我们前面提到过，OOM 表示内存不足时，某些应用会被系统杀死。可是，为什么内存会不足呢？我们的应用分配了 256 MB 的内存，而容器启动时，明明通过 
-m 选项，设置了 512 MB 的内存，按说应该是足够的。</p> <p>到这里，我估计你应该还记得，当 OOM 发生时，系统会把相关的 OOM 信息，记录到日志中。所以，接下来，我们可以在终端中执行 
dmesg 命令，查看系统日志，并定位 OOM 相关的日志：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> 
<tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ dmesg </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> [193038.106393] java invoked oom-killer: gfp_mask=0x14000c0(GFP_KERNEL), 
nodemask=(null), order=0, oom_score_adj=0 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> [193038.106396] java cpuset=0f2b3fcdd2578165ea77266cdc7b1ad43e75877b0ac1889ecda30a78cb78bd53 
mems_allowed=0 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
[193038.106402] CPU: 0 PID: 27424 Comm: java Tainted: G OE 4.15.0-1037 #39-Ubuntu </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> [193038.106404] Hardware name: Microsoft 
Corporation Virtual Machine/Virtual Machine, BIOS 090007 06/02/2017 </div></td> </tr> <tr> 
<td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> [193038.106405] Call Trace: </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> [193038.106414] dump_stack+0x63/0x89 </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> [193038.106419] dump_header+0x71/0x285 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> [193038.106422] oom_kill_process+0x220/0x440 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> [193038.106424] out_of_memory+0x2d1/0x4f0 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> [193038.106429] mem_cgroup_out_of_memory+0x4b/0x80 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> [193038.106432] mem_cgroup_oom_synchronize+0x2e8/0x320 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="13"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> [193038.106435] ? mem_cgroup_css_online+0x40/0x40 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="14"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> [193038.106437] pagefault_out_of_memory+0x36/0x7b 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="15"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> [193038.106443] mm_fault_error+0x90/0x180 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="16"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> [193038.106445] __do_page_fault+0x4a5/0x4d0 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="17"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> [193038.106448] do_page_fault+0x2e/0xe0 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="18"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> [193038.106454] ? page_fault+0x2f/0x50 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="19"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> [193038.106456] page_fault+0x45/0x50 </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="20"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> [193038.106459] RIP: 0033:0x7fa053e5a20d 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="21"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> [193038.106460] RSP: 002b:00007fa0060159e8 
EFLAGS: 00010206 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="22"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
[193038.106462] RAX: 0000000000000000 RBX: 00007fa04c4b3000 RCX: 0000000009187440 </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="23"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> [193038.106463] RDX: 00000000943aa440 
RSI: 0000000000000000 RDI: 000000009b223000 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="24"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> [193038.106464] RBP: 00007fa006015a60 R08: 0000000002000002 R09: 
00007fa053d0a8a1 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="25"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
[193038.106465] R10: 00007fa04c018b80 R11: 0000000000000206 R12: 0000000100000768 </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="26"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> [193038.106466] R13: 00007fa04c4b3000 
R14: 0000000100000768 R15: 0000000010000000 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="27"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> [193038.106468] Task in /docker/0f2b3fcdd2578165ea77266cdc7b1ad43e75877b0ac1889ecda30a78cb78bd53 
killed as a result of limit of /docker/0f2b3fcdd2578165ea77266cdc7b1ad43e75877b0ac1889ecda30a78cb78bd53 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="28"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> [193038.106478] memory: usage 524288kB, 
limit 524288kB, failcnt 77 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="29"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
[193038.106480] memory+swap: usage 0kB, limit 9007199254740988kB, failcnt 0 </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="30"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> [193038.106481] kmem: usage 3708kB, limit 
9007199254740988kB, failcnt 0 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="31"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
[193038.106481] Memory cgroup stats for /docker/0f2b3fcdd2578165ea77266cdc7b1ad43e75877b0ac1889ecda30a78cb78bd53: 
cache:0KB rss:520580KB rss_huge:450560KB shmem:0KB mapped_file:0KB dirty:0KB writeback:0KB 
inactive_anon:0KB active_anon:520580KB inactive_file:0KB active_file:0KB unevictable:0KB </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="32"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> [193038.106494] [ pid ] uid tgid total_vm 
rss pgtables_bytes swapents oom_score_adj name </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="33"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> [193038.106571] [27281] 0 27281 1153302 134371 1466368 0 0 java 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="34"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> [193038.106574] Memory cgroup out of memory: 
Kill process 27281 (java) score 1027 or sacrifice child </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="35"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> [193038.148334] Killed process 27281 (java) total-vm:4613208kB, 
anon-rss:517316kB, file-rss:20168kB, shmem-rss:0kB </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="36"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> [193039.607503] oom_reaper: reaped process 27281 (java), now anon-rss:0kB, 
file-rss:0kB, shmem-rss:0kB </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <p>从 dmesg 的输出，你就可以看到很详细的 OOM 记录了。你应该可以看到下面几个关键点。</p> 
<ul> <li> <p>第一，被杀死的是一个 java 进程。从内核调用栈上的 mem_cgroup_out_of_memory 可以看出，它是因为超过 cgroup 的内存限制，而被 
OOM 杀死的。</p> </li> <li> <p>第二，java 进程是在容器内运行的，而容器内存的使用量和限制都是 512M（524288kB）。目前使用量已经达到了限制，所以会导致 
OOM。</p> </li> <li> <p>第三，被杀死的进程，PID 为 27281，虚拟内存为 4.3G（total-vm:4613208kB），匿名内存为 505M（anon-rss:517316kB），页内存为 
19M（20168kB）。换句话说，匿名内存是主要的内存占用。而且，匿名内存加上页内存，总共是 524M，已经超过了 512M 的限制。</p> </li> </ul> <p>综合这几点，可以看出，Tomcat 
容器的内存主要用在了匿名内存中，而匿名内存，其实就是主动申请分配的堆内存。</p> <p>不过，为什么 Tomcat 会申请这么多的堆内存呢？要知道，Tomcat 是基于 Java 
开发的，所以应该不难想到，这很可能是 JVM 堆内存配置的问题。</p> <p>我们知道，JVM 根据系统的内存总量，来自动管理堆内存，不明确配置的话，堆内存的默认限制是物理内存的四分之一。不过，前面我们已经限制了容器内存为 
512 M，java 的堆内存到底是多少呢？</p> <p>我们继续在终端中，执行下面的命令，重新启动 tomcat 容器，并调用 java 命令行来查看堆内存大小：</p> <pre 
style="position: relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> # 重新启动容器 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> <div 
class="hljs-ln-line"> $ docker rm -f tomcat </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> $ docker run --name tomcat --cpus 0.1 -m 512M -p 8080:8080 -itd 
feisky/tomcat:8 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> # 查看堆内存，注意单位是字节 </div></td> </tr> <tr> 
<td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ docker exec tomcat java -XX:+PrintFlagsFinal 
-version | grep HeapSize </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="7"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
uintx ErgoHeapSizeLimit = 0 {product} </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></td> <td class="hljs-ln-code"> <div 
class="hljs-ln-line"> uintx HeapSizePerGCThread = 87241520 {product} </div></td> </tr> <tr> 
<td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> uintx InitialHeapSize := 132120576 {product} 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> uintx LargePageHeapSizeThreshold = 134217728 
{product} </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="11"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> uintx 
MaxHeapSize := 2092957696 {product} </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <p>你可以看到，初始堆内存的大小（InitialHeapSize）是 126MB，而最大堆内存则是 
1.95GB，这可比容器限制的 512 MB 大多了。</p> <p>之所以会这么大，其实是因为，容器内部看不到 Docker 为它设置的内存限制。虽然在启动容器时，我们通过 -m 
512M 选项，给容器设置了 512M 的内存限制。但实际上，从容器内部看到的限制，却并不是 512M。</p> <p>我们在终端中，继续执行下面的命令：</p> <pre style="position: 
relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
$ docker exec tomcat free -m </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
total used free shared buff/cache available </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> Mem: 7977 521 1941 0 5514 7148 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> Swap: 0 0 0 </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <p>果然，容器内部看到的内存，仍是主机内存。</p> <p>知道了问题根源，解决方法就很简单了，给 
JVM 正确配置内存限制为 512M 就可以了。</p> <p>比如，你可以执行下面的命令，通过环境变量 JAVA_OPTS=’-Xmx512m -Xms512m’ ，把 JVM 的初始内存和最大内存都设为 
512MB：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> # 删除问题容器 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> $ docker rm -f tomcat </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> # 运行新的容器 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> <div 
class="hljs-ln-line"> $ docker run --name tomcat --cpus 0.1 -m 512M -e JAVA_OPTS=''-Xmx512m 
-Xms512m'' -p 8080:8080 -itd feisky/tomcat:8 </div></td> </tr> </tbody> </table></code> <div 
class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 </div></pre> <p>接着，再切换到终端二中，重新在循环中执行 
curl 命令，查看 Tomcat 的响应：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> 
<tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ for ((i=0;i&lt;30;i++)); do curl localhost:8080; 
sleep 1; done </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
curl: (56) Recv failure: Connection reset by peer </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> curl: (56) Recv failure: Connection reset by peer </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> Hello, wolrd! </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> Hello, wolrd! </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="8"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
Hello, wolrd! </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <p>可以看到，刚开始时，显示的还是 “Connection reset by peer” 
错误。不过，稍等一会儿后，就是连续的 “Hello, wolrd!” 输出了。这说明， Tomcat 已经正常启动。</p> <p>这时，我们切换回终端一，执行 docker logs 
命令，查看 Tomcat 容器的日志：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ docker logs -f tomcat </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> ... </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 18-Feb-2019 12:52:00.823 INFO [localhost-startStop-1] org.apache.catalina.startup.HostConfig.deployDirectory 
Deploying web application directory [/usr/local/tomcat/webapps/manager] </div></td> </tr> <tr> 
<td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 18-Feb-2019 12:52:01.422 INFO [localhost-startStop-1] 
org.apache.catalina.startup.HostConfig.deployDirectory Deployment of web application directory 
[/usr/local/tomcat/webapps/manager] has finished in [598] ms </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 18-Feb-2019 12:52:01.920 INFO [main] org.apache.coyote.AbstractProtocol.start 
Starting ProtocolHandler ["http-nio-8080"] </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 18-Feb-2019 12:52:02.323 INFO [main] org.apache.coyote.AbstractProtocol.start 
Starting ProtocolHandler ["ajp-nio-8009"] </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 18-Feb-2019 12:52:02.523 INFO [main] org.apache.catalina.startup.Catalina.start 
Server startup in 22798 ms </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="8"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
</div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>这次，Tomcat 也正常启动了。不过，最后一行的启动时间，似乎比较刺眼。启动过程，居然需要 22 秒，这也太慢了吧。</p> <p>由于这个时间是花在容器启动上的，要排查这个问题，我们就要重启容器，并借助性能分析工具来分析容器进程。至于工具的选用，回顾一下我们前面的案例，我觉得可以先用 
top 看看。</p> <p>我们切换到终端二中，运行 top 命令；然后再切换到终端一，执行下面的命令，重启容器：</p> <pre style="position: relative;"><code> 
<table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
# 删除旧容器 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> $ docker 
rm -f tomcat </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="3"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> # 运行新容器 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ docker run --name tomcat --cpus 0.1 
-m 512M -e JAVA_OPTS=''-Xmx512m -Xms512m'' -p 8080:8080 -itd feisky/tomcat:8 </div></td> </tr> 
</tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>接着，再切换到终端二，观察 top 的输出：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> 
<tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ top </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> top - 12:57:18 up 2 days, 5:50, 2 users, load average: 0.00, 0.02, 
0.00 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="3"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> Tasks: 
131 total, 1 running, 74 sleeping, 0 stopped, 0 zombie </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> %Cpu0 : 3.0 us, 0.3 sy, 0.0 ni, 96.6 id, 0.0 wa, 0.0 hi, 0.0 si, 
0.0 st </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="5"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> %Cpu1 
: 5.7 us, 0.3 sy, 0.0 ni, 94.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> KiB Mem : 8169304 total, 2465984 free, 
500812 used, 5202508 buff/cache </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="7"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
KiB Swap: 0 total, 0 free, 0 used. 7353652 avail Mem </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="9"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 29457 root 20 0 2791736 73704 19164 S 10.0 0.9 0:01.61 java 27349 
root 20 0 1121372 96760 39340 S 0.3 1.2 4:20.82 dockerd </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 27376 root 20 0 1031760 43768 21680 S 0.3 0.5 2:44.47 docker-containe 
29430 root 20 0 7376 3604 3128 S 0.3 0.0 0:00.01 docker-containe </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 1 root 20 0 78132 9332 6744 S 0.0 0.1 
0:16.12 systemd </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <p>从 top 的输出，我们可以发现，</p> <ul> <li> <p>从系统整体来看，两个 
CPU 的使用率分别是 3% 和 5.7% ，都不算高，大部分还是空闲的；可用内存还有 7GB（7353652 avail Mem），也非常充足。</p> </li> <li> <p>具体到进程上，java 
进程的 CPU 使用率为 10%，内存使用 0.9%，其他进程就都很低了。</p> </li> </ul> <p>这些指标都不算高，看起来都没啥问题。不过，事实究竟如何呢？我们还得继续找下去。由于 
java 进程的 CPU 使用率最高，所以要把它当成重点，继续分析其性能情况。</p> <p>说到进程的性能分析工具，你一定也想起了 pidstat。接下来，我们就用 pidstat 
再来分析一下。我们回到终端一中，执行 pidstat 命令：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> 
<tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> # -t 表示显示线程，-p 指定进程号 </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ pidstat -t -p 29457 1 </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 12:59:59 UID TGID TID %usr %system %guest 
%wait %CPU CPU Command </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
13:00:00 0 29457 - 0.00 0.00 0.00 0.00 0.00 0 java </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 13:00:00 0 - 29457 0.00 0.00 0.00 0.00 0.00 0 |__java </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 13:00:00 0 - 29458 0.00 0.00 0.00 0.00 
0.00 1 |__java </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="7"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
... </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="8"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 13:00:00 
0 - 29491 0.00 0.00 0.00 0.00 0.00 0 |__java </div></td> </tr> </tbody> </table></code> <div 
class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 </div></pre> <p>结果中，各种 CPU 
使用率全是 0，看起来不对呀。再想想，我们有没有漏掉什么线索呢？对了，这时候容器启动已经结束了，在没有客户端请求的情况下，Tomcat 本身啥也不用做，CPU 使用率当然是 0。</p> 
<p>为了分析启动过程中的问题，我们需要再次重启容器。继续在终端一，按下 Ctrl+C 停止 pidstat 命令；然后执行下面的命令，重启容器。成功重启后，拿到新的 PID，再重新运行 
pidstat 命令：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> <tr> 
<td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> # 删除旧容器 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> $ docker rm -f tomcat </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> # 运行新容器 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> <div 
class="hljs-ln-line"> $ docker run --name tomcat --cpus 0.1 -m 512M -e JAVA_OPTS=''-Xmx512m 
-Xms512m'' -p 8080:8080 -itd feisky/tomcat:8 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> # 查询新容器中进程的 Pid </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> $ PID=$(docker inspect tomcat -f ''{{.State.Pid}}'') </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> # 执行 pidstat </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ pidstat -t -p $PID 1 </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 12:59:28 UID TGID TID %usr %system %guest 
%wait %CPU CPU Command </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="10"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
12:59:29 0 29850 - 10.00 0.00 0.00 0.00 10.00 0 java </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 12:59:29 0 - 29850 0.00 0.00 0.00 0.00 0.00 0 |__java </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 12:59:29 0 - 29897 5.00 1.00 0.00 86.00 
6.00 1 |__java </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="13"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
... </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="14"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 12:59:29 
0 - 29905 3.00 0.00 0.00 97.00 3.00 0 |__java </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="15"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 12:59:29 0 - 29906 2.00 0.00 0.00 49.00 2.00 1 |__java </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="16"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 12:59:29 0 - 29908 0.00 0.00 0.00 45.00 
0.00 0 |__java </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <p>仔细观察这次的输出，你会发现，虽然 CPU 使用率（%CPU）很低，但等待运行的使用率（%wait）却非常高，最高甚至已经达到了 
97%。这说明，这些线程大部分时间都在等待调度，而不是真正的运行。</p> <blockquote> <p>注：如果你看不到 %wait 指标，请先升级 sysstat 后再试试。</p> 
</blockquote> <p>为什么 CPU 使用率这么低，线程的大部分时间还要等待 CPU 呢？由于这个现象因 Docker 而起，自然的，你应该想到，这可能是因为 Docker 
为容器设置了限制。</p> <p>再回顾一下，案例开始时容器的启动命令。我们用 --cpus 0.1 ，为容器设置了 0.1 个 CPU 的限制，也就是 10% 的 CPU。这里也就可以解释，为什么 
java 进程只有 10% 的 CPU 使用率，也会大部分时间都在等待了。</p> <p>找出原因，最后的优化也就简单了，把 CPU 限制增大就可以了。比如，你可以执行下面的命令，将 
CPU 限制增大到 1 ；然后再重启，并观察启动日志：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> 
<tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> # 删除旧容器 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> $ docker rm -f tomcat </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> # 运行新容器 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> <div 
class="hljs-ln-line"> $ docker run --name tomcat --cpus 1 -m 512M -e JAVA_OPTS=''-Xmx512m -Xms512m'' 
-p 8080:8080 -itd feisky/tomcat:8 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> <td class="hljs-ln-code"> <div 
class="hljs-ln-line"> # 查看容器日志 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="6"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
$ docker logs -f tomcat </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="7"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
... </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="8"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 18-Feb-2019 
12:54:02.139 INFO [main] org.apache.catalina.startup.Catalina.start Server startup in 2001 
ms </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>现在可以看到，Tomcat 的启动过程，只需要 2 秒就完成了，果然比前面的 22 秒快多了。</p> <p>虽然我们通过增大 CPU 的限制，解决了这个问题。不过再碰到类似问题，你可能会觉得这种方法太麻烦了。因为要设置容器的资源限制，还需要我们预先评估应用程序的性能。显然还有更简单的方法，比如说直接去掉限制，让容器跑就是了。</p> 
<p>不过，这种简单方法，却很可能带来更严重的问题。没有资源限制，就意味着容器可以占用整个系统的资源。这样，一旦任何应用程序发生异常，都有可能拖垮整台机器。</p> <p>实际上，这也是在各大容器平台上最常见的一个问题。一开始图省事不设限，但当容器数量增长上来的时候，就会经常出现各种异常问题。最终查下来，可能就是因为某个应用资源使用过高，导致整台机器短期内无法响应。只有设置了资源限制，才能确保杜绝类似问题。</p> 
<h2>小结</h2> <p>今天，我带你学习了，如何分析容器化后应用程序性能下降的问题。</p> <p>如果你在 Docker 容器中运行 Java 应用，一定要确保，在设置容器资源限制的同时，配置好 
JVM 的资源选项（比如堆内存等）。当然，如果你可以升级 Java 版本，那么升级到 Java 10 ，就可以自动解决类似问题了。</p> <p>当碰到容器化的应用程序性能时，你依然可以使用，我们前面讲过的各种方法来分析和定位。只不过要记得，容器化后的性能分析，跟前面内容稍微有些区别，比如下面这几点。</p> 
<ul> <li> <p>容器本身通过 cgroups 进行资源隔离，所以，在分析时要考虑 cgroups 对应用程序的影响。</p> </li> <li> <p>容器的文件系统、网络协议栈等跟主机隔离。虽然在容器外面，我们也可以分析容器的行为，不过有时候，进入容器的命名空间内部，可能更为方便。</p> 
</li> <li> <p>容器的运行可能还会依赖于其他组件，比如各种网络插件（比如 CNI）、存储插件（比如 CSI）、设备插件（比如 GPU）等，让容器的性能分析更加复杂。如果你需要分析容器性能，别忘了考虑它们对性能的影响。</p> 
</li> </ul> <h2>思考</h2> <p>最后，我想邀请你一起来聊聊，你碰到过的容器性能问题。你是怎么分析它们的？又是怎么解决根源问题的？你可以结合我的讲解，总结自己的思路。</p> 
<p>欢迎在留言区和我讨论，也欢迎把这篇文章分享给你的同事、朋友。我们一起在实战中演练，在交流中进步。</p> <p><img src="https://static001.geekbang.org/resource/image/a3/e9/a396aed4116c2c989771c1295736abe9.jpg" 
alt=""></p>', body_summary='', bundle='book', delta=0, body_format='full_html', langcode='zh-hans', 
revision_id=1079 where entity_id=1079 
 {executed in 1 msec}
2020-11-25 10:11:25.953 INFO  jdbc.sqltiming Line:373 - update node_revision__body set body_value='<p>你好，我是倪朋飞。</p> <p>不知不觉，我们已经学完了整个专栏的四大基础模块，即 CPU、内存、文件系统和磁盘 
I/O、以及网络的性能分析和优化。相信你已经掌握了这些基础模块的基本分析、定位思路，并熟悉了相关的优化方法。</p> <p>接下来，我们将进入最后一个重要模块—— 综合实战篇。这部分实战内容，也将是我们对前面所学知识的复习和深化。</p> 
<p>我们都知道，随着 Kubernetes、Docker 等技术的普及，越来越多的企业，都已经走上了应用程序容器化的道路。我相信，你在了解学习这些技术的同时，一定也听说过不少，基于 
Docker 的微服务架构带来的各种优势，比如：</p> <ul> <li> <p>使用 Docker ，把应用程序以及相关依赖打包到镜像中后，部署和升级更快捷；</p> </li> 
<li> <p>把传统的单体应用拆分成多个更小的微服务应用后，每个微服务的功能都更简单，并且可以单独管理和维护；</p> </li> <li> <p>每个微服务都可以根据需求横向扩展。即使发生故障，也只是局部服务不可用，而不像以前那样，导致整个服务不可用。</p> 
</li> </ul> <p>不过，任何技术都不是银弹。这些新技术，在带来诸多便捷功能之外，也带来了更高的复杂性，比如性能降低、架构复杂、排错困难等等。</p> <p>今天，我就通过一个 
Tomcat 案例，带你一起学习，如何分析应用程序容器化后的性能问题。</p><!-- [[[read_end]]] --> <h2>案例准备</h2> <p>今天的案例，我们只需要一台虚拟机。还是基于 
Ubuntu 18.04，同样适用于其他的 Linux 系统。我使用的案例环境如下所示：</p> <ul> <li> <p>机器配置：2 CPU，8GB 内存。</p> </li> 
<li> <p>预先安装 docker、curl、jq、pidstat 等工具，如 apt install docker.io curl jq sysstat。</p> </li> 
</ul> <p>其中，jq 工具专门用来在命令行中处理 json。为了更好的展示 json 数据，我们用这个工具，来格式化 json 输出。</p> <p>你需要打开两个终端，登录到同一台虚拟机中，并安装上述工具。</p> 
<p>注意，以下所有命令都默认以 root 用户运行，如果你用普通用户身份登陆系统，请运行 sudo su root 命令切换到 root 用户。</p> <blockquote> 
<p>如果安装过程有问题，你可以先上网搜索解决，实在解决不了的，记得在留言区向我提问。</p> </blockquote> <p>到这里，准备工作就完成了。接下来，我们正式进入操作环节。</p> 
<h2>案例分析</h2> <p>我们今天要分析的案例，是一个 Tomcat 应用。Tomcat 是 Apache 基金会旗下，Jakarta 项目开发的轻量级应用服务器，它基于 Java 
语言开发。Docker 社区也维护着 Tomcat 的<a href="https://hub.docker.com/_/tomcat">官方镜像</a>，你可以直接使用这个镜像，来启动一个 
Tomcat 应用。</p> <p>我们的案例，也基于 Tomcat 的官方镜像构建，其核心逻辑很简单，就是分配一点儿内存，并输出 “Hello, world!”。</p> <pre 
style="position: relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> &lt;% </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
byte data[] = new byte[256*1024*1024]; </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> out.println("Hello, wolrd!"); </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> %&gt; </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <p>为了方便你运行，我已经将它打包成了一个 <a href="https://github.com/feiskyer/linux-perf-examples/tree/master/tomcat">Docker 
镜像</a> feisky/tomcat:8，并推送到了 Docker Hub 中。你可以直接按照下面的步骤来运行它。</p> <p>在终端一中，执行下面的命令，启动 Tomcat 
应用，并监听 8080 端口。如果一切正常，你应该可以看到如下的输出：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> 
<tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> # -m 表示设置内存为 512MB </div></td> </tr> <tr> 
<td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ docker run --name tomcat --cpus 0.1 
-m 512M -p 8080:8080 -itd feisky/tomcat:8 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> Unable to find image ''feisky/tomcat:8'' locally </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 8: Pulling from feisky/tomcat </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 741437d97401: Pull complete </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> ... </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 22cd96a25579: Pull complete </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> Digest: sha256:71871cff17b9043842c2ec99f370cc9f1de7bc121cd2c02d8e2092c6e268f7e2 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> Status: Downloaded newer image for feisky/tomcat:8 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> WARNING: Your kernel does not support 
swap limit capabilities or the cgroup is not mounted. Memory limited without swap. </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 2df259b752db334d96da26f19166d662a82283057411f6332f3cbdbcab452249 
</div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>从输出中，你可以看到，docker run 命令，会自动拉取镜像并启动容器。</p> <p>这里顺便提一下，之前很多同学留言问，到底要怎么下载 Docker 
镜像。其实，上面的 docker run，就是自动下载镜像到本地后，才开始运行的。</p> <p>由于 Docker 镜像分多层管理，所以在下载时，你会看到每层的下载进度。除了像 docker 
run 这样自动下载镜像外，你也可以分两步走，先下载镜像，然后再运行容器。</p> <p>比如，你可以先运行下面的 docker pull 命令，下载镜像：</p> <pre style="position: 
relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
$ docker pull feisky/tomcat:8 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
8: Pulling from feisky/tomcat </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
Digest: sha256:71871cff17b9043842c2ec99f370cc9f1de7bc121cd2c02d8e2092c6e268f7e2 </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> Status: Image is up to date for feisky/tomcat:8 
</div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>显然，在我的机器中，镜像已存在，所以就不需要再次下载，直接返回成功就可以了。</p> <p>接着，在终端二中使用 curl，访问 Tomcat 监听的 
8080 端口，确认案例已经正常启动：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ curl localhost:8080 </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> curl: (56) Recv failure: Connection reset 
by peer </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span 
class="iconfont"></span>复制代码 </div></pre> <p>不过，很不幸，curl 返回了 “Connection reset by peer” 的错误，说明 
Tomcat 服务，并不能正常响应客户端请求。</p> <p>是不是 Tomcat 启动出问题了呢？我们切换到终端一中，执行 docker logs 命令，查看容器的日志。这里注意，需要加上 
-f 参数，表示跟踪容器的最新日志输出：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ docker logs -f tomcat </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> Using CATALINA_BASE: /usr/local/tomcat 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> Using CATALINA_HOME: /usr/local/tomcat 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> Using CATALINA_TMPDIR: /usr/local/tomcat/temp 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> Using JRE_HOME: /docker-java-home/jre 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> Using CLASSPATH: /usr/local/tomcat/bin/bootstrap.jar:/usr/local/tomcat/bin/tomcat-juli.jar 
</div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>从这儿你可以看到，Tomcat 容器只打印了环境变量，还没有应用程序初始化的日志。也就是说，Tomcat 还在启动过程中，这时候去访问它，当然没有响应。</p> 
<p>为了观察 Tomcat 的启动过程，我们在终端一中，继续保留 docker logs -f 命令，并在终端二中执行下面的命令，多次尝试访问 Tomcat：</p> <pre style="position: 
relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
$ for ((i=0;i&lt;30;i++)); do curl localhost:8080; sleep 1; done </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> curl: (56) Recv failure: Connection reset 
by peer </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="3"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> curl: 
(56) Recv failure: Connection reset by peer </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> # 这儿会阻塞一会 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> <td class="hljs-ln-code"> <div 
class="hljs-ln-line"> Hello, wolrd! </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> <td class="hljs-ln-code"> <div 
class="hljs-ln-line"> curl: (52) Empty reply from server </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> curl: (7) Failed to connect to localhost port 8080: Connection refused 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> curl: (7) Failed to connect to localhost 
port 8080: Connection refused </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <p>观察一会儿，可以看到，一段时间后，curl 终于给出了我们想要的结果 “Hello, 
wolrd!”。但是，随后又出现了 “Empty reply from server” ，和一直持续的 “Connection refused” 错误。换句话说，Tomcat 响应一次请求后，就再也不响应了。</p> 
<p>这是怎么回事呢？我们回到终端一中，观察 Tomcat 的日志，看看能不能找到什么线索。</p> <p>从终端一中，你应该可以看到下面的输出：</p> <pre style="position: 
relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
18-Feb-2019 12:43:32.719 INFO [localhost-startStop-1] org.apache.catalina.startup.HostConfig.deployDirectory 
Deploying web application directory [/usr/local/tomcat/webapps/docs] </div></td> </tr> <tr> 
<td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 18-Feb-2019 12:43:33.725 INFO [localhost-startStop-1] 
org.apache.catalina.startup.HostConfig.deployDirectory Deployment of web application directory 
[/usr/local/tomcat/webapps/docs] has finished in [1,006] ms </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 18-Feb-2019 12:43:33.726 INFO [localhost-startStop-1] org.apache.catalina.startup.HostConfig.deployDirectory 
Deploying web application directory [/usr/local/tomcat/webapps/manager] </div></td> </tr> <tr> 
<td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 18-Feb-2019 12:43:34.521 INFO [localhost-startStop-1] 
org.apache.catalina.startup.HostConfig.deployDirectory Deployment of web application directory 
[/usr/local/tomcat/webapps/manager] has finished in [795] ms </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 18-Feb-2019 12:43:34.722 INFO [main] org.apache.coyote.AbstractProtocol.start 
Starting ProtocolHandler ["http-nio-8080"] </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 18-Feb-2019 12:43:35.319 INFO [main] org.apache.coyote.AbstractProtocol.start 
Starting ProtocolHandler ["ajp-nio-8009"] </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 18-Feb-2019 12:43:35.821 INFO [main] org.apache.catalina.startup.Catalina.start 
Server startup in 24096 ms </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="8"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
root@ubuntu:~# </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <p>从内容上可以看到，Tomcat 在启动 24s 后完成初始化，并且正常启动。从日志上来看，没有什么问题。</p> 
<p>不过，细心的你肯定注意到了最后一行，明显是回到了 Linux 的 SHELL 终端中，而没有继续等待 Docker 输出的容器日志。</p> <p>输出重新回到 SHELL 终端，通常表示上一个命令已经结束。而我们的上一个命令，是 
docker logs -f 命令。那么，它的退出就只有两种可能了，要么是容器退出了，要么就是 dockerd 进程退出了。</p> <p>究竟是哪种情况呢？这就需要我们进一步确认了。我们可以在终端一中，执行下面的命令，查看容器的状态：</p> 
<pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> $ docker ps -a </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 0f2b3fcdd257 feisky/tomcat:8 "catalina.sh 
run" 2 minutes ago Exited (137) About a minute ago tomcat </div></td> </tr> </tbody> </table></code> 
<div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 </div></pre> <p>你会看到，容器处于 
Exited 状态，说明是第一种情况，容器已经退出。不过为什么会这样呢？显然，在前面容器的日志里，我们并没有发现线索，那就只能从 Docker 本身入手了。</p> <p>我们可以调用 
Docker 的 API，查询容器的状态、退出码以及错误信息，然后确定容器退出的原因。这些可以通过 docker inspect 命令来完成，比如，你可以继续执行下面的命令，通过 -f 
选项设置只输出容器的状态：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> <tr> 
<td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> # 显示容器状态，jq 用来格式化 json 输出 </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ docker inspect tomcat -f ''{{json .State}}'' 
| jq </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="3"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> { </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> "Status": "exited", </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> "Running": false, </div></td> </tr> <tr> 
<td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> "Paused": false, </div></td> </tr> <tr> 
<td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> "Restarting": false, </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> "OOMKilled": true, </div></td> </tr> <tr> 
<td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> "Dead": false, </div></td> </tr> <tr> 
<td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> "Pid": 0, </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> "ExitCode": 137, </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> "Error": "", </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="13"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> ... </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="14"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
} </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>这次你可以看到，容器已经处于 exited 状态，OOMKilled 是 true，ExitCode 是 137。这其中，OOMKilled 表示容器被 
OOM 杀死了。</p> <p>我们前面提到过，OOM 表示内存不足时，某些应用会被系统杀死。可是，为什么内存会不足呢？我们的应用分配了 256 MB 的内存，而容器启动时，明明通过 
-m 选项，设置了 512 MB 的内存，按说应该是足够的。</p> <p>到这里，我估计你应该还记得，当 OOM 发生时，系统会把相关的 OOM 信息，记录到日志中。所以，接下来，我们可以在终端中执行 
dmesg 命令，查看系统日志，并定位 OOM 相关的日志：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> 
<tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ dmesg </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> [193038.106393] java invoked oom-killer: gfp_mask=0x14000c0(GFP_KERNEL), 
nodemask=(null), order=0, oom_score_adj=0 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> [193038.106396] java cpuset=0f2b3fcdd2578165ea77266cdc7b1ad43e75877b0ac1889ecda30a78cb78bd53 
mems_allowed=0 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
[193038.106402] CPU: 0 PID: 27424 Comm: java Tainted: G OE 4.15.0-1037 #39-Ubuntu </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> [193038.106404] Hardware name: Microsoft 
Corporation Virtual Machine/Virtual Machine, BIOS 090007 06/02/2017 </div></td> </tr> <tr> 
<td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> [193038.106405] Call Trace: </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> [193038.106414] dump_stack+0x63/0x89 </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> [193038.106419] dump_header+0x71/0x285 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> [193038.106422] oom_kill_process+0x220/0x440 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> [193038.106424] out_of_memory+0x2d1/0x4f0 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> [193038.106429] mem_cgroup_out_of_memory+0x4b/0x80 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> [193038.106432] mem_cgroup_oom_synchronize+0x2e8/0x320 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="13"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> [193038.106435] ? mem_cgroup_css_online+0x40/0x40 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="14"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> [193038.106437] pagefault_out_of_memory+0x36/0x7b 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="15"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> [193038.106443] mm_fault_error+0x90/0x180 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="16"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> [193038.106445] __do_page_fault+0x4a5/0x4d0 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="17"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> [193038.106448] do_page_fault+0x2e/0xe0 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="18"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> [193038.106454] ? page_fault+0x2f/0x50 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="19"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> [193038.106456] page_fault+0x45/0x50 </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="20"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> [193038.106459] RIP: 0033:0x7fa053e5a20d 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="21"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> [193038.106460] RSP: 002b:00007fa0060159e8 
EFLAGS: 00010206 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="22"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
[193038.106462] RAX: 0000000000000000 RBX: 00007fa04c4b3000 RCX: 0000000009187440 </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="23"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> [193038.106463] RDX: 00000000943aa440 
RSI: 0000000000000000 RDI: 000000009b223000 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="24"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> [193038.106464] RBP: 00007fa006015a60 R08: 0000000002000002 R09: 
00007fa053d0a8a1 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="25"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
[193038.106465] R10: 00007fa04c018b80 R11: 0000000000000206 R12: 0000000100000768 </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="26"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> [193038.106466] R13: 00007fa04c4b3000 
R14: 0000000100000768 R15: 0000000010000000 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="27"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> [193038.106468] Task in /docker/0f2b3fcdd2578165ea77266cdc7b1ad43e75877b0ac1889ecda30a78cb78bd53 
killed as a result of limit of /docker/0f2b3fcdd2578165ea77266cdc7b1ad43e75877b0ac1889ecda30a78cb78bd53 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="28"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> [193038.106478] memory: usage 524288kB, 
limit 524288kB, failcnt 77 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="29"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
[193038.106480] memory+swap: usage 0kB, limit 9007199254740988kB, failcnt 0 </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="30"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> [193038.106481] kmem: usage 3708kB, limit 
9007199254740988kB, failcnt 0 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="31"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
[193038.106481] Memory cgroup stats for /docker/0f2b3fcdd2578165ea77266cdc7b1ad43e75877b0ac1889ecda30a78cb78bd53: 
cache:0KB rss:520580KB rss_huge:450560KB shmem:0KB mapped_file:0KB dirty:0KB writeback:0KB 
inactive_anon:0KB active_anon:520580KB inactive_file:0KB active_file:0KB unevictable:0KB </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="32"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> [193038.106494] [ pid ] uid tgid total_vm 
rss pgtables_bytes swapents oom_score_adj name </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="33"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> [193038.106571] [27281] 0 27281 1153302 134371 1466368 0 0 java 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="34"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> [193038.106574] Memory cgroup out of memory: 
Kill process 27281 (java) score 1027 or sacrifice child </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="35"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> [193038.148334] Killed process 27281 (java) total-vm:4613208kB, 
anon-rss:517316kB, file-rss:20168kB, shmem-rss:0kB </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="36"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> [193039.607503] oom_reaper: reaped process 27281 (java), now anon-rss:0kB, 
file-rss:0kB, shmem-rss:0kB </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <p>从 dmesg 的输出，你就可以看到很详细的 OOM 记录了。你应该可以看到下面几个关键点。</p> 
<ul> <li> <p>第一，被杀死的是一个 java 进程。从内核调用栈上的 mem_cgroup_out_of_memory 可以看出，它是因为超过 cgroup 的内存限制，而被 
OOM 杀死的。</p> </li> <li> <p>第二，java 进程是在容器内运行的，而容器内存的使用量和限制都是 512M（524288kB）。目前使用量已经达到了限制，所以会导致 
OOM。</p> </li> <li> <p>第三，被杀死的进程，PID 为 27281，虚拟内存为 4.3G（total-vm:4613208kB），匿名内存为 505M（anon-rss:517316kB），页内存为 
19M（20168kB）。换句话说，匿名内存是主要的内存占用。而且，匿名内存加上页内存，总共是 524M，已经超过了 512M 的限制。</p> </li> </ul> <p>综合这几点，可以看出，Tomcat 
容器的内存主要用在了匿名内存中，而匿名内存，其实就是主动申请分配的堆内存。</p> <p>不过，为什么 Tomcat 会申请这么多的堆内存呢？要知道，Tomcat 是基于 Java 
开发的，所以应该不难想到，这很可能是 JVM 堆内存配置的问题。</p> <p>我们知道，JVM 根据系统的内存总量，来自动管理堆内存，不明确配置的话，堆内存的默认限制是物理内存的四分之一。不过，前面我们已经限制了容器内存为 
512 M，java 的堆内存到底是多少呢？</p> <p>我们继续在终端中，执行下面的命令，重新启动 tomcat 容器，并调用 java 命令行来查看堆内存大小：</p> <pre 
style="position: relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> # 重新启动容器 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> <div 
class="hljs-ln-line"> $ docker rm -f tomcat </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> $ docker run --name tomcat --cpus 0.1 -m 512M -p 8080:8080 -itd 
feisky/tomcat:8 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> # 查看堆内存，注意单位是字节 </div></td> </tr> <tr> 
<td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ docker exec tomcat java -XX:+PrintFlagsFinal 
-version | grep HeapSize </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="7"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
uintx ErgoHeapSizeLimit = 0 {product} </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></td> <td class="hljs-ln-code"> <div 
class="hljs-ln-line"> uintx HeapSizePerGCThread = 87241520 {product} </div></td> </tr> <tr> 
<td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> uintx InitialHeapSize := 132120576 {product} 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> uintx LargePageHeapSizeThreshold = 134217728 
{product} </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="11"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> uintx 
MaxHeapSize := 2092957696 {product} </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <p>你可以看到，初始堆内存的大小（InitialHeapSize）是 126MB，而最大堆内存则是 
1.95GB，这可比容器限制的 512 MB 大多了。</p> <p>之所以会这么大，其实是因为，容器内部看不到 Docker 为它设置的内存限制。虽然在启动容器时，我们通过 -m 
512M 选项，给容器设置了 512M 的内存限制。但实际上，从容器内部看到的限制，却并不是 512M。</p> <p>我们在终端中，继续执行下面的命令：</p> <pre style="position: 
relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
$ docker exec tomcat free -m </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
total used free shared buff/cache available </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> Mem: 7977 521 1941 0 5514 7148 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> Swap: 0 0 0 </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <p>果然，容器内部看到的内存，仍是主机内存。</p> <p>知道了问题根源，解决方法就很简单了，给 
JVM 正确配置内存限制为 512M 就可以了。</p> <p>比如，你可以执行下面的命令，通过环境变量 JAVA_OPTS=’-Xmx512m -Xms512m’ ，把 JVM 的初始内存和最大内存都设为 
512MB：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> # 删除问题容器 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> $ docker rm -f tomcat </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> # 运行新的容器 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> <div 
class="hljs-ln-line"> $ docker run --name tomcat --cpus 0.1 -m 512M -e JAVA_OPTS=''-Xmx512m 
-Xms512m'' -p 8080:8080 -itd feisky/tomcat:8 </div></td> </tr> </tbody> </table></code> <div 
class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 </div></pre> <p>接着，再切换到终端二中，重新在循环中执行 
curl 命令，查看 Tomcat 的响应：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> 
<tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ for ((i=0;i&lt;30;i++)); do curl localhost:8080; 
sleep 1; done </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
curl: (56) Recv failure: Connection reset by peer </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> curl: (56) Recv failure: Connection reset by peer </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> Hello, wolrd! </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> Hello, wolrd! </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="8"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
Hello, wolrd! </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <p>可以看到，刚开始时，显示的还是 “Connection reset by peer” 
错误。不过，稍等一会儿后，就是连续的 “Hello, wolrd!” 输出了。这说明， Tomcat 已经正常启动。</p> <p>这时，我们切换回终端一，执行 docker logs 
命令，查看 Tomcat 容器的日志：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ docker logs -f tomcat </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> ... </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 18-Feb-2019 12:52:00.823 INFO [localhost-startStop-1] org.apache.catalina.startup.HostConfig.deployDirectory 
Deploying web application directory [/usr/local/tomcat/webapps/manager] </div></td> </tr> <tr> 
<td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 18-Feb-2019 12:52:01.422 INFO [localhost-startStop-1] 
org.apache.catalina.startup.HostConfig.deployDirectory Deployment of web application directory 
[/usr/local/tomcat/webapps/manager] has finished in [598] ms </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 18-Feb-2019 12:52:01.920 INFO [main] org.apache.coyote.AbstractProtocol.start 
Starting ProtocolHandler ["http-nio-8080"] </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 18-Feb-2019 12:52:02.323 INFO [main] org.apache.coyote.AbstractProtocol.start 
Starting ProtocolHandler ["ajp-nio-8009"] </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 18-Feb-2019 12:52:02.523 INFO [main] org.apache.catalina.startup.Catalina.start 
Server startup in 22798 ms </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="8"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
</div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>这次，Tomcat 也正常启动了。不过，最后一行的启动时间，似乎比较刺眼。启动过程，居然需要 22 秒，这也太慢了吧。</p> <p>由于这个时间是花在容器启动上的，要排查这个问题，我们就要重启容器，并借助性能分析工具来分析容器进程。至于工具的选用，回顾一下我们前面的案例，我觉得可以先用 
top 看看。</p> <p>我们切换到终端二中，运行 top 命令；然后再切换到终端一，执行下面的命令，重启容器：</p> <pre style="position: relative;"><code> 
<table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
# 删除旧容器 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> $ docker 
rm -f tomcat </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="3"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> # 运行新容器 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ docker run --name tomcat --cpus 0.1 
-m 512M -e JAVA_OPTS=''-Xmx512m -Xms512m'' -p 8080:8080 -itd feisky/tomcat:8 </div></td> </tr> 
</tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>接着，再切换到终端二，观察 top 的输出：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> 
<tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ top </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> top - 12:57:18 up 2 days, 5:50, 2 users, load average: 0.00, 0.02, 
0.00 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="3"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> Tasks: 
131 total, 1 running, 74 sleeping, 0 stopped, 0 zombie </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> %Cpu0 : 3.0 us, 0.3 sy, 0.0 ni, 96.6 id, 0.0 wa, 0.0 hi, 0.0 si, 
0.0 st </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="5"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> %Cpu1 
: 5.7 us, 0.3 sy, 0.0 ni, 94.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> KiB Mem : 8169304 total, 2465984 free, 
500812 used, 5202508 buff/cache </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="7"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
KiB Swap: 0 total, 0 free, 0 used. 7353652 avail Mem </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="9"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 29457 root 20 0 2791736 73704 19164 S 10.0 0.9 0:01.61 java 27349 
root 20 0 1121372 96760 39340 S 0.3 1.2 4:20.82 dockerd </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 27376 root 20 0 1031760 43768 21680 S 0.3 0.5 2:44.47 docker-containe 
29430 root 20 0 7376 3604 3128 S 0.3 0.0 0:00.01 docker-containe </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 1 root 20 0 78132 9332 6744 S 0.0 0.1 
0:16.12 systemd </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <p>从 top 的输出，我们可以发现，</p> <ul> <li> <p>从系统整体来看，两个 
CPU 的使用率分别是 3% 和 5.7% ，都不算高，大部分还是空闲的；可用内存还有 7GB（7353652 avail Mem），也非常充足。</p> </li> <li> <p>具体到进程上，java 
进程的 CPU 使用率为 10%，内存使用 0.9%，其他进程就都很低了。</p> </li> </ul> <p>这些指标都不算高，看起来都没啥问题。不过，事实究竟如何呢？我们还得继续找下去。由于 
java 进程的 CPU 使用率最高，所以要把它当成重点，继续分析其性能情况。</p> <p>说到进程的性能分析工具，你一定也想起了 pidstat。接下来，我们就用 pidstat 
再来分析一下。我们回到终端一中，执行 pidstat 命令：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> 
<tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> # -t 表示显示线程，-p 指定进程号 </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ pidstat -t -p 29457 1 </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 12:59:59 UID TGID TID %usr %system %guest 
%wait %CPU CPU Command </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
13:00:00 0 29457 - 0.00 0.00 0.00 0.00 0.00 0 java </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 13:00:00 0 - 29457 0.00 0.00 0.00 0.00 0.00 0 |__java </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 13:00:00 0 - 29458 0.00 0.00 0.00 0.00 
0.00 1 |__java </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="7"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
... </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="8"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 13:00:00 
0 - 29491 0.00 0.00 0.00 0.00 0.00 0 |__java </div></td> </tr> </tbody> </table></code> <div 
class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 </div></pre> <p>结果中，各种 CPU 
使用率全是 0，看起来不对呀。再想想，我们有没有漏掉什么线索呢？对了，这时候容器启动已经结束了，在没有客户端请求的情况下，Tomcat 本身啥也不用做，CPU 使用率当然是 0。</p> 
<p>为了分析启动过程中的问题，我们需要再次重启容器。继续在终端一，按下 Ctrl+C 停止 pidstat 命令；然后执行下面的命令，重启容器。成功重启后，拿到新的 PID，再重新运行 
pidstat 命令：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> <tr> 
<td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> # 删除旧容器 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> $ docker rm -f tomcat </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> # 运行新容器 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> <div 
class="hljs-ln-line"> $ docker run --name tomcat --cpus 0.1 -m 512M -e JAVA_OPTS=''-Xmx512m 
-Xms512m'' -p 8080:8080 -itd feisky/tomcat:8 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> # 查询新容器中进程的 Pid </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> $ PID=$(docker inspect tomcat -f ''{{.State.Pid}}'') </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> # 执行 pidstat </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ pidstat -t -p $PID 1 </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 12:59:28 UID TGID TID %usr %system %guest 
%wait %CPU CPU Command </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="10"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
12:59:29 0 29850 - 10.00 0.00 0.00 0.00 10.00 0 java </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 12:59:29 0 - 29850 0.00 0.00 0.00 0.00 0.00 0 |__java </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 12:59:29 0 - 29897 5.00 1.00 0.00 86.00 
6.00 1 |__java </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="13"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
... </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="14"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 12:59:29 
0 - 29905 3.00 0.00 0.00 97.00 3.00 0 |__java </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="15"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 12:59:29 0 - 29906 2.00 0.00 0.00 49.00 2.00 1 |__java </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="16"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 12:59:29 0 - 29908 0.00 0.00 0.00 45.00 
0.00 0 |__java </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <p>仔细观察这次的输出，你会发现，虽然 CPU 使用率（%CPU）很低，但等待运行的使用率（%wait）却非常高，最高甚至已经达到了 
97%。这说明，这些线程大部分时间都在等待调度，而不是真正的运行。</p> <blockquote> <p>注：如果你看不到 %wait 指标，请先升级 sysstat 后再试试。</p> 
</blockquote> <p>为什么 CPU 使用率这么低，线程的大部分时间还要等待 CPU 呢？由于这个现象因 Docker 而起，自然的，你应该想到，这可能是因为 Docker 
为容器设置了限制。</p> <p>再回顾一下，案例开始时容器的启动命令。我们用 --cpus 0.1 ，为容器设置了 0.1 个 CPU 的限制，也就是 10% 的 CPU。这里也就可以解释，为什么 
java 进程只有 10% 的 CPU 使用率，也会大部分时间都在等待了。</p> <p>找出原因，最后的优化也就简单了，把 CPU 限制增大就可以了。比如，你可以执行下面的命令，将 
CPU 限制增大到 1 ；然后再重启，并观察启动日志：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> 
<tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> # 删除旧容器 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> $ docker rm -f tomcat </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> # 运行新容器 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> <div 
class="hljs-ln-line"> $ docker run --name tomcat --cpus 1 -m 512M -e JAVA_OPTS=''-Xmx512m -Xms512m'' 
-p 8080:8080 -itd feisky/tomcat:8 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> <td class="hljs-ln-code"> <div 
class="hljs-ln-line"> # 查看容器日志 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="6"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
$ docker logs -f tomcat </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="7"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
... </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="8"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 18-Feb-2019 
12:54:02.139 INFO [main] org.apache.catalina.startup.Catalina.start Server startup in 2001 
ms </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>现在可以看到，Tomcat 的启动过程，只需要 2 秒就完成了，果然比前面的 22 秒快多了。</p> <p>虽然我们通过增大 CPU 的限制，解决了这个问题。不过再碰到类似问题，你可能会觉得这种方法太麻烦了。因为要设置容器的资源限制，还需要我们预先评估应用程序的性能。显然还有更简单的方法，比如说直接去掉限制，让容器跑就是了。</p> 
<p>不过，这种简单方法，却很可能带来更严重的问题。没有资源限制，就意味着容器可以占用整个系统的资源。这样，一旦任何应用程序发生异常，都有可能拖垮整台机器。</p> <p>实际上，这也是在各大容器平台上最常见的一个问题。一开始图省事不设限，但当容器数量增长上来的时候，就会经常出现各种异常问题。最终查下来，可能就是因为某个应用资源使用过高，导致整台机器短期内无法响应。只有设置了资源限制，才能确保杜绝类似问题。</p> 
<h2>小结</h2> <p>今天，我带你学习了，如何分析容器化后应用程序性能下降的问题。</p> <p>如果你在 Docker 容器中运行 Java 应用，一定要确保，在设置容器资源限制的同时，配置好 
JVM 的资源选项（比如堆内存等）。当然，如果你可以升级 Java 版本，那么升级到 Java 10 ，就可以自动解决类似问题了。</p> <p>当碰到容器化的应用程序性能时，你依然可以使用，我们前面讲过的各种方法来分析和定位。只不过要记得，容器化后的性能分析，跟前面内容稍微有些区别，比如下面这几点。</p> 
<ul> <li> <p>容器本身通过 cgroups 进行资源隔离，所以，在分析时要考虑 cgroups 对应用程序的影响。</p> </li> <li> <p>容器的文件系统、网络协议栈等跟主机隔离。虽然在容器外面，我们也可以分析容器的行为，不过有时候，进入容器的命名空间内部，可能更为方便。</p> 
</li> <li> <p>容器的运行可能还会依赖于其他组件，比如各种网络插件（比如 CNI）、存储插件（比如 CSI）、设备插件（比如 GPU）等，让容器的性能分析更加复杂。如果你需要分析容器性能，别忘了考虑它们对性能的影响。</p> 
</li> </ul> <h2>思考</h2> <p>最后，我想邀请你一起来聊聊，你碰到过的容器性能问题。你是怎么分析它们的？又是怎么解决根源问题的？你可以结合我的讲解，总结自己的思路。</p> 
<p>欢迎在留言区和我讨论，也欢迎把这篇文章分享给你的同事、朋友。我们一起在实战中演练，在交流中进步。</p> <p><img src="https://static001.geekbang.org/resource/image/a3/e9/a396aed4116c2c989771c1295736abe9.jpg" 
alt=""></p>', body_summary='', bundle='book', delta=0, body_format='full_html', langcode='zh-hans', 
revision_id=1079 where entity_id=1079 
 {executed in 1 msec}
2020-11-25 10:11:25.960 INFO  jdbc.sqltiming Line:373 - select nodefiledd0_.nid as nid1_10_, nodefiledd0_.changed as changed2_10_, nodefiledd0_.created 
as created3_10_, nodefiledd0_.default_langcode as default_4_10_, nodefiledd0_.langcode as langcode5_10_, 
nodefiledd0_.promote as promote6_10_, nodefiledd0_.revision_translation_affected as revision7_10_, 
nodefiledd0_.status as status8_10_, nodefiledd0_.sticky as sticky9_10_, nodefiledd0_.title 
as title10_10_, nodefiledd0_.type as type11_10_, nodefiledd0_.uid as uid12_10_, nodefiledd0_.vid 
as vid13_10_ from node_field_data nodefiledd0_ where nodefiledd0_.nid=1079 
 {executed in 1 msec}
2020-11-25 10:11:25.960 INFO  jdbc.resultsettable Line:610 - 
|-----|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|-------------------------|-----|----|-----|
|nid  |changed    |created    |default_langcode |langcode |promote |revision_translation_affected |status |sticky |title                    |type |uid |vid  |
|-----|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|-------------------------|-----|----|-----|
|1079 |1606114967 |1606114967 |1                |zh-hans  |0       |1                             |1      |0      |46丨案例篇：为什么应用容器化后，启动慢了很多？ |book |1   |1079 |
|-----|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|-------------------------|-----|----|-----|

2020-11-25 10:11:25.961 INFO  jdbc.sqltiming Line:373 - select nodefieldr0_.nid as nid1_11_0_, nodefieldr0_.changed as changed2_11_0_, nodefieldr0_.created 
as created3_11_0_, nodefieldr0_.default_langcode as default_4_11_0_, nodefieldr0_.langcode 
as langcode5_11_0_, nodefieldr0_.promote as promote6_11_0_, nodefieldr0_.revision_translation_affected 
as revision7_11_0_, nodefieldr0_.status as status8_11_0_, nodefieldr0_.sticky as sticky9_11_0_, 
nodefieldr0_.title as title10_11_0_, nodefieldr0_.uid as uid11_11_0_, nodefieldr0_.vid as vid12_11_0_ 
from node_field_revision nodefieldr0_ where nodefieldr0_.nid=1079 
 {executed in 0 msec}
2020-11-25 10:11:25.962 INFO  jdbc.resultsettable Line:610 - 
|---------|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|-------------------------|----|-----|
|nid      |changed    |created    |default_langcode |langcode |promote |revision_translation_affected |status |sticky |title                    |uid |vid  |
|---------|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|-------------------------|----|-----|
|[unread] |1606114967 |1606114967 |1                |zh-hans  |0       |1                             |1      |0      |46丨案例篇：为什么应用容器化后，启动慢了很多？ |1   |1079 |
|---------|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|-------------------------|----|-----|

2020-11-25 10:11:25.963 INFO  jdbc.sqltiming Line:373 - update node_field_data set changed=1606270285, created=1606270285, default_langcode=1, langcode='zh-hans', 
promote=0, revision_translation_affected=1, status=1, sticky=0, title='46丨案例篇：为什么应用容器化后，启动慢了很多？', 
type='book', uid=1, vid=1079 where nid=1079 
 {executed in 0 msec}
2020-11-25 10:11:25.963 INFO  jdbc.sqltiming Line:373 - update node_field_revision set changed=1606270285, created=1606270285, default_langcode=1, 
langcode='zh-hans', promote=0, revision_translation_affected=1, status=1, sticky=0, title='46丨案例篇：为什么应用容器化后，启动慢了很多？', 
uid=1, vid=1079 where nid=1079 
 {executed in 0 msec}
2020-11-25 10:11:25.968 INFO  jdbc.sqltiming Line:373 - select bookfieldm0_.entity_id as entity_i1_8_, bookfieldm0_.bundle as bundle2_8_, bookfieldm0_.delta 
as delta3_8_, bookfieldm0_.langcode as langcode4_8_, bookfieldm0_.field_media_value as field_me5_8_, 
bookfieldm0_.revision_id as revision6_8_ from node__field_media bookfieldm0_ where bookfieldm0_.entity_id=1079 
 {executed in 0 msec}
2020-11-25 10:11:25.968 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------------|------------|
|entity_id |bundle |delta |langcode |field_media_value |revision_id |
|----------|-------|------|---------|------------------|------------|
|1079      |book   |0     |zh-hans  |                  |1079        |
|----------|-------|------|---------|------------------|------------|

2020-11-25 10:11:25.970 INFO  jdbc.sqltiming Line:373 - select nodefieldm0_.entity_id as entity_i1_17_0_, nodefieldm0_.bundle as bundle2_17_0_, nodefieldm0_.delta 
as delta3_17_0_, nodefieldm0_.langcode as langcode4_17_0_, nodefieldm0_.field_media_value as 
field_me5_17_0_, nodefieldm0_.revision_id as revision6_17_0_ from node_revision__field_media 
nodefieldm0_ where nodefieldm0_.entity_id=1079 
 {executed in 0 msec}
2020-11-25 10:11:25.971 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------------|------------|
|entity_id |bundle |delta |langcode |field_media_value |revision_id |
|----------|-------|------|---------|------------------|------------|
|[unread]  |book   |0     |zh-hans  |                  |1079        |
|----------|-------|------|---------|------------------|------------|

2020-11-25 10:11:25.972 INFO  jdbc.sqltiming Line:373 - select bookfieldc0_.entity_id as entity_i1_5_, bookfieldc0_.bundle as bundle2_5_, bookfieldc0_.field_comment_value 
as field_co3_5_, bookfieldc0_.delta as delta4_5_, bookfieldc0_.field_comment_format as field_co5_5_, 
bookfieldc0_.langcode as langcode6_5_, bookfieldc0_.revision_id as revision7_5_ from node__field_comment 
bookfieldc0_ where bookfieldc0_.entity_id=1079 
 {executed in 0 msec}
2020-11-25 10:11:25.972 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|--------------------|------|---------------------|---------|------------|
|entity_id |bundle |field_comment_value |delta |field_comment_format |langcode |revision_id |
|----------|-------|--------------------|------|---------------------|---------|------------|
|1079      |book   |                    |0     |full_html            |zh-hans  |1079        |
|----------|-------|--------------------|------|---------------------|---------|------------|

2020-11-25 10:11:25.975 INFO  jdbc.sqltiming Line:373 - update node__field_comment set bundle='book', field_comment_value='<li class="reJj6Thl_0"><img 
src="https://static001.geekbang.org/account/avatar/00/13/ec/21/b0fe1bfd.jpg" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>Adam</span> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-11 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">4</span> </div> <!----> 
<!----> </div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 这个问题应该是/proc 文件系统并不知道用户通过 Cgroups 
给这个容器做了限制导致的。 <br> </div> <!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 嗯嗯，正解！</p> 
</div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/16/15/93/cc3a1320.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>Tony</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-12 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> </div> <!----> 
<!----> </div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 这个例子对稍微有点docker和jvm的基础的人还是太简单了。应该上点serverless冷启动的分析。cold 
start是FaaS一个很大的问题，不知道你怎么用前面的知识分析一下？谢谢 </div> <!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 
cold start话题太大了，涉及的不止是单机内的问题。你如果有具体的问题，可以分享出来，大家一起讨论</p> </div> </div></li> <li class="reJj6Thl_0"><img 
src="https://static001.geekbang.org/account/avatar/00/14/11/4b/fa64f061.jpg" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>xfan</span> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-12 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> </div> <!----> 
<!----> </div> </div> <div class="_3M6kV3zb_0"> 和虚拟机内存设置也有关系，老师的是8G 30%就很大，我的2G 所以不大，也不会引起OOM，当我调成8G 
的时候就出现了和老师一样的现象了OOM </div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> 
</div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 嗯嗯 是这样的</p> </div> </div></li> 
<li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>我来也</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-11 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> </div> <!----> 
<!----> </div> </div> <div class="_3M6kV3zb_0"> [D46打卡] <br>看来真是有必要对容器做资源限制. <br>刚开始分配的资源可以不要计算得那么精准,只要别把机器拖垮即可. 
<br> <br>实战篇还是很有意思,根据症状去找各种程序及系统日志和各项配置参数. <br> <br>如果不做特殊处理,容器内部看到的系统cpu/memory配置确实都是主机的.程序默认根据这个来做策略调整确实会受到误导. 
<br> <br>目前工作中还没使用容器,暂时还没法在容器中实战.😁 </div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> 
</div> <!----> </div></li> <li class="reJj6Thl_0"><img src="https://wx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEKQMM4m7NHuicr55aRiblTSEWIYe0QqbpyHweaoAbG7j2v7UUElqqeP3Ihrm3UfDPDRb1Hv8LvPwXqA/132" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>ninuxer</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-11 </div> </div> <div 
class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> 
</div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0"> 打卡day49 <br>前两天在我们线下环境一台docker宿主机上，一直无法create容器，后来看日志，发现有两个可疑之处: 
<br>第一:docker日志显示socket文件损坏，但是当时运行其他docker管理命令能正常返回结果 <br>第二:宿主机上有个kworker/u80进程cpu利用率一直100%，最终是通过重启宿主机解决的～ 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 👍 谢谢分享</p> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/12/05/7f/d35ab9a1.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>z.l</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-04-17 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> 初学docker时解决的第一个问题就是没设置jvm的-Xmx导致oom的问题，前面的同事想当然的以为限制了容器内存也可以传递给jvm。 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <!----> </div></li> 
<li class="reJj6Thl_0"><img src="" class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> 
<div> <div class="_18Dng5rT_0"> <span>如果</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-04-11 
</div> </div> <div class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> 
<span class=""></span> </div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0"> DAY46，打卡 
<br> </div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <!----> 
</div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/13/2f/f4/2dede51a.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>小老鼠</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-28 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 测试应用软件的性能（比如用LoadRunner 或JMter）可以在容器中进行吗？ 
</div> <!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 可以的</p> </div> </div></li> 
<li class="reJj6Thl_0"><img src="" class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> 
<div> <div class="_18Dng5rT_0"> <span>腾达</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-12 
</div> </div> <div class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> 
<span class=""></span> </div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0"> 这里看java进程cpu的时候，使用了之前学到的perf 
record方法，但看docker内部函数名称的时候，还是遇到了问题，我的步骤如下： <br><span class="MathJax_Preview" style="color: 
inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-1-Frame" tabindex="0" 
style="position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>m</mi><mi>k</mi><mi>d</mi><mi>i</mi><mi>r</mi><mi>d</mi><mi>o</mi><mi>c</mi><mi>k</mi><mi>e</mi><mi>r</mi><mi>m</mi><mi>a</mi><mi>p</mi></math>" 
role="presentation"> <nobr aria-hidden="true"> <span class="math" id="MathJax-Span-1" style="width: 
9.402em; display: inline-block;"><span style="display: inline-block; position: relative; width: 
7.503em; height: 0px; font-size: 125%;"><span style="position: absolute; clip: rect(1.453em, 
1007.5em, 2.652em, -999.998em); top: -2.298em; left: 0em;"><span class="mrow" id="MathJax-Span-2"><span 
class="mi" id="MathJax-Span-3" style="font-family: MathJax_Math-italic;">m</span><span class="mi" 
id="MathJax-Span-4" style="font-family: MathJax_Math-italic;">k</span><span class="mi" id="MathJax-Span-5" 
style="font-family: MathJax_Math-italic;">d<span style="display: inline-block; overflow: hidden; 
height: 1px; width: 0.003em;"></span></span><span class="mi" id="MathJax-Span-6" style="font-family: 
MathJax_Math-italic;">i</span><span class="mi" id="MathJax-Span-7" style="font-family: MathJax_Math-italic;">r</span><span 
class="mi" id="MathJax-Span-8" style="font-family: MathJax_Math-italic;">d<span style="display: 
inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mi" 
id="MathJax-Span-9" style="font-family: MathJax_Math-italic;">o</span><span class="mi" id="MathJax-Span-10" 
style="font-family: MathJax_Math-italic;">c</span><span class="mi" id="MathJax-Span-11" style="font-family: 
MathJax_Math-italic;">k</span><span class="mi" id="MathJax-Span-12" style="font-family: MathJax_Math-italic;">e</span><span 
class="mi" id="MathJax-Span-13" style="font-family: MathJax_Math-italic;">r</span><span class="mi" 
id="MathJax-Span-14" style="font-family: MathJax_Math-italic;">m</span><span class="mi" id="MathJax-Span-15" 
style="font-family: MathJax_Math-italic;">a</span><span class="mi" id="MathJax-Span-16" style="font-family: 
MathJax_Math-italic;">p</span></span><span style="display: inline-block; width: 0px; height: 
2.302em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: 
-0.309em; border-left: 0px solid; width: 0px; height: 1.253em;"></span></span> </nobr><span 
class="MJX_Assistive_MathML" role="presentation"> <math xmlns="http://www.w3.org/1998/Math/MathML"> 
<mi> m </mi><mi> k </mi><mi> d </mi><mi> i </mi><mi> r </mi><mi> d </mi><mi> o </mi><mi> c 
</mi><mi> k </mi><mi> e </mi><mi> r </mi><mi> m </mi><mi> a </mi><mi> p </mi> </math></span></span> 
<script type="math/tex" id="MathJax-Element-1"></script> PID=<span class="MathJax_Preview" 
style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-2-Frame" 
tabindex="0" style="position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mo 
stretchy=&quot;false&quot;>(</mo><mi>d</mi><mi>o</mi><mi>c</mi><mi>k</mi><mi>e</mi><mi>r</mi><mi>i</mi><mi>n</mi><mi>s</mi><mi>p</mi><mi>e</mi><mi>c</mi><mi>t</mi><mo>−</mo><mo>−</mo><mi>f</mi><mi>o</mi><mi>r</mi><mi>m</mi><mi>a</mi><mi>t</mi><mrow 
class=&quot;MJX-TeXAtom-ORD&quot;><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>.</mo><mi>S</mi><mi>t</mi><mi>a</mi><mi>t</mi><mi>e</mi><mo>.</mo><mi>P</mi><mi>i</mi><mi>d</mi></mrow></mrow><mi>t</mi><mi>o</mi><mi>m</mi><mi>c</mi><mi>a</mi><mi>t</mi><mo 
stretchy=&quot;false&quot;>)</mo></math>" role="presentation"> <nobr aria-hidden="true"> <span 
class="math" id="MathJax-Span-17" style="width: 24.953em; display: inline-block;"><span style="display: 
inline-block; position: relative; width: 19.953em; height: 0px; font-size: 125%;"><span style="position: 
absolute; clip: rect(1.453em, 1019.85em, 2.752em, -999.998em); top: -2.348em; left: 0em;"><span 
class="mrow" id="MathJax-Span-18"><span class="mo" id="MathJax-Span-19" style="font-family: 
MathJax_Main;">(</span><span class="mi" id="MathJax-Span-20" style="font-family: MathJax_Math-italic;">d<span 
style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span 
class="mi" id="MathJax-Span-21" style="font-family: MathJax_Math-italic;">o</span><span class="mi" 
id="MathJax-Span-22" style="font-family: MathJax_Math-italic;">c</span><span class="mi" id="MathJax-Span-23" 
style="font-family: MathJax_Math-italic;">k</span><span class="mi" id="MathJax-Span-24" style="font-family: 
MathJax_Math-italic;">e</span><span class="mi" id="MathJax-Span-25" style="font-family: MathJax_Math-italic;">r</span><span 
class="mi" id="MathJax-Span-26" style="font-family: MathJax_Math-italic;">i</span><span class="mi" 
id="MathJax-Span-27" style="font-family: MathJax_Math-italic;">n</span><span class="mi" id="MathJax-Span-28" 
style="font-family: MathJax_Math-italic;">s</span><span class="mi" id="MathJax-Span-29" style="font-family: 
MathJax_Math-italic;">p</span><span class="mi" id="MathJax-Span-30" style="font-family: MathJax_Math-italic;">e</span><span 
class="mi" id="MathJax-Span-31" style="font-family: MathJax_Math-italic;">c</span><span class="mi" 
id="MathJax-Span-32" style="font-family: MathJax_Math-italic;">t</span><span class="mo" id="MathJax-Span-33" 
style="font-family: MathJax_Main; padding-left: 0.202em;">−</span><span class="mo" id="MathJax-Span-34" 
style="font-family: MathJax_Main; padding-left: 0.202em;">−</span><span class="mi" id="MathJax-Span-35" 
style="font-family: MathJax_Math-italic;">f<span style="display: inline-block; overflow: hidden; 
height: 1px; width: 0.053em;"></span></span><span class="mi" id="MathJax-Span-36" style="font-family: 
MathJax_Math-italic;">o</span><span class="mi" id="MathJax-Span-37" style="font-family: MathJax_Math-italic;">r</span><span 
class="mi" id="MathJax-Span-38" style="font-family: MathJax_Math-italic;">m</span><span class="mi" 
id="MathJax-Span-39" style="font-family: MathJax_Math-italic;">a</span><span class="mi" id="MathJax-Span-40" 
style="font-family: MathJax_Math-italic;">t</span><span class="texatom" id="MathJax-Span-41"><span 
class="mrow" id="MathJax-Span-42"><span class="texatom" id="MathJax-Span-43"><span class="mrow" 
id="MathJax-Span-44"><span class="mo" id="MathJax-Span-45" style="font-family: MathJax_Main;">.</span><span 
class="mi" id="MathJax-Span-46" style="font-family: MathJax_Math-italic; padding-left: 0.152em;">S<span 
style="display: inline-block; overflow: hidden; height: 1px; width: 0.053em;"></span></span><span 
class="mi" id="MathJax-Span-47" style="font-family: MathJax_Math-italic;">t</span><span class="mi" 
id="MathJax-Span-48" style="font-family: MathJax_Math-italic;">a</span><span class="mi" id="MathJax-Span-49" 
style="font-family: MathJax_Math-italic;">t</span><span class="mi" id="MathJax-Span-50" style="font-family: 
MathJax_Math-italic;">e</span><span class="mo" id="MathJax-Span-51" style="font-family: MathJax_Main;">.</span><span 
class="mi" id="MathJax-Span-52" style="font-family: MathJax_Math-italic; padding-left: 0.152em;">P<span 
style="display: inline-block; overflow: hidden; height: 1px; width: 0.102em;"></span></span><span 
class="mi" id="MathJax-Span-53" style="font-family: MathJax_Math-italic;">i</span><span class="mi" 
id="MathJax-Span-54" style="font-family: MathJax_Math-italic;">d<span style="display: inline-block; 
overflow: hidden; height: 1px; width: 0.003em;"></span></span></span></span></span></span><span 
class="mi" id="MathJax-Span-55" style="font-family: MathJax_Math-italic;">t</span><span class="mi" 
id="MathJax-Span-56" style="font-family: MathJax_Math-italic;">o</span><span class="mi" id="MathJax-Span-57" 
style="font-family: MathJax_Math-italic;">m</span><span class="mi" id="MathJax-Span-58" style="font-family: 
MathJax_Math-italic;">c</span><span class="mi" id="MathJax-Span-59" style="font-family: MathJax_Math-italic;">a</span><span 
class="mi" id="MathJax-Span-60" style="font-family: MathJax_Math-italic;">t</span><span class="mo" 
id="MathJax-Span-61" style="font-family: MathJax_Main;">)</span></span><span style="display: 
inline-block; width: 0px; height: 2.353em;"></span></span></span><span style="display: inline-block; 
overflow: hidden; vertical-align: -0.372em; border-left: 0px solid; width: 0px; height: 1.378em;"></span></span> 
</nobr><span class="MJX_Assistive_MathML" role="presentation"> <math xmlns="http://www.w3.org/1998/Math/MathML"> 
<mo stretchy="false"> ( </mo><mi> d </mi><mi> o </mi><mi> c </mi><mi> k </mi><mi> e </mi><mi> 
r </mi><mi> i </mi><mi> n </mi><mi> s </mi><mi> p </mi><mi> e </mi><mi> c </mi><mi> t </mi><mo> 
− </mo><mo> − </mo><mi> f </mi><mi> o </mi><mi> r </mi><mi> m </mi><mi> a </mi><mi> t </mi><mrow 
class="MJX-TeXAtom-ORD"> <mrow class="MJX-TeXAtom-ORD"> <mo> . </mo> <mi> S </mi> <mi> t </mi> 
<mi> a </mi> <mi> t </mi> <mi> e </mi> <mo> . </mo> <mi> P </mi> <mi> i </mi> <mi> d </mi> 
</mrow> </mrow><mi> t </mi><mi> o </mi><mi> m </mi><mi> c </mi><mi> a </mi><mi> t </mi><mo 
stretchy="false"> ) </mo> </math></span></span> <script type="math/tex" id="MathJax-Element-2"></script> 
sudo bindfs /proc/<span class="MathJax_Preview" style="color: inherit; display: none;"></span><span 
class="MathJax" id="MathJax-Element-3-Frame" tabindex="0" style="position: relative;" data-mathml="<math 
xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>P</mi><mi>I</mi><mi>D</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>/</mo></mrow><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi><mi>d</mi><mi>o</mi><mi>c</mi><mi>k</mi><mi>e</mi><mi>r</mi><mi>m</mi><mi>a</mi><mi>p</mi></math>" 
role="presentation"> <nobr aria-hidden="true"> <span class="math" id="MathJax-Span-62" style="width: 
11.453em; display: inline-block;"><span style="display: inline-block; position: relative; width: 
9.152em; height: 0px; font-size: 125%;"><span style="position: absolute; clip: rect(1.453em, 
1009.15em, 2.752em, -999.998em); top: -2.348em; left: 0em;"><span class="mrow" id="MathJax-Span-63"><span 
class="mi" id="MathJax-Span-64" style="font-family: MathJax_Math-italic;">P<span style="display: 
inline-block; overflow: hidden; height: 1px; width: 0.102em;"></span></span><span class="mi" 
id="MathJax-Span-65" style="font-family: MathJax_Math-italic;">I<span style="display: inline-block; 
overflow: hidden; height: 1px; width: 0.053em;"></span></span><span class="mi" id="MathJax-Span-66" 
style="font-family: MathJax_Math-italic;">D</span><span class="texatom" id="MathJax-Span-67"><span 
class="mrow" id="MathJax-Span-68"><span class="mo" id="MathJax-Span-69" style="font-family: 
MathJax_Main;">/</span></span></span><span class="mi" id="MathJax-Span-70" style="font-family: 
MathJax_Math-italic;">r</span><span class="mi" id="MathJax-Span-71" style="font-family: MathJax_Math-italic;">o</span><span 
class="mi" id="MathJax-Span-72" style="font-family: MathJax_Math-italic;">o</span><span class="mi" 
id="MathJax-Span-73" style="font-family: MathJax_Math-italic;">t</span><span class="mi" id="MathJax-Span-74" 
style="font-family: MathJax_Math-italic;">d<span style="display: inline-block; overflow: hidden; 
height: 1px; width: 0.003em;"></span></span><span class="mi" id="MathJax-Span-75" style="font-family: 
MathJax_Math-italic;">o</span><span class="mi" id="MathJax-Span-76" style="font-family: MathJax_Math-italic;">c</span><span 
class="mi" id="MathJax-Span-77" style="font-family: MathJax_Math-italic;">k</span><span class="mi" 
id="MathJax-Span-78" style="font-family: MathJax_Math-italic;">e</span><span class="mi" id="MathJax-Span-79" 
style="font-family: MathJax_Math-italic;">r</span><span class="mi" id="MathJax-Span-80" style="font-family: 
MathJax_Math-italic;">m</span><span class="mi" id="MathJax-Span-81" style="font-family: MathJax_Math-italic;">a</span><span 
class="mi" id="MathJax-Span-82" style="font-family: MathJax_Math-italic;">p</span></span><span 
style="display: inline-block; width: 0px; height: 2.353em;"></span></span></span><span style="display: 
inline-block; overflow: hidden; vertical-align: -0.372em; border-left: 0px solid; width: 0px; 
height: 1.378em;"></span></span> </nobr><span class="MJX_Assistive_MathML" role="presentation"> 
<math xmlns="http://www.w3.org/1998/Math/MathML"> <mi> P </mi><mi> I </mi><mi> D </mi><mrow 
class="MJX-TeXAtom-ORD"> <mo> / </mo> </mrow><mi> r </mi><mi> o </mi><mi> o </mi><mi> t </mi><mi> 
d </mi><mi> o </mi><mi> c </mi><mi> k </mi><mi> e </mi><mi> r </mi><mi> m </mi><mi> a </mi><mi> 
p </mi> </math></span></span> <script type="math/tex" id="MathJax-Element-3"></script> sudo 
perf record -g -p <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span 
class="MathJax" id="MathJax-Element-4-Frame" tabindex="0" style="position: relative;" data-mathml="<math 
xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>P</mi><mi>I</mi><mi>D</mi></math>" 
role="presentation"> <nobr aria-hidden="true"> <span class="math" id="MathJax-Span-83" style="width: 
2.652em; display: inline-block;"><span style="display: inline-block; position: relative; width: 
2.103em; height: 0px; font-size: 125%;"><span style="position: absolute; clip: rect(1.453em, 
1002.1em, 2.452em, -999.998em); top: -2.298em; left: 0em;"><span class="mrow" id="MathJax-Span-84"><span 
class="mi" id="MathJax-Span-85" style="font-family: MathJax_Math-italic;">P<span style="display: 
inline-block; overflow: hidden; height: 1px; width: 0.102em;"></span></span><span class="mi" 
id="MathJax-Span-86" style="font-family: MathJax_Math-italic;">I<span style="display: inline-block; 
overflow: hidden; height: 1px; width: 0.053em;"></span></span><span class="mi" id="MathJax-Span-87" 
style="font-family: MathJax_Math-italic;">D</span></span><span style="display: inline-block; 
width: 0px; height: 2.302em;"></span></span></span><span style="display: inline-block; overflow: 
hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 1.003em;"></span></span> 
</nobr><span class="MJX_Assistive_MathML" role="presentation"> <math xmlns="http://www.w3.org/1998/Math/MathML"> 
<mi> P </mi><mi> I </mi><mi> D </mi> </math></span></span> <script type="math/tex" id="MathJax-Element-4"></script> 
sudo perf report --symfs dockermap <br> <br>- 99.95% 0.00% java libjvm.so [.] 0x00000000008bf292 
<br>&nbsp;&nbsp;&nbsp;- 0x8bf292 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- 67.44% 0xa79ff1 
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0xa79af6 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0xa78677 
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0xa7afc7 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0xa75d62 
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ 0x8e6853 </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 
Java的问题请参考https://github.com/jvm-profiling-tools/perf-map-agent</p> </div> </div></li> <li 
class="reJj6Thl_0"><img src="" class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> 
<div> <div class="_18Dng5rT_0"> <span>腾达</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-12 
</div> </div> <div class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> 
<span class=""></span> </div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0"> 我的tomcat为什么不能实现oom？dmesg显示没有oom，进程也没有被杀死。我看有其他网友留言说要虚拟机内存设为8G，我的是设置为8G了。 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 执行 docker exec tomcat java -XX:+PrintFlagsFinal -version | grep 
HeapSize 确认一下容器中java的堆内存？</p> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/0f/9a/e6/97443550.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>ttxser</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-11 </div> </div> <div 
class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> 
</div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0"> 值了 </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <!----> </div></li> <li class="reJj6Thl_0"><img 
src="https://static001.geekbang.org/account/avatar/00/13/57/6e/dd0eee5f.jpg" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>夜空中最亮...</span> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-11 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> 很受启发，最近也在钻研docker 和k8s </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <!----> </div></li> <li class="reJj6Thl_0"><img 
src="http://thirdwx.qlogo.cn/mmopen/vi_32/XC10ibnwF0jtwgksFoSuUCMtgfK0Ndk5Wib3Xyr5Yyz9xiaCrKibNicPksVmicpZEatWgPPLfMXz3jCGMMiclHHQlku4Q/132" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>rock04</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-11 </div> </div> <div 
class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> 
</div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0"> 老师，今天工作做遇到一个平均负载的问题。8C的虚拟机。只有一个java进程，但是平均负载很高超过8.甚至达到12。查看CPU 
IO都很低 这个应该怎么排查 </div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> 
<!----> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/0f/a0/2d/2fee2d83.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>且听风吟</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-11 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 启动容器几分钟后，直接把宿主机跑死了，没法继续进行，这是怎么回事呢？ </div> 
<!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 主机内存多大？重启后可以看看系统日志，一般会有上次为啥死机的线索</p> 
</div> </div></li>', delta=0, field_comment_format='full_html', langcode='zh-hans', revision_id=1079 
where entity_id=1079 
 {executed in 1 msec}
2020-11-25 10:11:25.980 INFO  jdbc.sqltiming Line:373 - select nodefieldc0_.entity_id as entity_i1_14_0_, nodefieldc0_.bundle as bundle2_14_0_, nodefieldc0_.field_comment_value 
as field_co3_14_0_, nodefieldc0_.delta as delta4_14_0_, nodefieldc0_.field_comment_format as 
field_co5_14_0_, nodefieldc0_.langcode as langcode6_14_0_, nodefieldc0_.revision_id as revision7_14_0_ 
from node_revision__field_comment nodefieldc0_ where nodefieldc0_.entity_id=1079 
 {executed in 1 msec}
2020-11-25 10:11:25.980 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|--------------------|------|---------------------|---------|------------|
|entity_id |bundle |field_comment_value |delta |field_comment_format |langcode |revision_id |
|----------|-------|--------------------|------|---------------------|---------|------------|
|[unread]  |book   |                    |0     |full_html            |zh-hans  |1079        |
|----------|-------|--------------------|------|---------------------|---------|------------|

2020-11-25 10:11:25.983 INFO  jdbc.sqltiming Line:373 - update node_revision__field_comment set bundle='book', field_comment_value='<li class="reJj6Thl_0"><img 
src="https://static001.geekbang.org/account/avatar/00/13/ec/21/b0fe1bfd.jpg" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>Adam</span> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-11 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">4</span> </div> <!----> 
<!----> </div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 这个问题应该是/proc 文件系统并不知道用户通过 Cgroups 
给这个容器做了限制导致的。 <br> </div> <!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 嗯嗯，正解！</p> 
</div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/16/15/93/cc3a1320.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>Tony</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-12 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> </div> <!----> 
<!----> </div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 这个例子对稍微有点docker和jvm的基础的人还是太简单了。应该上点serverless冷启动的分析。cold 
start是FaaS一个很大的问题，不知道你怎么用前面的知识分析一下？谢谢 </div> <!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 
cold start话题太大了，涉及的不止是单机内的问题。你如果有具体的问题，可以分享出来，大家一起讨论</p> </div> </div></li> <li class="reJj6Thl_0"><img 
src="https://static001.geekbang.org/account/avatar/00/14/11/4b/fa64f061.jpg" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>xfan</span> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-12 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> </div> <!----> 
<!----> </div> </div> <div class="_3M6kV3zb_0"> 和虚拟机内存设置也有关系，老师的是8G 30%就很大，我的2G 所以不大，也不会引起OOM，当我调成8G 
的时候就出现了和老师一样的现象了OOM </div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> 
</div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 嗯嗯 是这样的</p> </div> </div></li> 
<li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>我来也</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-11 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> </div> <!----> 
<!----> </div> </div> <div class="_3M6kV3zb_0"> [D46打卡] <br>看来真是有必要对容器做资源限制. <br>刚开始分配的资源可以不要计算得那么精准,只要别把机器拖垮即可. 
<br> <br>实战篇还是很有意思,根据症状去找各种程序及系统日志和各项配置参数. <br> <br>如果不做特殊处理,容器内部看到的系统cpu/memory配置确实都是主机的.程序默认根据这个来做策略调整确实会受到误导. 
<br> <br>目前工作中还没使用容器,暂时还没法在容器中实战.😁 </div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> 
</div> <!----> </div></li> <li class="reJj6Thl_0"><img src="https://wx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEKQMM4m7NHuicr55aRiblTSEWIYe0QqbpyHweaoAbG7j2v7UUElqqeP3Ihrm3UfDPDRb1Hv8LvPwXqA/132" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>ninuxer</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-11 </div> </div> <div 
class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> 
</div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0"> 打卡day49 <br>前两天在我们线下环境一台docker宿主机上，一直无法create容器，后来看日志，发现有两个可疑之处: 
<br>第一:docker日志显示socket文件损坏，但是当时运行其他docker管理命令能正常返回结果 <br>第二:宿主机上有个kworker/u80进程cpu利用率一直100%，最终是通过重启宿主机解决的～ 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 👍 谢谢分享</p> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/12/05/7f/d35ab9a1.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>z.l</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-04-17 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> 初学docker时解决的第一个问题就是没设置jvm的-Xmx导致oom的问题，前面的同事想当然的以为限制了容器内存也可以传递给jvm。 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <!----> </div></li> 
<li class="reJj6Thl_0"><img src="" class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> 
<div> <div class="_18Dng5rT_0"> <span>如果</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-04-11 
</div> </div> <div class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> 
<span class=""></span> </div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0"> DAY46，打卡 
<br> </div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <!----> 
</div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/13/2f/f4/2dede51a.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>小老鼠</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-28 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 测试应用软件的性能（比如用LoadRunner 或JMter）可以在容器中进行吗？ 
</div> <!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 可以的</p> </div> </div></li> 
<li class="reJj6Thl_0"><img src="" class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> 
<div> <div class="_18Dng5rT_0"> <span>腾达</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-12 
</div> </div> <div class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> 
<span class=""></span> </div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0"> 这里看java进程cpu的时候，使用了之前学到的perf 
record方法，但看docker内部函数名称的时候，还是遇到了问题，我的步骤如下： <br><span class="MathJax_Preview" style="color: 
inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-1-Frame" tabindex="0" 
style="position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>m</mi><mi>k</mi><mi>d</mi><mi>i</mi><mi>r</mi><mi>d</mi><mi>o</mi><mi>c</mi><mi>k</mi><mi>e</mi><mi>r</mi><mi>m</mi><mi>a</mi><mi>p</mi></math>" 
role="presentation"> <nobr aria-hidden="true"> <span class="math" id="MathJax-Span-1" style="width: 
9.402em; display: inline-block;"><span style="display: inline-block; position: relative; width: 
7.503em; height: 0px; font-size: 125%;"><span style="position: absolute; clip: rect(1.453em, 
1007.5em, 2.652em, -999.998em); top: -2.298em; left: 0em;"><span class="mrow" id="MathJax-Span-2"><span 
class="mi" id="MathJax-Span-3" style="font-family: MathJax_Math-italic;">m</span><span class="mi" 
id="MathJax-Span-4" style="font-family: MathJax_Math-italic;">k</span><span class="mi" id="MathJax-Span-5" 
style="font-family: MathJax_Math-italic;">d<span style="display: inline-block; overflow: hidden; 
height: 1px; width: 0.003em;"></span></span><span class="mi" id="MathJax-Span-6" style="font-family: 
MathJax_Math-italic;">i</span><span class="mi" id="MathJax-Span-7" style="font-family: MathJax_Math-italic;">r</span><span 
class="mi" id="MathJax-Span-8" style="font-family: MathJax_Math-italic;">d<span style="display: 
inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mi" 
id="MathJax-Span-9" style="font-family: MathJax_Math-italic;">o</span><span class="mi" id="MathJax-Span-10" 
style="font-family: MathJax_Math-italic;">c</span><span class="mi" id="MathJax-Span-11" style="font-family: 
MathJax_Math-italic;">k</span><span class="mi" id="MathJax-Span-12" style="font-family: MathJax_Math-italic;">e</span><span 
class="mi" id="MathJax-Span-13" style="font-family: MathJax_Math-italic;">r</span><span class="mi" 
id="MathJax-Span-14" style="font-family: MathJax_Math-italic;">m</span><span class="mi" id="MathJax-Span-15" 
style="font-family: MathJax_Math-italic;">a</span><span class="mi" id="MathJax-Span-16" style="font-family: 
MathJax_Math-italic;">p</span></span><span style="display: inline-block; width: 0px; height: 
2.302em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: 
-0.309em; border-left: 0px solid; width: 0px; height: 1.253em;"></span></span> </nobr><span 
class="MJX_Assistive_MathML" role="presentation"> <math xmlns="http://www.w3.org/1998/Math/MathML"> 
<mi> m </mi><mi> k </mi><mi> d </mi><mi> i </mi><mi> r </mi><mi> d </mi><mi> o </mi><mi> c 
</mi><mi> k </mi><mi> e </mi><mi> r </mi><mi> m </mi><mi> a </mi><mi> p </mi> </math></span></span> 
<script type="math/tex" id="MathJax-Element-1"></script> PID=<span class="MathJax_Preview" 
style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-2-Frame" 
tabindex="0" style="position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mo 
stretchy=&quot;false&quot;>(</mo><mi>d</mi><mi>o</mi><mi>c</mi><mi>k</mi><mi>e</mi><mi>r</mi><mi>i</mi><mi>n</mi><mi>s</mi><mi>p</mi><mi>e</mi><mi>c</mi><mi>t</mi><mo>−</mo><mo>−</mo><mi>f</mi><mi>o</mi><mi>r</mi><mi>m</mi><mi>a</mi><mi>t</mi><mrow 
class=&quot;MJX-TeXAtom-ORD&quot;><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>.</mo><mi>S</mi><mi>t</mi><mi>a</mi><mi>t</mi><mi>e</mi><mo>.</mo><mi>P</mi><mi>i</mi><mi>d</mi></mrow></mrow><mi>t</mi><mi>o</mi><mi>m</mi><mi>c</mi><mi>a</mi><mi>t</mi><mo 
stretchy=&quot;false&quot;>)</mo></math>" role="presentation"> <nobr aria-hidden="true"> <span 
class="math" id="MathJax-Span-17" style="width: 24.953em; display: inline-block;"><span style="display: 
inline-block; position: relative; width: 19.953em; height: 0px; font-size: 125%;"><span style="position: 
absolute; clip: rect(1.453em, 1019.85em, 2.752em, -999.998em); top: -2.348em; left: 0em;"><span 
class="mrow" id="MathJax-Span-18"><span class="mo" id="MathJax-Span-19" style="font-family: 
MathJax_Main;">(</span><span class="mi" id="MathJax-Span-20" style="font-family: MathJax_Math-italic;">d<span 
style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span 
class="mi" id="MathJax-Span-21" style="font-family: MathJax_Math-italic;">o</span><span class="mi" 
id="MathJax-Span-22" style="font-family: MathJax_Math-italic;">c</span><span class="mi" id="MathJax-Span-23" 
style="font-family: MathJax_Math-italic;">k</span><span class="mi" id="MathJax-Span-24" style="font-family: 
MathJax_Math-italic;">e</span><span class="mi" id="MathJax-Span-25" style="font-family: MathJax_Math-italic;">r</span><span 
class="mi" id="MathJax-Span-26" style="font-family: MathJax_Math-italic;">i</span><span class="mi" 
id="MathJax-Span-27" style="font-family: MathJax_Math-italic;">n</span><span class="mi" id="MathJax-Span-28" 
style="font-family: MathJax_Math-italic;">s</span><span class="mi" id="MathJax-Span-29" style="font-family: 
MathJax_Math-italic;">p</span><span class="mi" id="MathJax-Span-30" style="font-family: MathJax_Math-italic;">e</span><span 
class="mi" id="MathJax-Span-31" style="font-family: MathJax_Math-italic;">c</span><span class="mi" 
id="MathJax-Span-32" style="font-family: MathJax_Math-italic;">t</span><span class="mo" id="MathJax-Span-33" 
style="font-family: MathJax_Main; padding-left: 0.202em;">−</span><span class="mo" id="MathJax-Span-34" 
style="font-family: MathJax_Main; padding-left: 0.202em;">−</span><span class="mi" id="MathJax-Span-35" 
style="font-family: MathJax_Math-italic;">f<span style="display: inline-block; overflow: hidden; 
height: 1px; width: 0.053em;"></span></span><span class="mi" id="MathJax-Span-36" style="font-family: 
MathJax_Math-italic;">o</span><span class="mi" id="MathJax-Span-37" style="font-family: MathJax_Math-italic;">r</span><span 
class="mi" id="MathJax-Span-38" style="font-family: MathJax_Math-italic;">m</span><span class="mi" 
id="MathJax-Span-39" style="font-family: MathJax_Math-italic;">a</span><span class="mi" id="MathJax-Span-40" 
style="font-family: MathJax_Math-italic;">t</span><span class="texatom" id="MathJax-Span-41"><span 
class="mrow" id="MathJax-Span-42"><span class="texatom" id="MathJax-Span-43"><span class="mrow" 
id="MathJax-Span-44"><span class="mo" id="MathJax-Span-45" style="font-family: MathJax_Main;">.</span><span 
class="mi" id="MathJax-Span-46" style="font-family: MathJax_Math-italic; padding-left: 0.152em;">S<span 
style="display: inline-block; overflow: hidden; height: 1px; width: 0.053em;"></span></span><span 
class="mi" id="MathJax-Span-47" style="font-family: MathJax_Math-italic;">t</span><span class="mi" 
id="MathJax-Span-48" style="font-family: MathJax_Math-italic;">a</span><span class="mi" id="MathJax-Span-49" 
style="font-family: MathJax_Math-italic;">t</span><span class="mi" id="MathJax-Span-50" style="font-family: 
MathJax_Math-italic;">e</span><span class="mo" id="MathJax-Span-51" style="font-family: MathJax_Main;">.</span><span 
class="mi" id="MathJax-Span-52" style="font-family: MathJax_Math-italic; padding-left: 0.152em;">P<span 
style="display: inline-block; overflow: hidden; height: 1px; width: 0.102em;"></span></span><span 
class="mi" id="MathJax-Span-53" style="font-family: MathJax_Math-italic;">i</span><span class="mi" 
id="MathJax-Span-54" style="font-family: MathJax_Math-italic;">d<span style="display: inline-block; 
overflow: hidden; height: 1px; width: 0.003em;"></span></span></span></span></span></span><span 
class="mi" id="MathJax-Span-55" style="font-family: MathJax_Math-italic;">t</span><span class="mi" 
id="MathJax-Span-56" style="font-family: MathJax_Math-italic;">o</span><span class="mi" id="MathJax-Span-57" 
style="font-family: MathJax_Math-italic;">m</span><span class="mi" id="MathJax-Span-58" style="font-family: 
MathJax_Math-italic;">c</span><span class="mi" id="MathJax-Span-59" style="font-family: MathJax_Math-italic;">a</span><span 
class="mi" id="MathJax-Span-60" style="font-family: MathJax_Math-italic;">t</span><span class="mo" 
id="MathJax-Span-61" style="font-family: MathJax_Main;">)</span></span><span style="display: 
inline-block; width: 0px; height: 2.353em;"></span></span></span><span style="display: inline-block; 
overflow: hidden; vertical-align: -0.372em; border-left: 0px solid; width: 0px; height: 1.378em;"></span></span> 
</nobr><span class="MJX_Assistive_MathML" role="presentation"> <math xmlns="http://www.w3.org/1998/Math/MathML"> 
<mo stretchy="false"> ( </mo><mi> d </mi><mi> o </mi><mi> c </mi><mi> k </mi><mi> e </mi><mi> 
r </mi><mi> i </mi><mi> n </mi><mi> s </mi><mi> p </mi><mi> e </mi><mi> c </mi><mi> t </mi><mo> 
− </mo><mo> − </mo><mi> f </mi><mi> o </mi><mi> r </mi><mi> m </mi><mi> a </mi><mi> t </mi><mrow 
class="MJX-TeXAtom-ORD"> <mrow class="MJX-TeXAtom-ORD"> <mo> . </mo> <mi> S </mi> <mi> t </mi> 
<mi> a </mi> <mi> t </mi> <mi> e </mi> <mo> . </mo> <mi> P </mi> <mi> i </mi> <mi> d </mi> 
</mrow> </mrow><mi> t </mi><mi> o </mi><mi> m </mi><mi> c </mi><mi> a </mi><mi> t </mi><mo 
stretchy="false"> ) </mo> </math></span></span> <script type="math/tex" id="MathJax-Element-2"></script> 
sudo bindfs /proc/<span class="MathJax_Preview" style="color: inherit; display: none;"></span><span 
class="MathJax" id="MathJax-Element-3-Frame" tabindex="0" style="position: relative;" data-mathml="<math 
xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>P</mi><mi>I</mi><mi>D</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>/</mo></mrow><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi><mi>d</mi><mi>o</mi><mi>c</mi><mi>k</mi><mi>e</mi><mi>r</mi><mi>m</mi><mi>a</mi><mi>p</mi></math>" 
role="presentation"> <nobr aria-hidden="true"> <span class="math" id="MathJax-Span-62" style="width: 
11.453em; display: inline-block;"><span style="display: inline-block; position: relative; width: 
9.152em; height: 0px; font-size: 125%;"><span style="position: absolute; clip: rect(1.453em, 
1009.15em, 2.752em, -999.998em); top: -2.348em; left: 0em;"><span class="mrow" id="MathJax-Span-63"><span 
class="mi" id="MathJax-Span-64" style="font-family: MathJax_Math-italic;">P<span style="display: 
inline-block; overflow: hidden; height: 1px; width: 0.102em;"></span></span><span class="mi" 
id="MathJax-Span-65" style="font-family: MathJax_Math-italic;">I<span style="display: inline-block; 
overflow: hidden; height: 1px; width: 0.053em;"></span></span><span class="mi" id="MathJax-Span-66" 
style="font-family: MathJax_Math-italic;">D</span><span class="texatom" id="MathJax-Span-67"><span 
class="mrow" id="MathJax-Span-68"><span class="mo" id="MathJax-Span-69" style="font-family: 
MathJax_Main;">/</span></span></span><span class="mi" id="MathJax-Span-70" style="font-family: 
MathJax_Math-italic;">r</span><span class="mi" id="MathJax-Span-71" style="font-family: MathJax_Math-italic;">o</span><span 
class="mi" id="MathJax-Span-72" style="font-family: MathJax_Math-italic;">o</span><span class="mi" 
id="MathJax-Span-73" style="font-family: MathJax_Math-italic;">t</span><span class="mi" id="MathJax-Span-74" 
style="font-family: MathJax_Math-italic;">d<span style="display: inline-block; overflow: hidden; 
height: 1px; width: 0.003em;"></span></span><span class="mi" id="MathJax-Span-75" style="font-family: 
MathJax_Math-italic;">o</span><span class="mi" id="MathJax-Span-76" style="font-family: MathJax_Math-italic;">c</span><span 
class="mi" id="MathJax-Span-77" style="font-family: MathJax_Math-italic;">k</span><span class="mi" 
id="MathJax-Span-78" style="font-family: MathJax_Math-italic;">e</span><span class="mi" id="MathJax-Span-79" 
style="font-family: MathJax_Math-italic;">r</span><span class="mi" id="MathJax-Span-80" style="font-family: 
MathJax_Math-italic;">m</span><span class="mi" id="MathJax-Span-81" style="font-family: MathJax_Math-italic;">a</span><span 
class="mi" id="MathJax-Span-82" style="font-family: MathJax_Math-italic;">p</span></span><span 
style="display: inline-block; width: 0px; height: 2.353em;"></span></span></span><span style="display: 
inline-block; overflow: hidden; vertical-align: -0.372em; border-left: 0px solid; width: 0px; 
height: 1.378em;"></span></span> </nobr><span class="MJX_Assistive_MathML" role="presentation"> 
<math xmlns="http://www.w3.org/1998/Math/MathML"> <mi> P </mi><mi> I </mi><mi> D </mi><mrow 
class="MJX-TeXAtom-ORD"> <mo> / </mo> </mrow><mi> r </mi><mi> o </mi><mi> o </mi><mi> t </mi><mi> 
d </mi><mi> o </mi><mi> c </mi><mi> k </mi><mi> e </mi><mi> r </mi><mi> m </mi><mi> a </mi><mi> 
p </mi> </math></span></span> <script type="math/tex" id="MathJax-Element-3"></script> sudo 
perf record -g -p <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span 
class="MathJax" id="MathJax-Element-4-Frame" tabindex="0" style="position: relative;" data-mathml="<math 
xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>P</mi><mi>I</mi><mi>D</mi></math>" 
role="presentation"> <nobr aria-hidden="true"> <span class="math" id="MathJax-Span-83" style="width: 
2.652em; display: inline-block;"><span style="display: inline-block; position: relative; width: 
2.103em; height: 0px; font-size: 125%;"><span style="position: absolute; clip: rect(1.453em, 
1002.1em, 2.452em, -999.998em); top: -2.298em; left: 0em;"><span class="mrow" id="MathJax-Span-84"><span 
class="mi" id="MathJax-Span-85" style="font-family: MathJax_Math-italic;">P<span style="display: 
inline-block; overflow: hidden; height: 1px; width: 0.102em;"></span></span><span class="mi" 
id="MathJax-Span-86" style="font-family: MathJax_Math-italic;">I<span style="display: inline-block; 
overflow: hidden; height: 1px; width: 0.053em;"></span></span><span class="mi" id="MathJax-Span-87" 
style="font-family: MathJax_Math-italic;">D</span></span><span style="display: inline-block; 
width: 0px; height: 2.302em;"></span></span></span><span style="display: inline-block; overflow: 
hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 1.003em;"></span></span> 
</nobr><span class="MJX_Assistive_MathML" role="presentation"> <math xmlns="http://www.w3.org/1998/Math/MathML"> 
<mi> P </mi><mi> I </mi><mi> D </mi> </math></span></span> <script type="math/tex" id="MathJax-Element-4"></script> 
sudo perf report --symfs dockermap <br> <br>- 99.95% 0.00% java libjvm.so [.] 0x00000000008bf292 
<br>&nbsp;&nbsp;&nbsp;- 0x8bf292 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- 67.44% 0xa79ff1 
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0xa79af6 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0xa78677 
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0xa7afc7 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0xa75d62 
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ 0x8e6853 </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 
Java的问题请参考https://github.com/jvm-profiling-tools/perf-map-agent</p> </div> </div></li> <li 
class="reJj6Thl_0"><img src="" class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> 
<div> <div class="_18Dng5rT_0"> <span>腾达</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-12 
</div> </div> <div class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> 
<span class=""></span> </div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0"> 我的tomcat为什么不能实现oom？dmesg显示没有oom，进程也没有被杀死。我看有其他网友留言说要虚拟机内存设为8G，我的是设置为8G了。 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 执行 docker exec tomcat java -XX:+PrintFlagsFinal -version | grep 
HeapSize 确认一下容器中java的堆内存？</p> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/0f/9a/e6/97443550.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>ttxser</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-11 </div> </div> <div 
class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> 
</div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0"> 值了 </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <!----> </div></li> <li class="reJj6Thl_0"><img 
src="https://static001.geekbang.org/account/avatar/00/13/57/6e/dd0eee5f.jpg" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>夜空中最亮...</span> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-11 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> 很受启发，最近也在钻研docker 和k8s </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <!----> </div></li> <li class="reJj6Thl_0"><img 
src="http://thirdwx.qlogo.cn/mmopen/vi_32/XC10ibnwF0jtwgksFoSuUCMtgfK0Ndk5Wib3Xyr5Yyz9xiaCrKibNicPksVmicpZEatWgPPLfMXz3jCGMMiclHHQlku4Q/132" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>rock04</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-11 </div> </div> <div 
class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> 
</div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0"> 老师，今天工作做遇到一个平均负载的问题。8C的虚拟机。只有一个java进程，但是平均负载很高超过8.甚至达到12。查看CPU 
IO都很低 这个应该怎么排查 </div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> 
<!----> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/0f/a0/2d/2fee2d83.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>且听风吟</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-11 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 启动容器几分钟后，直接把宿主机跑死了，没法继续进行，这是怎么回事呢？ </div> 
<!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 主机内存多大？重启后可以看看系统日志，一般会有上次为啥死机的线索</p> 
</div> </div></li>', delta=0, field_comment_format='full_html', langcode='zh-hans', revision_id=1079 
where entity_id=1079 
 {executed in 1 msec}
2020-11-25 10:11:25.986 INFO  jdbc.sqltiming Line:373 - select bookfieldt0_.entity_id as entity_i1_9_, bookfieldt0_.bundle as bundle2_9_, bookfieldt0_.delta 
as delta3_9_, bookfieldt0_.langcode as langcode4_9_, bookfieldt0_.revision_id as revision5_9_, 
bookfieldt0_.field_thumb_value as field_th6_9_ from node__field_thumb bookfieldt0_ where bookfieldt0_.entity_id=1079 
 {executed in 0 msec}
2020-11-25 10:11:25.987 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------|------------------|
|entity_id |bundle |delta |langcode |revision_id |field_thumb_value |
|----------|-------|------|---------|------------|------------------|
|1079      |book   |0     |zh-hans  |1079        |                  |
|----------|-------|------|---------|------------|------------------|

2020-11-25 10:11:25.989 INFO  jdbc.sqltiming Line:373 - update node__field_thumb set bundle='book', delta=0, langcode='zh-hans', revision_id=1079, 
field_thumb_value='https://static001.geekbang.org/resource/image/c5/27/c5c943d776b2b72eb123de19e57c0827.jpg' 
where entity_id=1079 
 {executed in 1 msec}
2020-11-25 10:11:25.991 INFO  jdbc.sqltiming Line:373 - select nodefieldt0_.entity_id as entity_i1_18_0_, nodefieldt0_.bundle as bundle2_18_0_, nodefieldt0_.delta 
as delta3_18_0_, nodefieldt0_.langcode as langcode4_18_0_, nodefieldt0_.revision_id as revision5_18_0_, 
nodefieldt0_.field_thumb_value as field_th6_18_0_ from node_revision__field_thumb nodefieldt0_ 
where nodefieldt0_.entity_id=1079 
 {executed in 0 msec}
2020-11-25 10:11:25.992 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------|------------------|
|entity_id |bundle |delta |langcode |revision_id |field_thumb_value |
|----------|-------|------|---------|------------|------------------|
|[unread]  |book   |0     |zh-hans  |1079        |                  |
|----------|-------|------|---------|------------|------------------|

2020-11-25 10:11:25.993 INFO  jdbc.sqltiming Line:373 - update node_revision__field_thumb set bundle='book', delta=0, langcode='zh-hans', revision_id=1079, 
field_thumb_value='https://static001.geekbang.org/resource/image/c5/27/c5c943d776b2b72eb123de19e57c0827.jpg' 
where entity_id=1079 
 {executed in 0 msec}
2020-11-25 10:11:25.996 INFO  jdbc.sqltiming Line:373 - select bookfieldf0_.entity_id as entity_i1_6_0_, bookfieldf0_.bundle as bundle2_6_0_, bookfieldf0_.delta 
as delta3_6_0_, bookfieldf0_.field_fenlei_target_id as field_fe4_6_0_, bookfieldf0_.langcode 
as langcode5_6_0_, bookfieldf0_.revision_id as revision6_6_0_ from node__field_fenlei bookfieldf0_ 
where bookfieldf0_.entity_id=1079 
 {executed in 0 msec}
2020-11-25 10:11:25.996 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|-----------------------|---------|------------|
|entity_id |bundle |delta |field_fenlei_target_id |langcode |revision_id |
|----------|-------|------|-----------------------|---------|------------|
|[unread]  |book   |0     |1                      |zh-hans  |1079        |
|----------|-------|------|-----------------------|---------|------------|

2020-11-25 10:11:25.998 INFO  jdbc.sqltiming Line:373 - select nodefieldf0_.entity_id as entity_i1_15_0_, nodefieldf0_.bundle as bundle2_15_0_, nodefieldf0_.delta 
as delta3_15_0_, nodefieldf0_.field_fenlei_target_id as field_fe4_15_0_, nodefieldf0_.langcode 
as langcode5_15_0_, nodefieldf0_.revision_id as revision6_15_0_ from node_revision__field_fenlei 
nodefieldf0_ where nodefieldf0_.entity_id=1079 
 {executed in 0 msec}
2020-11-25 10:11:25.998 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|-----------------------|---------|------------|
|entity_id |bundle |delta |field_fenlei_target_id |langcode |revision_id |
|----------|-------|------|-----------------------|---------|------------|
|[unread]  |book   |0     |1                      |zh-hans  |1079        |
|----------|-------|------|-----------------------|---------|------------|

2020-11-25 10:11:26.000 INFO  jdbc.sqltiming Line:373 - select bookchecke0_.item_id as item_id1_2_, bookchecke0_.fsid as fsid2_2_, bookchecke0_.got 
as got3_2_, bookchecke0_.name as name4_2_, bookchecke0_.parse_fail as parse_fa5_2_, bookchecke0_.parsed 
as parsed6_2_, bookchecke0_.path as path7_2_, bookchecke0_.title as title8_2_, bookchecke0_.vid 
as vid9_2_ from book_check bookchecke0_ where bookchecke0_.fsid='163098618968533' and bookchecke0_.name='net_content' 
 {executed in 0 msec}
2020-11-25 10:11:26.001 INFO  jdbc.resultsettable Line:610 - 
|--------|---------|---------|---------|-----------|---------|---------|---------|---------|
|item_id |fsid     |got      |name     |parse_fail |parsed   |path     |title    |vid      |
|--------|---------|---------|---------|-----------|---------|---------|---------|---------|
|1080    |[unread] |[unread] |[unread] |[unread]   |[unread] |[unread] |[unread] |[unread] |
|--------|---------|---------|---------|-----------|---------|---------|---------|---------|

2020-11-25 10:12:48.313 INFO  jdbc.sqltiming Line:373 - update book_check set fsid='163098618968533', got=1, name='net_content', parse_fail='', parsed=1, 
path='12-Linux性能优化实战/06-综合实战篇 (13讲)/47丨案例篇：服务器总是时不时丢包，我该怎么办？（上）.html', title='47丨案例篇：服务器总是时不时丢包，我该怎么办？（上）', 
vid=1080 where item_id=1080 
 {executed in 0 msec}
2020-11-25 10:12:48.321 INFO  jdbc.sqltiming Line:373 - select nodebodyen0_.entity_id as entity_i1_4_, nodebodyen0_.body_value as body_val2_4_, nodebodyen0_.body_summary 
as body_sum3_4_, nodebodyen0_.bundle as bundle4_4_, nodebodyen0_.delta as delta5_4_, nodebodyen0_.body_format 
as body_for6_4_, nodebodyen0_.langcode as langcode7_4_, nodebodyen0_.revision_id as revision8_4_ 
from node__body nodebodyen0_ where nodebodyen0_.entity_id=1080 
 {executed in 0 msec}
2020-11-25 10:12:48.321 INFO  jdbc.resultsettable Line:610 - 
|----------|-----------|-------------|-------|------|------------|---------|------------|
|entity_id |body_value |body_summary |bundle |delta |body_format |langcode |revision_id |
|----------|-----------|-------------|-------|------|------------|---------|------------|
|1080      |           |             |book   |0     |full_html   |zh-hans  |1080        |
|----------|-----------|-------------|-------|------|------------|---------|------------|

2020-11-25 10:12:48.322 INFO  jdbc.sqltiming Line:373 - select nodebodyre0_.entity_id as entity_i1_13_0_, nodebodyre0_.body_value as body_val2_13_0_, 
nodebodyre0_.body_summary as body_sum3_13_0_, nodebodyre0_.bundle as bundle4_13_0_, nodebodyre0_.delta 
as delta5_13_0_, nodebodyre0_.body_format as body_for6_13_0_, nodebodyre0_.langcode as langcode7_13_0_, 
nodebodyre0_.revision_id as revision8_13_0_ from node_revision__body nodebodyre0_ where nodebodyre0_.entity_id=1080 
 {executed in 0 msec}
2020-11-25 10:12:48.323 INFO  jdbc.resultsettable Line:610 - 
|----------|-----------|-------------|-------|------|------------|---------|------------|
|entity_id |body_value |body_summary |bundle |delta |body_format |langcode |revision_id |
|----------|-----------|-------------|-------|------|------------|---------|------------|
|[unread]  |           |             |book   |0     |full_html   |zh-hans  |1080        |
|----------|-----------|-------------|-------|------|------------|---------|------------|

2020-11-25 10:12:48.326 INFO  jdbc.sqltiming Line:373 - update node__body set body_value='<p>你好，我是倪朋飞。</p> <p>上一节，我们梳理了，应用程序容器化后性能下降的分析方法。一起先简单回顾下。</p> 
<p>容器利用 Linux 内核提供的命名空间技术，将不同应用程序的运行隔离起来，并用统一的镜像，来管理应用程序的依赖环境。这为应用程序的管理和维护，带来了极大的便捷性，并进一步催生了微服务、云原生等新一代技术架构。</p> 
<p>不过，虽说有很多优势，但容器化也会对应用程序的性能带来一定影响。比如，上一节我们一起分析的 Java 应用，就容易发生启动过慢、运行一段时间后 OOM 退出等问题。当你碰到这种问题时，不要慌，我们前面四大基础模块中的各种思路，都依然适用。</p> 
<p>实际上，我们专栏中的很多案例都在容器中运行。容器化后，应用程序会通过命名空间进行隔离。所以，你在分析时，不要忘了结合命名空间、cgroups、iptables 等来综合分析。比如：</p> 
<ul> <li> <p>cgroups 会影响容器应用的运行；</p> </li> <li> <p>iptables 中的 NAT，会影响容器的网络性能；</p> </li> <li> 
<p>叠加文件系统，会影响应用的 I/O 性能等。</p> </li> </ul> <p>关于 NAT 的影响，我在网络模块的 <a href="https://time.geekbang.org/column/article/83189">如何优化 
NAT 性能</a> 文章中，已经为你介绍了很多优化思路。今天，我们一起来看另一种情况，也就是丢包的分析方法。</p> <p>所谓丢包，是指在网络数据的收发过程中，由于种种原因，数据包还没传输到应用程序中，就被丢弃了。这些被丢弃包的数量，除以总的传输包数，也就是我们常说的<strong>丢包率</strong>。丢包率是网络性能中最核心的指标之一。</p><!-- 
[[[read_end]]] --> <p>丢包通常会带来严重的性能下降，特别是对 TCP 来说，丢包通常意味着网络拥塞和重传，进而还会导致网络延迟增大、吞吐降低。</p> <p>接下来，我就以最常用的反向代理服务器 
Nginx 为例，带你一起看看，如何分析网络丢包的问题。由于内容比较多，这个案例将分为上下两篇来讲解，今天我们先看第一部分内容。</p> <h2>案例准备</h2> <p>今天的案例需要用到两台虚拟机，还是基于 
Ubuntu 18.04，同样适用于其他的 Linux 系统。我使用的案例环境如下所示：</p> <ul> <li> <p>机器配置：2 CPU，8GB 内存。</p> </li> 
<li> <p>预先安装 docker、curl、hping3 等工具，如 apt install docker.io curl hping3。</p> </li> </ul> <p>这些工具，我们在前面的案例中已经多次使用，这里就不再重复介绍。</p> 
<p>现在，打开两个终端，分别登录到这两台虚拟机中，并安装上述工具。</p> <p>注意，以下所有命令都默认以 root 用户运行，如果你用普通用户身份登陆系统，请运行 sudo su 
root 命令，切换到 root 用户。</p> <blockquote> <p>如果安装过程有问题，你可以先上网搜索解决，实在解决不了的，记得在留言区向我提问。</p> </blockquote> 
<p>到这里，准备工作就完成了。接下来，我们正式进入操作环节。</p> <h2>案例分析</h2> <p>我们今天要分析的案例是一个 Nginx 应用，如下图所示，hping3 和 
curl 是 Nginx 的客户端。</p> <p><img src="https://static001.geekbang.org/resource/image/7d/1b/7d8cb9a2ce1c3bad4d74f46a632f671b.png" 
alt=""></p> <p>为了方便你运行，我已经把它打包成了一个 Docker 镜像，并推送到 Docker Hub 中。你可以直接按照下面的步骤来运行它。</p> <p>在终端一中执行下面的命令，启动 
Nginx 应用，并在 80 端口监听。如果一切正常，你应该可以看到如下的输出：</p> <pre style="position: relative;"><code> <table 
class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> $ docker 
run --name nginx --hostname nginx --privileged -p 80:80 -itd feisky/nginx:drop </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> dae0202cc27e5082b282a6aeeb1398fcec423c642e63322da2a97b9ebd7538e0 
</div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>然后，执行 docker ps 命令，查询容器的状态，你会发现容器已经处于运行状态（Up）了：</p> <pre style="position: relative;"><code> 
<table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
$ docker ps </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> CONTAINER 
ID IMAGE COMMAND CREATED STATUS PORTS NAMES </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> dae0202cc27e feisky/nginx:drop "/start.sh" 4 minutes ago Up 4 minutes 
0.0.0.0:80-&gt;80/tcp nginx </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <p>不过，从 docker ps 的输出，我们只能知道容器处于运行状态，至于 Nginx 
是否可以正常处理外部请求，还需要进一步的确认。</p> <p>接着，我们切换到终端二中，执行下面的 hping3 命令，进一步验证 Nginx 是不是真的可以正常访问了。注意，这里我没有使用 
ping，是因为 ping 基于 ICMP 协议，而 Nginx 使用的是 TCP 协议。</p> <pre style="position: relative;"><code> <table 
class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> # -c 
表示发送 10 个请求，-S 表示使用 TCP SYN，-p 指定端口为 80 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> $ hping3 -c 10 -S -p 80 192.168.0.30 </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> HPING 192.168.0.30 (eth0 192.168.0.30): 
S set, 40 headers + 0 data bytes </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
len=44 ip=192.168.0.30 ttl=63 DF id=0 sport=80 flags=SA seq=3 win=5120 rtt=7.5 ms </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> len=44 ip=192.168.0.30 ttl=63 DF id=0 
sport=80 flags=SA seq=4 win=5120 rtt=7.4 ms </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> len=44 ip=192.168.0.30 ttl=63 DF id=0 sport=80 flags=SA seq=5 win=5120 
rtt=3.3 ms </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="7"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> len=44 
ip=192.168.0.30 ttl=63 DF id=0 sport=80 flags=SA seq=7 win=5120 rtt=3.0 ms </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> len=44 ip=192.168.0.30 ttl=63 DF id=0 
sport=80 flags=SA seq=6 win=5120 rtt=3027.2 ms </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="10"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
--- 192.168.0.30 hping statistic --- </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 10 packets transmitted, 5 packets received, 50% packet loss </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> round-trip min/avg/max = 3.0/609.7/3027.2 
ms </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>从 hping3 的输出中，我们可以发现，发送了 10 个请求包，却只收到了 5 个回复，50% 的包都丢了。再观察每个请求的 RTT 可以发现，RTT 
也有非常大的波动变化，小的时候只有 3ms，而大的时候则有 3s。</p> <p>根据这些输出，我们基本能判断，已经发生了丢包现象。可以猜测，3s 的 RTT ，很可能是因为丢包后重传导致的。那到底是哪里发生了丢包呢？</p> 
<p>排查之前，我们可以回忆一下 Linux 的网络收发流程，先从理论上分析，哪里有可能会发生丢包。你不妨拿出手边的笔和纸，边回忆边在纸上梳理，思考清楚再继续下面的内容。</p> <p>在这里，为了帮你理解网络丢包的原理，我画了一张图，你可以保存并打印出来使用：</p> 
<p><img src="https://static001.geekbang.org/resource/image/dd/fd/dd5b4050d555b1c23362456e357dfffd.png" 
alt=""></p> <p>从图中你可以看出，可能发生丢包的位置，实际上贯穿了整个网络协议栈。换句话说，全程都有丢包的可能。比如我们从下往上看：</p> <ul> <li> <p>在两台 
VM 连接之间，可能会发生传输失败的错误，比如网络拥塞、线路错误等；</p> </li> <li> <p>在网卡收包后，环形缓冲区可能会因为溢出而丢包；</p> </li> <li> 
<p>在链路层，可能会因为网络帧校验失败、QoS 等而丢包；</p> </li> <li> <p>在 IP 层，可能会因为路由失败、组包大小超过 MTU 等而丢包；</p> </li> 
<li> <p>在传输层，可能会因为端口未监听、资源占用超过内核限制等而丢包；</p> </li> <li> <p>在套接字层，可能会因为套接字缓冲区溢出而丢包；</p> </li> 
<li> <p>在应用层，可能会因为应用程序异常而丢包；</p> </li> <li> <p>此外，如果配置了 iptables 规则，这些网络包也可能因为 iptables 过滤规则而丢包。</p> 
</li> </ul> <p>当然，上面这些问题，还有可能同时发生在通信的两台机器中。不过，由于我们没对 VM2 做任何修改，并且 VM2 也只运行了一个最简单的 hping3 命令，这儿不妨假设它是没有问题的。</p> 
<p>为了简化整个排查过程，我们还可以进一步假设， VM1 的网络和内核配置也没问题。这样一来，有可能发生问题的位置，就都在容器内部了。</p> <p>现在我们切换回终端一，执行下面的命令，进入容器的终端中：</p> 
<pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> $ docker exec -it nginx bash </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> root@nginx:/# </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <p>在这里简单说明一下，接下来的所有分析，前面带有 <em>root@nginx:/#</em> 
的操作，都表示在容器中进行。</p> <blockquote> <p>注意：实际环境中，容器内部和外部都有可能发生问题。不过不要担心，容器内、外部的分析步骤和思路都是一样的，只不过要花更多的时间而已。</p> 
</blockquote> <p>那么， 接下来，我们就可以从协议栈中，逐层排查丢包问题。</p> <h3>链路层</h3> <p>首先，来看最底下的链路层。当缓冲区溢出等原因导致网卡丢包时，Linux 
会在网卡收发数据的统计信息中，记录下收发错误的次数。</p> <p>你可以通过 ethtool 或者 netstat ，来查看网卡的丢包记录。比如，可以在容器中执行下面的命令，查看丢包情况：</p> 
<pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> root@nginx:/# netstat -i </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> Kernel Interface table </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> Iface MTU RX-OK RX-ERR RX-DRP RX-OVR TX-OK TX-ERR TX-DRP TX-OVR 
Flg </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="4"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> eth0 
100 31 0 0 0 8 0 0 0 BMRU </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="5"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
lo 65536 0 0 0 0 0 0 0 0 LRU </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <p>输出中的 RX-OK、RX-ERR、RX-DRP、RX-OVR ，分别表示接收时的总包数、总错误数、进入 
Ring Buffer 后因其他原因（如内存不足）导致的丢包数以及 Ring Buffer 溢出导致的丢包数。</p> <p>TX-OK、TX-ERR、TX-DRP、TX-OVR 也代表类似的含义，只不过是指发送时对应的各个指标。</p> 
<blockquote> <p>注意，由于 Docker 容器的虚拟网卡，实际上是一对 veth pair，一端接入容器中用作 eth0，另一端在主机中接入 docker0 网桥中。veth 
驱动并没有实现网络统计的功能，所以使用 ethtool -S 命令，无法得到网卡收发数据的汇总信息。</p> </blockquote> <p>从这个输出中，我们没有发现任何错误，说明容器的虚拟网卡没有丢包。不过要注意，如果用 
tc 等工具配置了 QoS，那么 tc 规则导致的丢包，就不会包含在网卡的统计信息中。</p> <p>所以接下来，我们还要检查一下 eth0 上是否配置了 tc 规则，并查看有没有丢包。我们继续容器终端中，执行下面的 
tc 命令，不过这次注意添加 -s 选项，以输出统计信息：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> 
<tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> root@nginx:/# tc -s qdisc show dev eth0 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> qdisc netem 800d: root refcnt 2 limit 
1000 loss 30% </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
Sent 432 bytes 8 pkt (dropped 4, overlimits 0 requeues 0) </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> backlog 0b 0p requeues 0 </div></td> </tr> </tbody> </table></code> 
<div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 </div></pre> <p>从 tc 
的输出中可以看到， eth0 上面配置了一个网络模拟排队规则（qdisc netem），并且配置了丢包率为 30%（loss 30%）。再看后面的统计信息，发送了 8 个包，但是丢了 
4 个。</p> <p>看来，应该就是这里，导致 Nginx 回复的响应包，被 netem 模块给丢了。</p> <p>既然发现了问题，解决方法也就很简单了，直接删掉 netem 模块就可以了。我们可以继续在容器终端中，执行下面的命令，删除 
tc 中的 netem 模块：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> root@nginx:/# tc qdisc del dev eth0 root 
netem loss 30% </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <p>删除后，问题到底解决了没？我们切换到终端二中，重新执行刚才的 hping3 命令，看看现在还有没有问题：</p> 
<pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> $ hping3 -c 10 -S -p 80 192.168.0.30 </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> HPING 192.168.0.30 (eth0 192.168.0.30): 
S set, 40 headers + 0 data bytes </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
len=44 ip=192.168.0.30 ttl=63 DF id=0 sport=80 flags=SA seq=0 win=5120 rtt=7.9 ms </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> len=44 ip=192.168.0.30 ttl=63 DF id=0 
sport=80 flags=SA seq=2 win=5120 rtt=1003.8 ms </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> len=44 ip=192.168.0.30 ttl=63 DF id=0 sport=80 flags=SA seq=5 win=5120 
rtt=7.6 ms </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="6"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> len=44 
ip=192.168.0.30 ttl=63 DF id=0 sport=80 flags=SA seq=6 win=5120 rtt=7.4 ms </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> len=44 ip=192.168.0.30 ttl=63 DF id=0 
sport=80 flags=SA seq=9 win=5120 rtt=3.0 ms </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="9"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
--- 192.168.0.30 hping statistic --- </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 10 packets transmitted, 5 packets received, 50% packet loss </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> round-trip min/avg/max = 3.0/205.9/1003.8 
ms </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>不幸的是，从 hping3 的输出中，我们可以看到，跟前面现象一样，还是 50% 的丢包；RTT 的波动也仍旧很大，从 3ms 到 1s。</p> <p>显然，问题还是没解决，丢包还在继续发生。不过，既然链路层已经排查完了，我们就继续向上层分析，看看网络层和传输层有没有问题。</p> 
<h3>网络层和传输层</h3> <p>我们知道，在网络层和传输层中，引发丢包的因素非常多。不过，其实想确认是否丢包，是非常简单的事，因为 Linux 已经为我们提供了各个协议的收发汇总情况。</p> 
<p>我们继续在容器终端中，执行下面的 netstat -s 命令，就可以看到协议的收发汇总，以及错误信息了：</p> <pre style="position: relative;"><code> 
<table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
root@nginx:/# netstat -s </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
Ip: </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="3"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> Forwarding: 
1 // 开启转发 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="4"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 31 total 
packets received // 总收包数 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="5"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
0 forwarded // 转发包数 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="6"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
0 incoming packets discarded // 接收丢包数 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></td> <td class="hljs-ln-code"> <div 
class="hljs-ln-line"> 25 incoming packets delivered // 接收的数据包数 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 15 requests sent out // 发出的数据包数 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> Icmp: </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="10"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
0 ICMP messages received // 收到的 ICMP 包数 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 0 input ICMP message failed // 收到 ICMP 失败数 </div></td> </tr> <tr> 
<td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> ICMP input histogram: </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="13"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 0 ICMP messages sent //ICMP 发送数 </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="14"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 0 ICMP messages failed //ICMP 失败数 </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="15"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> ICMP output histogram: </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="16"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> Tcp: </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="17"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 0 active connection openings // 主动连接数 </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="18"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 0 passive connection openings // 被动连接数 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="19"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 11 failed connection attempts // 失败连接尝试数 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="20"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 0 connection resets received // 接收的连接重置数 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="21"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 0 connections established // 建立连接数 </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="22"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 25 segments received // 已接收报文数 </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="23"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 21 segments sent out // 已发送报文数 </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="24"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 4 segments retransmitted // 重传报文数 </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="25"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 0 bad segments received // 错误报文数 </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="26"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 0 resets sent // 发出的连接重置数 </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="27"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> Udp: </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="28"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 0 packets received </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="29"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> ... </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="30"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
TcpExt: </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="31"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 11 resets 
received for embryonic SYN_RECV sockets // 半连接重置数 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="32"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 0 packet headers predicted </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="33"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> TCPTimeouts: 7 // 超时数 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="34"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> TCPSynRetrans: 4 //SYN 重传数 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="35"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> ... </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <p>netstat 汇总了 IP、ICMP、TCP、UDP 等各种协议的收发统计信息。不过，我们的目的是排查丢包问题，所以这里主要观察的是错误数、丢包数以及重传数。</p> 
<p>根据上面的输出，你可以看到，只有 TCP 协议发生了丢包和重传，分别是：</p> <ul> <li> <p>11 次连接失败重试（11 failed connection attempts）</p> 
</li> <li> <p>4 次重传（4 segments retransmitted）</p> </li> <li> <p>11 次半连接重置（11 resets received 
for embryonic SYN_RECV sockets）</p> </li> <li> <p>4 次 SYN 重传（TCPSynRetrans）</p> </li> <li> 
<p>7 次超时（TCPTimeouts）</p> </li> </ul> <p>这个结果告诉我们，TCP 协议有多次超时和失败重试，并且主要错误是半连接重置。换句话说，主要的失败，都是三次握手失败。</p> 
<p>不过，虽然在这儿看到了这么多失败，但具体失败的根源还是无法确定。所以，我们还需要继续顺着协议栈来分析。接下来的几层又该如何分析呢？你不妨自己先来思考操作一下，下一节我们继续来一起探讨。</p> 
<h2>小结</h2> <p>网络丢包，通常会带来严重的性能下降，特别是对 TCP 来说，丢包通常意味着网络拥塞和重传，进一步还会导致网络延迟增大、吞吐降低。</p> <p>今天的这个案例，我们学会了如何从链路层、网络层和传输层等入手，分析网络丢包的问题。不过，案例最后，我们还没有找出最终的性能瓶颈，下一节，我将继续为你讲解。</p> 
<h2>思考</h2> <p>最后，给你留一个思考题，也是案例最后提到的问题。</p> <p>今天我们只分析了链路层、网络层以及传输层等。而根据 TCP/IP 协议栈和 Linux 
网络收发原理，还有很多我们没分析到的地方。那么，接下来，我们又该如何分析，才能破获这个案例，找出“真凶”呢？</p> <p>欢迎在留言区和我讨论，也欢迎把这篇文章分享给你的同事、朋友。我们一起在实战中演练，在交流中进步。</p> 
<p><img src="https://static001.geekbang.org/resource/image/a3/e9/a396aed4116c2c989771c1295736abe9.jpg" 
alt=""></p>', body_summary='', bundle='book', delta=0, body_format='full_html', langcode='zh-hans', 
revision_id=1080 where entity_id=1080 
 {executed in 0 msec}
2020-11-25 10:12:48.328 INFO  jdbc.sqltiming Line:373 - update node_revision__body set body_value='<p>你好，我是倪朋飞。</p> <p>上一节，我们梳理了，应用程序容器化后性能下降的分析方法。一起先简单回顾下。</p> 
<p>容器利用 Linux 内核提供的命名空间技术，将不同应用程序的运行隔离起来，并用统一的镜像，来管理应用程序的依赖环境。这为应用程序的管理和维护，带来了极大的便捷性，并进一步催生了微服务、云原生等新一代技术架构。</p> 
<p>不过，虽说有很多优势，但容器化也会对应用程序的性能带来一定影响。比如，上一节我们一起分析的 Java 应用，就容易发生启动过慢、运行一段时间后 OOM 退出等问题。当你碰到这种问题时，不要慌，我们前面四大基础模块中的各种思路，都依然适用。</p> 
<p>实际上，我们专栏中的很多案例都在容器中运行。容器化后，应用程序会通过命名空间进行隔离。所以，你在分析时，不要忘了结合命名空间、cgroups、iptables 等来综合分析。比如：</p> 
<ul> <li> <p>cgroups 会影响容器应用的运行；</p> </li> <li> <p>iptables 中的 NAT，会影响容器的网络性能；</p> </li> <li> 
<p>叠加文件系统，会影响应用的 I/O 性能等。</p> </li> </ul> <p>关于 NAT 的影响，我在网络模块的 <a href="https://time.geekbang.org/column/article/83189">如何优化 
NAT 性能</a> 文章中，已经为你介绍了很多优化思路。今天，我们一起来看另一种情况，也就是丢包的分析方法。</p> <p>所谓丢包，是指在网络数据的收发过程中，由于种种原因，数据包还没传输到应用程序中，就被丢弃了。这些被丢弃包的数量，除以总的传输包数，也就是我们常说的<strong>丢包率</strong>。丢包率是网络性能中最核心的指标之一。</p><!-- 
[[[read_end]]] --> <p>丢包通常会带来严重的性能下降，特别是对 TCP 来说，丢包通常意味着网络拥塞和重传，进而还会导致网络延迟增大、吞吐降低。</p> <p>接下来，我就以最常用的反向代理服务器 
Nginx 为例，带你一起看看，如何分析网络丢包的问题。由于内容比较多，这个案例将分为上下两篇来讲解，今天我们先看第一部分内容。</p> <h2>案例准备</h2> <p>今天的案例需要用到两台虚拟机，还是基于 
Ubuntu 18.04，同样适用于其他的 Linux 系统。我使用的案例环境如下所示：</p> <ul> <li> <p>机器配置：2 CPU，8GB 内存。</p> </li> 
<li> <p>预先安装 docker、curl、hping3 等工具，如 apt install docker.io curl hping3。</p> </li> </ul> <p>这些工具，我们在前面的案例中已经多次使用，这里就不再重复介绍。</p> 
<p>现在，打开两个终端，分别登录到这两台虚拟机中，并安装上述工具。</p> <p>注意，以下所有命令都默认以 root 用户运行，如果你用普通用户身份登陆系统，请运行 sudo su 
root 命令，切换到 root 用户。</p> <blockquote> <p>如果安装过程有问题，你可以先上网搜索解决，实在解决不了的，记得在留言区向我提问。</p> </blockquote> 
<p>到这里，准备工作就完成了。接下来，我们正式进入操作环节。</p> <h2>案例分析</h2> <p>我们今天要分析的案例是一个 Nginx 应用，如下图所示，hping3 和 
curl 是 Nginx 的客户端。</p> <p><img src="https://static001.geekbang.org/resource/image/7d/1b/7d8cb9a2ce1c3bad4d74f46a632f671b.png" 
alt=""></p> <p>为了方便你运行，我已经把它打包成了一个 Docker 镜像，并推送到 Docker Hub 中。你可以直接按照下面的步骤来运行它。</p> <p>在终端一中执行下面的命令，启动 
Nginx 应用，并在 80 端口监听。如果一切正常，你应该可以看到如下的输出：</p> <pre style="position: relative;"><code> <table 
class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> $ docker 
run --name nginx --hostname nginx --privileged -p 80:80 -itd feisky/nginx:drop </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> dae0202cc27e5082b282a6aeeb1398fcec423c642e63322da2a97b9ebd7538e0 
</div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>然后，执行 docker ps 命令，查询容器的状态，你会发现容器已经处于运行状态（Up）了：</p> <pre style="position: relative;"><code> 
<table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
$ docker ps </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> CONTAINER 
ID IMAGE COMMAND CREATED STATUS PORTS NAMES </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> dae0202cc27e feisky/nginx:drop "/start.sh" 4 minutes ago Up 4 minutes 
0.0.0.0:80-&gt;80/tcp nginx </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <p>不过，从 docker ps 的输出，我们只能知道容器处于运行状态，至于 Nginx 
是否可以正常处理外部请求，还需要进一步的确认。</p> <p>接着，我们切换到终端二中，执行下面的 hping3 命令，进一步验证 Nginx 是不是真的可以正常访问了。注意，这里我没有使用 
ping，是因为 ping 基于 ICMP 协议，而 Nginx 使用的是 TCP 协议。</p> <pre style="position: relative;"><code> <table 
class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> # -c 
表示发送 10 个请求，-S 表示使用 TCP SYN，-p 指定端口为 80 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> $ hping3 -c 10 -S -p 80 192.168.0.30 </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> HPING 192.168.0.30 (eth0 192.168.0.30): 
S set, 40 headers + 0 data bytes </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
len=44 ip=192.168.0.30 ttl=63 DF id=0 sport=80 flags=SA seq=3 win=5120 rtt=7.5 ms </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> len=44 ip=192.168.0.30 ttl=63 DF id=0 
sport=80 flags=SA seq=4 win=5120 rtt=7.4 ms </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> len=44 ip=192.168.0.30 ttl=63 DF id=0 sport=80 flags=SA seq=5 win=5120 
rtt=3.3 ms </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="7"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> len=44 
ip=192.168.0.30 ttl=63 DF id=0 sport=80 flags=SA seq=7 win=5120 rtt=3.0 ms </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> len=44 ip=192.168.0.30 ttl=63 DF id=0 
sport=80 flags=SA seq=6 win=5120 rtt=3027.2 ms </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="10"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
--- 192.168.0.30 hping statistic --- </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 10 packets transmitted, 5 packets received, 50% packet loss </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> round-trip min/avg/max = 3.0/609.7/3027.2 
ms </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>从 hping3 的输出中，我们可以发现，发送了 10 个请求包，却只收到了 5 个回复，50% 的包都丢了。再观察每个请求的 RTT 可以发现，RTT 
也有非常大的波动变化，小的时候只有 3ms，而大的时候则有 3s。</p> <p>根据这些输出，我们基本能判断，已经发生了丢包现象。可以猜测，3s 的 RTT ，很可能是因为丢包后重传导致的。那到底是哪里发生了丢包呢？</p> 
<p>排查之前，我们可以回忆一下 Linux 的网络收发流程，先从理论上分析，哪里有可能会发生丢包。你不妨拿出手边的笔和纸，边回忆边在纸上梳理，思考清楚再继续下面的内容。</p> <p>在这里，为了帮你理解网络丢包的原理，我画了一张图，你可以保存并打印出来使用：</p> 
<p><img src="https://static001.geekbang.org/resource/image/dd/fd/dd5b4050d555b1c23362456e357dfffd.png" 
alt=""></p> <p>从图中你可以看出，可能发生丢包的位置，实际上贯穿了整个网络协议栈。换句话说，全程都有丢包的可能。比如我们从下往上看：</p> <ul> <li> <p>在两台 
VM 连接之间，可能会发生传输失败的错误，比如网络拥塞、线路错误等；</p> </li> <li> <p>在网卡收包后，环形缓冲区可能会因为溢出而丢包；</p> </li> <li> 
<p>在链路层，可能会因为网络帧校验失败、QoS 等而丢包；</p> </li> <li> <p>在 IP 层，可能会因为路由失败、组包大小超过 MTU 等而丢包；</p> </li> 
<li> <p>在传输层，可能会因为端口未监听、资源占用超过内核限制等而丢包；</p> </li> <li> <p>在套接字层，可能会因为套接字缓冲区溢出而丢包；</p> </li> 
<li> <p>在应用层，可能会因为应用程序异常而丢包；</p> </li> <li> <p>此外，如果配置了 iptables 规则，这些网络包也可能因为 iptables 过滤规则而丢包。</p> 
</li> </ul> <p>当然，上面这些问题，还有可能同时发生在通信的两台机器中。不过，由于我们没对 VM2 做任何修改，并且 VM2 也只运行了一个最简单的 hping3 命令，这儿不妨假设它是没有问题的。</p> 
<p>为了简化整个排查过程，我们还可以进一步假设， VM1 的网络和内核配置也没问题。这样一来，有可能发生问题的位置，就都在容器内部了。</p> <p>现在我们切换回终端一，执行下面的命令，进入容器的终端中：</p> 
<pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> $ docker exec -it nginx bash </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> root@nginx:/# </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <p>在这里简单说明一下，接下来的所有分析，前面带有 <em>root@nginx:/#</em> 
的操作，都表示在容器中进行。</p> <blockquote> <p>注意：实际环境中，容器内部和外部都有可能发生问题。不过不要担心，容器内、外部的分析步骤和思路都是一样的，只不过要花更多的时间而已。</p> 
</blockquote> <p>那么， 接下来，我们就可以从协议栈中，逐层排查丢包问题。</p> <h3>链路层</h3> <p>首先，来看最底下的链路层。当缓冲区溢出等原因导致网卡丢包时，Linux 
会在网卡收发数据的统计信息中，记录下收发错误的次数。</p> <p>你可以通过 ethtool 或者 netstat ，来查看网卡的丢包记录。比如，可以在容器中执行下面的命令，查看丢包情况：</p> 
<pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> root@nginx:/# netstat -i </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> Kernel Interface table </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> Iface MTU RX-OK RX-ERR RX-DRP RX-OVR TX-OK TX-ERR TX-DRP TX-OVR 
Flg </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="4"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> eth0 
100 31 0 0 0 8 0 0 0 BMRU </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="5"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
lo 65536 0 0 0 0 0 0 0 0 LRU </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <p>输出中的 RX-OK、RX-ERR、RX-DRP、RX-OVR ，分别表示接收时的总包数、总错误数、进入 
Ring Buffer 后因其他原因（如内存不足）导致的丢包数以及 Ring Buffer 溢出导致的丢包数。</p> <p>TX-OK、TX-ERR、TX-DRP、TX-OVR 也代表类似的含义，只不过是指发送时对应的各个指标。</p> 
<blockquote> <p>注意，由于 Docker 容器的虚拟网卡，实际上是一对 veth pair，一端接入容器中用作 eth0，另一端在主机中接入 docker0 网桥中。veth 
驱动并没有实现网络统计的功能，所以使用 ethtool -S 命令，无法得到网卡收发数据的汇总信息。</p> </blockquote> <p>从这个输出中，我们没有发现任何错误，说明容器的虚拟网卡没有丢包。不过要注意，如果用 
tc 等工具配置了 QoS，那么 tc 规则导致的丢包，就不会包含在网卡的统计信息中。</p> <p>所以接下来，我们还要检查一下 eth0 上是否配置了 tc 规则，并查看有没有丢包。我们继续容器终端中，执行下面的 
tc 命令，不过这次注意添加 -s 选项，以输出统计信息：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> 
<tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> root@nginx:/# tc -s qdisc show dev eth0 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> qdisc netem 800d: root refcnt 2 limit 
1000 loss 30% </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
Sent 432 bytes 8 pkt (dropped 4, overlimits 0 requeues 0) </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> backlog 0b 0p requeues 0 </div></td> </tr> </tbody> </table></code> 
<div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 </div></pre> <p>从 tc 
的输出中可以看到， eth0 上面配置了一个网络模拟排队规则（qdisc netem），并且配置了丢包率为 30%（loss 30%）。再看后面的统计信息，发送了 8 个包，但是丢了 
4 个。</p> <p>看来，应该就是这里，导致 Nginx 回复的响应包，被 netem 模块给丢了。</p> <p>既然发现了问题，解决方法也就很简单了，直接删掉 netem 模块就可以了。我们可以继续在容器终端中，执行下面的命令，删除 
tc 中的 netem 模块：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> root@nginx:/# tc qdisc del dev eth0 root 
netem loss 30% </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <p>删除后，问题到底解决了没？我们切换到终端二中，重新执行刚才的 hping3 命令，看看现在还有没有问题：</p> 
<pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> $ hping3 -c 10 -S -p 80 192.168.0.30 </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> HPING 192.168.0.30 (eth0 192.168.0.30): 
S set, 40 headers + 0 data bytes </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
len=44 ip=192.168.0.30 ttl=63 DF id=0 sport=80 flags=SA seq=0 win=5120 rtt=7.9 ms </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> len=44 ip=192.168.0.30 ttl=63 DF id=0 
sport=80 flags=SA seq=2 win=5120 rtt=1003.8 ms </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> len=44 ip=192.168.0.30 ttl=63 DF id=0 sport=80 flags=SA seq=5 win=5120 
rtt=7.6 ms </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="6"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> len=44 
ip=192.168.0.30 ttl=63 DF id=0 sport=80 flags=SA seq=6 win=5120 rtt=7.4 ms </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> len=44 ip=192.168.0.30 ttl=63 DF id=0 
sport=80 flags=SA seq=9 win=5120 rtt=3.0 ms </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="9"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
--- 192.168.0.30 hping statistic --- </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 10 packets transmitted, 5 packets received, 50% packet loss </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> round-trip min/avg/max = 3.0/205.9/1003.8 
ms </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>不幸的是，从 hping3 的输出中，我们可以看到，跟前面现象一样，还是 50% 的丢包；RTT 的波动也仍旧很大，从 3ms 到 1s。</p> <p>显然，问题还是没解决，丢包还在继续发生。不过，既然链路层已经排查完了，我们就继续向上层分析，看看网络层和传输层有没有问题。</p> 
<h3>网络层和传输层</h3> <p>我们知道，在网络层和传输层中，引发丢包的因素非常多。不过，其实想确认是否丢包，是非常简单的事，因为 Linux 已经为我们提供了各个协议的收发汇总情况。</p> 
<p>我们继续在容器终端中，执行下面的 netstat -s 命令，就可以看到协议的收发汇总，以及错误信息了：</p> <pre style="position: relative;"><code> 
<table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
root@nginx:/# netstat -s </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
Ip: </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="3"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> Forwarding: 
1 // 开启转发 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="4"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 31 total 
packets received // 总收包数 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="5"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
0 forwarded // 转发包数 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="6"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
0 incoming packets discarded // 接收丢包数 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></td> <td class="hljs-ln-code"> <div 
class="hljs-ln-line"> 25 incoming packets delivered // 接收的数据包数 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 15 requests sent out // 发出的数据包数 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> Icmp: </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="10"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
0 ICMP messages received // 收到的 ICMP 包数 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 0 input ICMP message failed // 收到 ICMP 失败数 </div></td> </tr> <tr> 
<td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> ICMP input histogram: </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="13"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 0 ICMP messages sent //ICMP 发送数 </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="14"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 0 ICMP messages failed //ICMP 失败数 </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="15"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> ICMP output histogram: </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="16"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> Tcp: </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="17"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 0 active connection openings // 主动连接数 </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="18"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 0 passive connection openings // 被动连接数 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="19"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 11 failed connection attempts // 失败连接尝试数 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="20"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 0 connection resets received // 接收的连接重置数 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="21"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 0 connections established // 建立连接数 </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="22"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 25 segments received // 已接收报文数 </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="23"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 21 segments sent out // 已发送报文数 </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="24"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 4 segments retransmitted // 重传报文数 </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="25"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 0 bad segments received // 错误报文数 </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="26"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 0 resets sent // 发出的连接重置数 </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="27"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> Udp: </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="28"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 0 packets received </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="29"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> ... </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="30"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
TcpExt: </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="31"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 11 resets 
received for embryonic SYN_RECV sockets // 半连接重置数 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="32"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 0 packet headers predicted </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="33"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> TCPTimeouts: 7 // 超时数 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="34"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> TCPSynRetrans: 4 //SYN 重传数 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="35"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> ... </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <p>netstat 汇总了 IP、ICMP、TCP、UDP 等各种协议的收发统计信息。不过，我们的目的是排查丢包问题，所以这里主要观察的是错误数、丢包数以及重传数。</p> 
<p>根据上面的输出，你可以看到，只有 TCP 协议发生了丢包和重传，分别是：</p> <ul> <li> <p>11 次连接失败重试（11 failed connection attempts）</p> 
</li> <li> <p>4 次重传（4 segments retransmitted）</p> </li> <li> <p>11 次半连接重置（11 resets received 
for embryonic SYN_RECV sockets）</p> </li> <li> <p>4 次 SYN 重传（TCPSynRetrans）</p> </li> <li> 
<p>7 次超时（TCPTimeouts）</p> </li> </ul> <p>这个结果告诉我们，TCP 协议有多次超时和失败重试，并且主要错误是半连接重置。换句话说，主要的失败，都是三次握手失败。</p> 
<p>不过，虽然在这儿看到了这么多失败，但具体失败的根源还是无法确定。所以，我们还需要继续顺着协议栈来分析。接下来的几层又该如何分析呢？你不妨自己先来思考操作一下，下一节我们继续来一起探讨。</p> 
<h2>小结</h2> <p>网络丢包，通常会带来严重的性能下降，特别是对 TCP 来说，丢包通常意味着网络拥塞和重传，进一步还会导致网络延迟增大、吞吐降低。</p> <p>今天的这个案例，我们学会了如何从链路层、网络层和传输层等入手，分析网络丢包的问题。不过，案例最后，我们还没有找出最终的性能瓶颈，下一节，我将继续为你讲解。</p> 
<h2>思考</h2> <p>最后，给你留一个思考题，也是案例最后提到的问题。</p> <p>今天我们只分析了链路层、网络层以及传输层等。而根据 TCP/IP 协议栈和 Linux 
网络收发原理，还有很多我们没分析到的地方。那么，接下来，我们又该如何分析，才能破获这个案例，找出“真凶”呢？</p> <p>欢迎在留言区和我讨论，也欢迎把这篇文章分享给你的同事、朋友。我们一起在实战中演练，在交流中进步。</p> 
<p><img src="https://static001.geekbang.org/resource/image/a3/e9/a396aed4116c2c989771c1295736abe9.jpg" 
alt=""></p>', body_summary='', bundle='book', delta=0, body_format='full_html', langcode='zh-hans', 
revision_id=1080 where entity_id=1080 
 {executed in 1 msec}
2020-11-25 10:12:48.333 INFO  jdbc.sqltiming Line:373 - select nodefiledd0_.nid as nid1_10_, nodefiledd0_.changed as changed2_10_, nodefiledd0_.created 
as created3_10_, nodefiledd0_.default_langcode as default_4_10_, nodefiledd0_.langcode as langcode5_10_, 
nodefiledd0_.promote as promote6_10_, nodefiledd0_.revision_translation_affected as revision7_10_, 
nodefiledd0_.status as status8_10_, nodefiledd0_.sticky as sticky9_10_, nodefiledd0_.title 
as title10_10_, nodefiledd0_.type as type11_10_, nodefiledd0_.uid as uid12_10_, nodefiledd0_.vid 
as vid13_10_ from node_field_data nodefiledd0_ where nodefiledd0_.nid=1080 
 {executed in 0 msec}
2020-11-25 10:12:48.334 INFO  jdbc.resultsettable Line:610 - 
|-----|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|----------------------------|-----|----|-----|
|nid  |changed    |created    |default_langcode |langcode |promote |revision_translation_affected |status |sticky |title                       |type |uid |vid  |
|-----|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|----------------------------|-----|----|-----|
|1080 |1606114972 |1606114972 |1                |zh-hans  |0       |1                             |1      |0      |47丨案例篇：服务器总是时不时丢包，我该怎么办？（上） |book |1   |1080 |
|-----|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|----------------------------|-----|----|-----|

2020-11-25 10:12:48.335 INFO  jdbc.sqltiming Line:373 - select nodefieldr0_.nid as nid1_11_0_, nodefieldr0_.changed as changed2_11_0_, nodefieldr0_.created 
as created3_11_0_, nodefieldr0_.default_langcode as default_4_11_0_, nodefieldr0_.langcode 
as langcode5_11_0_, nodefieldr0_.promote as promote6_11_0_, nodefieldr0_.revision_translation_affected 
as revision7_11_0_, nodefieldr0_.status as status8_11_0_, nodefieldr0_.sticky as sticky9_11_0_, 
nodefieldr0_.title as title10_11_0_, nodefieldr0_.uid as uid11_11_0_, nodefieldr0_.vid as vid12_11_0_ 
from node_field_revision nodefieldr0_ where nodefieldr0_.nid=1080 
 {executed in 1 msec}
2020-11-25 10:12:48.335 INFO  jdbc.resultsettable Line:610 - 
|---------|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|----------------------------|----|-----|
|nid      |changed    |created    |default_langcode |langcode |promote |revision_translation_affected |status |sticky |title                       |uid |vid  |
|---------|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|----------------------------|----|-----|
|[unread] |1606114972 |1606114972 |1                |zh-hans  |0       |1                             |1      |0      |47丨案例篇：服务器总是时不时丢包，我该怎么办？（上） |1   |1080 |
|---------|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|----------------------------|----|-----|

2020-11-25 10:12:48.337 INFO  jdbc.sqltiming Line:373 - update node_field_data set changed=1606270368, created=1606270368, default_langcode=1, langcode='zh-hans', 
promote=0, revision_translation_affected=1, status=1, sticky=0, title='47丨案例篇：服务器总是时不时丢包，我该怎么办？（上）', 
type='book', uid=1, vid=1080 where nid=1080 
 {executed in 0 msec}
2020-11-25 10:12:48.337 INFO  jdbc.sqltiming Line:373 - update node_field_revision set changed=1606270368, created=1606270368, default_langcode=1, 
langcode='zh-hans', promote=0, revision_translation_affected=1, status=1, sticky=0, title='47丨案例篇：服务器总是时不时丢包，我该怎么办？（上）', 
uid=1, vid=1080 where nid=1080 
 {executed in 0 msec}
2020-11-25 10:12:48.342 INFO  jdbc.sqltiming Line:373 - select bookfieldm0_.entity_id as entity_i1_8_, bookfieldm0_.bundle as bundle2_8_, bookfieldm0_.delta 
as delta3_8_, bookfieldm0_.langcode as langcode4_8_, bookfieldm0_.field_media_value as field_me5_8_, 
bookfieldm0_.revision_id as revision6_8_ from node__field_media bookfieldm0_ where bookfieldm0_.entity_id=1080 
 {executed in 1 msec}
2020-11-25 10:12:48.342 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------------|------------|
|entity_id |bundle |delta |langcode |field_media_value |revision_id |
|----------|-------|------|---------|------------------|------------|
|1080      |book   |0     |zh-hans  |                  |1080        |
|----------|-------|------|---------|------------------|------------|

2020-11-25 10:12:48.344 INFO  jdbc.sqltiming Line:373 - select nodefieldm0_.entity_id as entity_i1_17_0_, nodefieldm0_.bundle as bundle2_17_0_, nodefieldm0_.delta 
as delta3_17_0_, nodefieldm0_.langcode as langcode4_17_0_, nodefieldm0_.field_media_value as 
field_me5_17_0_, nodefieldm0_.revision_id as revision6_17_0_ from node_revision__field_media 
nodefieldm0_ where nodefieldm0_.entity_id=1080 
 {executed in 0 msec}
2020-11-25 10:12:48.345 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------------|------------|
|entity_id |bundle |delta |langcode |field_media_value |revision_id |
|----------|-------|------|---------|------------------|------------|
|[unread]  |book   |0     |zh-hans  |                  |1080        |
|----------|-------|------|---------|------------------|------------|

2020-11-25 10:12:48.348 INFO  jdbc.sqltiming Line:373 - select bookfieldc0_.entity_id as entity_i1_5_, bookfieldc0_.bundle as bundle2_5_, bookfieldc0_.field_comment_value 
as field_co3_5_, bookfieldc0_.delta as delta4_5_, bookfieldc0_.field_comment_format as field_co5_5_, 
bookfieldc0_.langcode as langcode6_5_, bookfieldc0_.revision_id as revision7_5_ from node__field_comment 
bookfieldc0_ where bookfieldc0_.entity_id=1080 
 {executed in 0 msec}
2020-11-25 10:12:48.348 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|--------------------|------|---------------------|---------|------------|
|entity_id |bundle |field_comment_value |delta |field_comment_format |langcode |revision_id |
|----------|-------|--------------------|------|---------------------|---------|------------|
|1080      |book   |                    |0     |full_html            |zh-hans  |1080        |
|----------|-------|--------------------|------|---------------------|---------|------------|

2020-11-25 10:12:48.351 INFO  jdbc.sqltiming Line:373 - update node__field_comment set bundle='book', field_comment_value='<li class="reJj6Thl_0"><img 
src="https://wx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEKQMM4m7NHuicr55aRiblTSEWIYe0QqbpyHweaoAbG7j2v7UUElqqeP3Ihrm3UfDPDRb1Hv8LvPwXqA/132" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>ninuxer</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-13 </div> </div> <div 
class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">3</span> 
</div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0"> 打卡day50 <br>还没来得及实践，思路是，在服务端用tcpdump抓包，然后导入wireshark分析～ 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <!----> </div></li> 
<li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/14/11/4b/fa64f061.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>xfan</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-14 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> </div> <!----> 
<!----> </div> </div> <div class="_3M6kV3zb_0"> 有可能nginx配置问题 </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <!----> </div></li> <li class="reJj6Thl_0"><img 
src="https://static001.geekbang.org/account/avatar/00/10/20/b0/0a1551c4.jpg" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>蓝雾里的部...</span> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-13 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> </div> <!----> 
<!----> </div> </div> <div class="_3M6kV3zb_0"> 遇到过 ingress envoy -&gt; 某组应用容器 时不时的容器访问 503的问题， 
抓包放 wireshark 分析，发现有大量的 dup ack。 <br>2个容器的机器指标正常， pod 指标正常。 <br> <br>至今不知道原因， 升级了操作系统内核后， 问题有所缓解，但是没有根本解决问题。 
作者可否提供个思路？ <br> </div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> 
<div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 请参考文中（47和48篇）的思路分析</p> </div> </div></li> 
<li class="reJj6Thl_0"><img src="" class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> 
<div> <div class="_18Dng5rT_0"> <span>无名老卒</span> <!----> </div> <div class="_1H1Z49Dr_0"> 
2019-05-04 </div> </div> <div class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> 
<span class=""></span> </div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0"> 经过一夜的思考，终于搞明白了，使用iptables做了限制，删除这2条规则就正常Ping了。 
<br> <br>root@nginx:/# iptables -nvL <br>Chain INPUT (policy ACCEPT 84 packets, 3472 bytes) 
<br>&nbsp;pkts bytes target prot opt in out source destination <br>&nbsp;&nbsp;&nbsp;51 2116 
DROP all -- * * 0.0.0.0/0 0.0.0.0/0 statistic mode random probability 0.29999999981 <br> <br>Chain 
FORWARD (policy ACCEPT 0 packets, 0 bytes) <br>&nbsp;pkts bytes target prot opt in out source 
destination <br> <br>Chain OUTPUT (policy ACCEPT 65 packets, 2960 bytes) <br>&nbsp;pkts bytes 
target prot opt in out source destination <br>&nbsp;&nbsp;&nbsp;38 1716 DROP all -- * * 0.0.0.0/0 
0.0.0.0/0 statistic mode random probability 0.29999999981 </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 
👍</p> </div> </div></li> <li class="reJj6Thl_0"><img src="" class="_2273kGdT_0"> <div class="_2CG0SquK_0"> 
<div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>如果</span> <!----> </div> <div 
class="_1H1Z49Dr_0"> 2019-04-12 </div> </div> <div class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> 
<i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> </div> </div> <div 
class="_3M6kV3zb_0"> DAY47.打卡 </div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> 
</div> <!----> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/12/8c/2b/3ab96998.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>青石</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-21 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> TCP缓冲区在溢出后，数据会被阻塞并不会丢弃，从netstat可以看到Recv-Q的值很大。 <br>UDP缓冲区溢出，直接丢弃报文，从netstat 
-s可以看到UDP有大量的packet receive errors错误。 <br> <br>看了47、48节，并没有从套接字层排查问题是因为使用TCP协议的原因吗？ </div> 
<div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 我们这是丢包问题，只需要去分析netstat中有丢包的位置就可以了</p> </div> </div></li> <li class="reJj6Thl_0"><img 
src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK0lekib0VOFiaylqrYiaYgSVSMJ9ZyLymaxHpL9hWIUvEypxGhrDkJ2CSQUSwKaopuZFpRvRCIUicghA/132" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>cheyang</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-20 </div> </div> <div 
class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> 
</div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> netstat -s中的failed 
connection attempts的ip源有办法定位到吗？ </div> <!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 
ss 查看SYN-SENT状态的连接；或者，使用tcpdump抓包</p> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/11/25/42/72adcb14.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>亚洲-凯撒...</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-16 </div> </div> <div 
class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> 
</div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0"> netstat -s 的数据怎么重置呢 </div> <div 
class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 这是从proc文件系统读出来的，重置只能重启</p> </div> </div></li> <li class="reJj6Thl_0"><img 
src="http://thirdwx.qlogo.cn/mmopen/vi_32/oW1lwRgwgBaQk0ZA33fy4XE0rqF7NiaRupV89lqzib02SA5hwFRUicA5OiaA6TYaxKubnVAEFJnJ5olq8xmcJLpcwg/132" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>H</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-13 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 老师能详细解释下一TcpExt 里的指标分别是代表什么意思吗？ </div> 
<!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 这儿指标太多了，大部分还都是完整的英语句子，应该很好理解。如果有哪个不懂的，可以单独提出来</p> 
</div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>我来也</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-13 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> [D47打卡] <br>不知为何,容器中的mtu值只有100, 即使`ifconfig eth0 mtu 
1400`,丢包率也是依旧很高. <br>我这边的hping3结果中,有些看不懂的地方: <br>DUP! len=44 ip=192.168.1.128 ttl=63 DF id=0 
sport=80 flags=SA seq=2 win=27200 rtt=1018.3 ms <br>len=44 ip=192.168.1.128 ttl=63 DF id=0 
sport=80 flags=SA seq=4 win=27200 rtt=1032.7 ms <br>DUP! len=44 ip=192.168.1.128 ttl=63 DF 
id=0 sport=80 flags=SA seq=2 win=27200 rtt=3034.1 ms <br> <br>这里的DUP应该是重复了的意思吧. <br> <br>老师这个案例太狠了,连链路层上都做了手脚.😐 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 你这容器中mtu只有100是更狠呀😊<br><br>DUP表示收到了重复包</p> </div> </div></li> 
<li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/10/f7/b1/b05a2156.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>we</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-13 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> 老师 TcpExt: 表示什么项目哦？ </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 
扩展TCP指标，相对于Tcp部分包含更多的指标</p> </div> </div></li>', delta=0, field_comment_format='full_html', 
langcode='zh-hans', revision_id=1080 where entity_id=1080 
 {executed in 1 msec}
2020-11-25 10:12:48.354 INFO  jdbc.sqltiming Line:373 - select nodefieldc0_.entity_id as entity_i1_14_0_, nodefieldc0_.bundle as bundle2_14_0_, nodefieldc0_.field_comment_value 
as field_co3_14_0_, nodefieldc0_.delta as delta4_14_0_, nodefieldc0_.field_comment_format as 
field_co5_14_0_, nodefieldc0_.langcode as langcode6_14_0_, nodefieldc0_.revision_id as revision7_14_0_ 
from node_revision__field_comment nodefieldc0_ where nodefieldc0_.entity_id=1080 
 {executed in 0 msec}
2020-11-25 10:12:48.355 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|--------------------|------|---------------------|---------|------------|
|entity_id |bundle |field_comment_value |delta |field_comment_format |langcode |revision_id |
|----------|-------|--------------------|------|---------------------|---------|------------|
|[unread]  |book   |                    |0     |full_html            |zh-hans  |1080        |
|----------|-------|--------------------|------|---------------------|---------|------------|

2020-11-25 10:12:48.357 INFO  jdbc.sqltiming Line:373 - update node_revision__field_comment set bundle='book', field_comment_value='<li class="reJj6Thl_0"><img 
src="https://wx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEKQMM4m7NHuicr55aRiblTSEWIYe0QqbpyHweaoAbG7j2v7UUElqqeP3Ihrm3UfDPDRb1Hv8LvPwXqA/132" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>ninuxer</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-13 </div> </div> <div 
class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">3</span> 
</div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0"> 打卡day50 <br>还没来得及实践，思路是，在服务端用tcpdump抓包，然后导入wireshark分析～ 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <!----> </div></li> 
<li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/14/11/4b/fa64f061.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>xfan</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-14 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> </div> <!----> 
<!----> </div> </div> <div class="_3M6kV3zb_0"> 有可能nginx配置问题 </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <!----> </div></li> <li class="reJj6Thl_0"><img 
src="https://static001.geekbang.org/account/avatar/00/10/20/b0/0a1551c4.jpg" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>蓝雾里的部...</span> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-13 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> </div> <!----> 
<!----> </div> </div> <div class="_3M6kV3zb_0"> 遇到过 ingress envoy -&gt; 某组应用容器 时不时的容器访问 503的问题， 
抓包放 wireshark 分析，发现有大量的 dup ack。 <br>2个容器的机器指标正常， pod 指标正常。 <br> <br>至今不知道原因， 升级了操作系统内核后， 问题有所缓解，但是没有根本解决问题。 
作者可否提供个思路？ <br> </div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> 
<div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 请参考文中（47和48篇）的思路分析</p> </div> </div></li> 
<li class="reJj6Thl_0"><img src="" class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> 
<div> <div class="_18Dng5rT_0"> <span>无名老卒</span> <!----> </div> <div class="_1H1Z49Dr_0"> 
2019-05-04 </div> </div> <div class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> 
<span class=""></span> </div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0"> 经过一夜的思考，终于搞明白了，使用iptables做了限制，删除这2条规则就正常Ping了。 
<br> <br>root@nginx:/# iptables -nvL <br>Chain INPUT (policy ACCEPT 84 packets, 3472 bytes) 
<br>&nbsp;pkts bytes target prot opt in out source destination <br>&nbsp;&nbsp;&nbsp;51 2116 
DROP all -- * * 0.0.0.0/0 0.0.0.0/0 statistic mode random probability 0.29999999981 <br> <br>Chain 
FORWARD (policy ACCEPT 0 packets, 0 bytes) <br>&nbsp;pkts bytes target prot opt in out source 
destination <br> <br>Chain OUTPUT (policy ACCEPT 65 packets, 2960 bytes) <br>&nbsp;pkts bytes 
target prot opt in out source destination <br>&nbsp;&nbsp;&nbsp;38 1716 DROP all -- * * 0.0.0.0/0 
0.0.0.0/0 statistic mode random probability 0.29999999981 </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 
👍</p> </div> </div></li> <li class="reJj6Thl_0"><img src="" class="_2273kGdT_0"> <div class="_2CG0SquK_0"> 
<div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>如果</span> <!----> </div> <div 
class="_1H1Z49Dr_0"> 2019-04-12 </div> </div> <div class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> 
<i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> </div> </div> <div 
class="_3M6kV3zb_0"> DAY47.打卡 </div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> 
</div> <!----> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/12/8c/2b/3ab96998.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>青石</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-21 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> TCP缓冲区在溢出后，数据会被阻塞并不会丢弃，从netstat可以看到Recv-Q的值很大。 <br>UDP缓冲区溢出，直接丢弃报文，从netstat 
-s可以看到UDP有大量的packet receive errors错误。 <br> <br>看了47、48节，并没有从套接字层排查问题是因为使用TCP协议的原因吗？ </div> 
<div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 我们这是丢包问题，只需要去分析netstat中有丢包的位置就可以了</p> </div> </div></li> <li class="reJj6Thl_0"><img 
src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK0lekib0VOFiaylqrYiaYgSVSMJ9ZyLymaxHpL9hWIUvEypxGhrDkJ2CSQUSwKaopuZFpRvRCIUicghA/132" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>cheyang</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-20 </div> </div> <div 
class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> 
</div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> netstat -s中的failed 
connection attempts的ip源有办法定位到吗？ </div> <!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 
ss 查看SYN-SENT状态的连接；或者，使用tcpdump抓包</p> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/11/25/42/72adcb14.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>亚洲-凯撒...</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-16 </div> </div> <div 
class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> 
</div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0"> netstat -s 的数据怎么重置呢 </div> <div 
class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 这是从proc文件系统读出来的，重置只能重启</p> </div> </div></li> <li class="reJj6Thl_0"><img 
src="http://thirdwx.qlogo.cn/mmopen/vi_32/oW1lwRgwgBaQk0ZA33fy4XE0rqF7NiaRupV89lqzib02SA5hwFRUicA5OiaA6TYaxKubnVAEFJnJ5olq8xmcJLpcwg/132" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>H</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-13 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 老师能详细解释下一TcpExt 里的指标分别是代表什么意思吗？ </div> 
<!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 这儿指标太多了，大部分还都是完整的英语句子，应该很好理解。如果有哪个不懂的，可以单独提出来</p> 
</div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>我来也</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-13 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> [D47打卡] <br>不知为何,容器中的mtu值只有100, 即使`ifconfig eth0 mtu 
1400`,丢包率也是依旧很高. <br>我这边的hping3结果中,有些看不懂的地方: <br>DUP! len=44 ip=192.168.1.128 ttl=63 DF id=0 
sport=80 flags=SA seq=2 win=27200 rtt=1018.3 ms <br>len=44 ip=192.168.1.128 ttl=63 DF id=0 
sport=80 flags=SA seq=4 win=27200 rtt=1032.7 ms <br>DUP! len=44 ip=192.168.1.128 ttl=63 DF 
id=0 sport=80 flags=SA seq=2 win=27200 rtt=3034.1 ms <br> <br>这里的DUP应该是重复了的意思吧. <br> <br>老师这个案例太狠了,连链路层上都做了手脚.😐 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 你这容器中mtu只有100是更狠呀😊<br><br>DUP表示收到了重复包</p> </div> </div></li> 
<li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/10/f7/b1/b05a2156.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>we</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-13 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> 老师 TcpExt: 表示什么项目哦？ </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 
扩展TCP指标，相对于Tcp部分包含更多的指标</p> </div> </div></li>', delta=0, field_comment_format='full_html', 
langcode='zh-hans', revision_id=1080 where entity_id=1080 
 {executed in 1 msec}
2020-11-25 10:12:48.360 INFO  jdbc.sqltiming Line:373 - select bookfieldt0_.entity_id as entity_i1_9_, bookfieldt0_.bundle as bundle2_9_, bookfieldt0_.delta 
as delta3_9_, bookfieldt0_.langcode as langcode4_9_, bookfieldt0_.revision_id as revision5_9_, 
bookfieldt0_.field_thumb_value as field_th6_9_ from node__field_thumb bookfieldt0_ where bookfieldt0_.entity_id=1080 
 {executed in 0 msec}
2020-11-25 10:12:48.361 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------|------------------|
|entity_id |bundle |delta |langcode |revision_id |field_thumb_value |
|----------|-------|------|---------|------------|------------------|
|1080      |book   |0     |zh-hans  |1080        |                  |
|----------|-------|------|---------|------------|------------------|

2020-11-25 10:12:48.362 INFO  jdbc.sqltiming Line:373 - update node__field_thumb set bundle='book', delta=0, langcode='zh-hans', revision_id=1080, 
field_thumb_value='https://static001.geekbang.org/resource/image/2f/51/2fa8b8387c256a7ba022d3f4b2ad2051.jpg' 
where entity_id=1080 
 {executed in 0 msec}
2020-11-25 10:12:48.365 INFO  jdbc.sqltiming Line:373 - select nodefieldt0_.entity_id as entity_i1_18_0_, nodefieldt0_.bundle as bundle2_18_0_, nodefieldt0_.delta 
as delta3_18_0_, nodefieldt0_.langcode as langcode4_18_0_, nodefieldt0_.revision_id as revision5_18_0_, 
nodefieldt0_.field_thumb_value as field_th6_18_0_ from node_revision__field_thumb nodefieldt0_ 
where nodefieldt0_.entity_id=1080 
 {executed in 0 msec}
2020-11-25 10:12:48.365 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------|------------------|
|entity_id |bundle |delta |langcode |revision_id |field_thumb_value |
|----------|-------|------|---------|------------|------------------|
|[unread]  |book   |0     |zh-hans  |1080        |                  |
|----------|-------|------|---------|------------|------------------|

2020-11-25 10:12:48.367 INFO  jdbc.sqltiming Line:373 - update node_revision__field_thumb set bundle='book', delta=0, langcode='zh-hans', revision_id=1080, 
field_thumb_value='https://static001.geekbang.org/resource/image/2f/51/2fa8b8387c256a7ba022d3f4b2ad2051.jpg' 
where entity_id=1080 
 {executed in 0 msec}
2020-11-25 10:12:48.371 INFO  jdbc.sqltiming Line:373 - select bookfieldf0_.entity_id as entity_i1_6_0_, bookfieldf0_.bundle as bundle2_6_0_, bookfieldf0_.delta 
as delta3_6_0_, bookfieldf0_.field_fenlei_target_id as field_fe4_6_0_, bookfieldf0_.langcode 
as langcode5_6_0_, bookfieldf0_.revision_id as revision6_6_0_ from node__field_fenlei bookfieldf0_ 
where bookfieldf0_.entity_id=1080 
 {executed in 0 msec}
2020-11-25 10:12:48.372 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|-----------------------|---------|------------|
|entity_id |bundle |delta |field_fenlei_target_id |langcode |revision_id |
|----------|-------|------|-----------------------|---------|------------|
|[unread]  |book   |0     |1                      |zh-hans  |1080        |
|----------|-------|------|-----------------------|---------|------------|

2020-11-25 10:12:48.373 INFO  jdbc.sqltiming Line:373 - select nodefieldf0_.entity_id as entity_i1_15_0_, nodefieldf0_.bundle as bundle2_15_0_, nodefieldf0_.delta 
as delta3_15_0_, nodefieldf0_.field_fenlei_target_id as field_fe4_15_0_, nodefieldf0_.langcode 
as langcode5_15_0_, nodefieldf0_.revision_id as revision6_15_0_ from node_revision__field_fenlei 
nodefieldf0_ where nodefieldf0_.entity_id=1080 
 {executed in 0 msec}
2020-11-25 10:12:48.374 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|-----------------------|---------|------------|
|entity_id |bundle |delta |field_fenlei_target_id |langcode |revision_id |
|----------|-------|------|-----------------------|---------|------------|
|[unread]  |book   |0     |1                      |zh-hans  |1080        |
|----------|-------|------|-----------------------|---------|------------|

2020-11-25 10:12:48.375 INFO  jdbc.sqltiming Line:373 - select bookchecke0_.item_id as item_id1_2_, bookchecke0_.fsid as fsid2_2_, bookchecke0_.got 
as got3_2_, bookchecke0_.name as name4_2_, bookchecke0_.parse_fail as parse_fa5_2_, bookchecke0_.parsed 
as parsed6_2_, bookchecke0_.path as path7_2_, bookchecke0_.title as title8_2_, bookchecke0_.vid 
as vid9_2_ from book_check bookchecke0_ where bookchecke0_.fsid='688647992209358' and bookchecke0_.name='net_content' 
 {executed in 0 msec}
2020-11-25 10:12:48.376 INFO  jdbc.resultsettable Line:610 - 
|--------|---------|---------|---------|-----------|---------|---------|---------|---------|
|item_id |fsid     |got      |name     |parse_fail |parsed   |path     |title    |vid      |
|--------|---------|---------|---------|-----------|---------|---------|---------|---------|
|1081    |[unread] |[unread] |[unread] |[unread]   |[unread] |[unread] |[unread] |[unread] |
|--------|---------|---------|---------|-----------|---------|---------|---------|---------|

2020-11-25 10:12:48.420 INFO  jdbc.sqltiming Line:373 - update book_check set fsid='688647992209358', got=0, name='net_content', parse_fail='', parsed=1, 
path='12-Linux性能优化实战/06-综合实战篇 (13讲)/48丨案例篇：服务器总是时不时丢包，我该怎么办？（下）.html', title='48丨案例篇：服务器总是时不时丢包，我该怎么办？（下）', 
vid=1081 where item_id=1081 
 {executed in 0 msec}
2020-11-25 10:12:48.425 INFO  jdbc.sqltiming Line:373 - select nodebodyen0_.entity_id as entity_i1_4_, nodebodyen0_.body_value as body_val2_4_, nodebodyen0_.body_summary 
as body_sum3_4_, nodebodyen0_.bundle as bundle4_4_, nodebodyen0_.delta as delta5_4_, nodebodyen0_.body_format 
as body_for6_4_, nodebodyen0_.langcode as langcode7_4_, nodebodyen0_.revision_id as revision8_4_ 
from node__body nodebodyen0_ where nodebodyen0_.entity_id=1081 
 {executed in 1 msec}
2020-11-25 10:12:48.425 INFO  jdbc.resultsettable Line:610 - 
|----------|-----------|-------------|-------|------|------------|---------|------------|
|entity_id |body_value |body_summary |bundle |delta |body_format |langcode |revision_id |
|----------|-----------|-------------|-------|------|------------|---------|------------|
|1081      |           |             |book   |0     |full_html   |zh-hans  |1081        |
|----------|-----------|-------------|-------|------|------------|---------|------------|

2020-11-25 10:12:48.426 INFO  jdbc.sqltiming Line:373 - select nodebodyre0_.entity_id as entity_i1_13_0_, nodebodyre0_.body_value as body_val2_13_0_, 
nodebodyre0_.body_summary as body_sum3_13_0_, nodebodyre0_.bundle as bundle4_13_0_, nodebodyre0_.delta 
as delta5_13_0_, nodebodyre0_.body_format as body_for6_13_0_, nodebodyre0_.langcode as langcode7_13_0_, 
nodebodyre0_.revision_id as revision8_13_0_ from node_revision__body nodebodyre0_ where nodebodyre0_.entity_id=1081 
 {executed in 0 msec}
2020-11-25 10:12:48.427 INFO  jdbc.resultsettable Line:610 - 
|----------|-----------|-------------|-------|------|------------|---------|------------|
|entity_id |body_value |body_summary |bundle |delta |body_format |langcode |revision_id |
|----------|-----------|-------------|-------|------|------------|---------|------------|
|[unread]  |           |             |book   |0     |full_html   |zh-hans  |1081        |
|----------|-----------|-------------|-------|------|------------|---------|------------|

2020-11-25 10:12:48.430 INFO  jdbc.sqltiming Line:373 - select nodefiledd0_.nid as nid1_10_, nodefiledd0_.changed as changed2_10_, nodefiledd0_.created 
as created3_10_, nodefiledd0_.default_langcode as default_4_10_, nodefiledd0_.langcode as langcode5_10_, 
nodefiledd0_.promote as promote6_10_, nodefiledd0_.revision_translation_affected as revision7_10_, 
nodefiledd0_.status as status8_10_, nodefiledd0_.sticky as sticky9_10_, nodefiledd0_.title 
as title10_10_, nodefiledd0_.type as type11_10_, nodefiledd0_.uid as uid12_10_, nodefiledd0_.vid 
as vid13_10_ from node_field_data nodefiledd0_ where nodefiledd0_.nid=1081 
 {executed in 0 msec}
2020-11-25 10:12:48.431 INFO  jdbc.resultsettable Line:610 - 
|-----|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|----------------------------|-----|----|-----|
|nid  |changed    |created    |default_langcode |langcode |promote |revision_translation_affected |status |sticky |title                       |type |uid |vid  |
|-----|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|----------------------------|-----|----|-----|
|1081 |1606114976 |1606114976 |1                |zh-hans  |0       |1                             |1      |0      |48丨案例篇：服务器总是时不时丢包，我该怎么办？（下） |book |1   |1081 |
|-----|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|----------------------------|-----|----|-----|

2020-11-25 10:12:48.432 INFO  jdbc.sqltiming Line:373 - select nodefieldr0_.nid as nid1_11_0_, nodefieldr0_.changed as changed2_11_0_, nodefieldr0_.created 
as created3_11_0_, nodefieldr0_.default_langcode as default_4_11_0_, nodefieldr0_.langcode 
as langcode5_11_0_, nodefieldr0_.promote as promote6_11_0_, nodefieldr0_.revision_translation_affected 
as revision7_11_0_, nodefieldr0_.status as status8_11_0_, nodefieldr0_.sticky as sticky9_11_0_, 
nodefieldr0_.title as title10_11_0_, nodefieldr0_.uid as uid11_11_0_, nodefieldr0_.vid as vid12_11_0_ 
from node_field_revision nodefieldr0_ where nodefieldr0_.nid=1081 
 {executed in 0 msec}
2020-11-25 10:12:48.432 INFO  jdbc.resultsettable Line:610 - 
|---------|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|----------------------------|----|-----|
|nid      |changed    |created    |default_langcode |langcode |promote |revision_translation_affected |status |sticky |title                       |uid |vid  |
|---------|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|----------------------------|----|-----|
|[unread] |1606114976 |1606114976 |1                |zh-hans  |0       |1                             |1      |0      |48丨案例篇：服务器总是时不时丢包，我该怎么办？（下） |1   |1081 |
|---------|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|----------------------------|----|-----|

2020-11-25 10:12:48.434 INFO  jdbc.sqltiming Line:373 - update node_field_data set changed=1606270368, created=1606270368, default_langcode=1, langcode='zh-hans', 
promote=0, revision_translation_affected=1, status=1, sticky=0, title='48丨案例篇：服务器总是时不时丢包，我该怎么办？（下）', 
type='book', uid=1, vid=1081 where nid=1081 
 {executed in 1 msec}
2020-11-25 10:12:48.434 INFO  jdbc.sqltiming Line:373 - update node_field_revision set changed=1606270368, created=1606270368, default_langcode=1, 
langcode='zh-hans', promote=0, revision_translation_affected=1, status=1, sticky=0, title='48丨案例篇：服务器总是时不时丢包，我该怎么办？（下）', 
uid=1, vid=1081 where nid=1081 
 {executed in 0 msec}
2020-11-25 10:12:48.439 INFO  jdbc.sqltiming Line:373 - select bookfieldm0_.entity_id as entity_i1_8_, bookfieldm0_.bundle as bundle2_8_, bookfieldm0_.delta 
as delta3_8_, bookfieldm0_.langcode as langcode4_8_, bookfieldm0_.field_media_value as field_me5_8_, 
bookfieldm0_.revision_id as revision6_8_ from node__field_media bookfieldm0_ where bookfieldm0_.entity_id=1081 
 {executed in 0 msec}
2020-11-25 10:12:48.440 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------------|------------|
|entity_id |bundle |delta |langcode |field_media_value |revision_id |
|----------|-------|------|---------|------------------|------------|
|1081      |book   |0     |zh-hans  |                  |1081        |
|----------|-------|------|---------|------------------|------------|

2020-11-25 10:12:48.442 INFO  jdbc.sqltiming Line:373 - select nodefieldm0_.entity_id as entity_i1_17_0_, nodefieldm0_.bundle as bundle2_17_0_, nodefieldm0_.delta 
as delta3_17_0_, nodefieldm0_.langcode as langcode4_17_0_, nodefieldm0_.field_media_value as 
field_me5_17_0_, nodefieldm0_.revision_id as revision6_17_0_ from node_revision__field_media 
nodefieldm0_ where nodefieldm0_.entity_id=1081 
 {executed in 0 msec}
2020-11-25 10:12:48.442 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------------|------------|
|entity_id |bundle |delta |langcode |field_media_value |revision_id |
|----------|-------|------|---------|------------------|------------|
|[unread]  |book   |0     |zh-hans  |                  |1081        |
|----------|-------|------|---------|------------------|------------|

2020-11-25 10:12:48.444 INFO  jdbc.sqltiming Line:373 - select bookfieldc0_.entity_id as entity_i1_5_, bookfieldc0_.bundle as bundle2_5_, bookfieldc0_.field_comment_value 
as field_co3_5_, bookfieldc0_.delta as delta4_5_, bookfieldc0_.field_comment_format as field_co5_5_, 
bookfieldc0_.langcode as langcode6_5_, bookfieldc0_.revision_id as revision7_5_ from node__field_comment 
bookfieldc0_ where bookfieldc0_.entity_id=1081 
 {executed in 0 msec}
2020-11-25 10:12:48.444 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|--------------------|------|---------------------|---------|------------|
|entity_id |bundle |field_comment_value |delta |field_comment_format |langcode |revision_id |
|----------|-------|--------------------|------|---------------------|---------|------------|
|1081      |book   |                    |0     |full_html            |zh-hans  |1081        |
|----------|-------|--------------------|------|---------------------|---------|------------|

2020-11-25 10:12:48.446 INFO  jdbc.sqltiming Line:373 - select nodefieldc0_.entity_id as entity_i1_14_0_, nodefieldc0_.bundle as bundle2_14_0_, nodefieldc0_.field_comment_value 
as field_co3_14_0_, nodefieldc0_.delta as delta4_14_0_, nodefieldc0_.field_comment_format as 
field_co5_14_0_, nodefieldc0_.langcode as langcode6_14_0_, nodefieldc0_.revision_id as revision7_14_0_ 
from node_revision__field_comment nodefieldc0_ where nodefieldc0_.entity_id=1081 
 {executed in 0 msec}
2020-11-25 10:12:48.447 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|--------------------|------|---------------------|---------|------------|
|entity_id |bundle |field_comment_value |delta |field_comment_format |langcode |revision_id |
|----------|-------|--------------------|------|---------------------|---------|------------|
|[unread]  |book   |                    |0     |full_html            |zh-hans  |1081        |
|----------|-------|--------------------|------|---------------------|---------|------------|

2020-11-25 10:12:48.449 INFO  jdbc.sqltiming Line:373 - select bookfieldt0_.entity_id as entity_i1_9_, bookfieldt0_.bundle as bundle2_9_, bookfieldt0_.delta 
as delta3_9_, bookfieldt0_.langcode as langcode4_9_, bookfieldt0_.revision_id as revision5_9_, 
bookfieldt0_.field_thumb_value as field_th6_9_ from node__field_thumb bookfieldt0_ where bookfieldt0_.entity_id=1081 
 {executed in 1 msec}
2020-11-25 10:12:48.449 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------|------------------|
|entity_id |bundle |delta |langcode |revision_id |field_thumb_value |
|----------|-------|------|---------|------------|------------------|
|1081      |book   |0     |zh-hans  |1081        |                  |
|----------|-------|------|---------|------------|------------------|

2020-11-25 10:12:48.451 INFO  jdbc.sqltiming Line:373 - select nodefieldt0_.entity_id as entity_i1_18_0_, nodefieldt0_.bundle as bundle2_18_0_, nodefieldt0_.delta 
as delta3_18_0_, nodefieldt0_.langcode as langcode4_18_0_, nodefieldt0_.revision_id as revision5_18_0_, 
nodefieldt0_.field_thumb_value as field_th6_18_0_ from node_revision__field_thumb nodefieldt0_ 
where nodefieldt0_.entity_id=1081 
 {executed in 1 msec}
2020-11-25 10:12:48.451 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------|------------------|
|entity_id |bundle |delta |langcode |revision_id |field_thumb_value |
|----------|-------|------|---------|------------|------------------|
|[unread]  |book   |0     |zh-hans  |1081        |                  |
|----------|-------|------|---------|------------|------------------|

2020-11-25 10:12:48.453 INFO  jdbc.sqltiming Line:373 - select bookfieldf0_.entity_id as entity_i1_6_0_, bookfieldf0_.bundle as bundle2_6_0_, bookfieldf0_.delta 
as delta3_6_0_, bookfieldf0_.field_fenlei_target_id as field_fe4_6_0_, bookfieldf0_.langcode 
as langcode5_6_0_, bookfieldf0_.revision_id as revision6_6_0_ from node__field_fenlei bookfieldf0_ 
where bookfieldf0_.entity_id=1081 
 {executed in 0 msec}
2020-11-25 10:12:48.453 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|-----------------------|---------|------------|
|entity_id |bundle |delta |field_fenlei_target_id |langcode |revision_id |
|----------|-------|------|-----------------------|---------|------------|
|[unread]  |book   |0     |1                      |zh-hans  |1081        |
|----------|-------|------|-----------------------|---------|------------|

2020-11-25 10:12:48.455 INFO  jdbc.sqltiming Line:373 - select nodefieldf0_.entity_id as entity_i1_15_0_, nodefieldf0_.bundle as bundle2_15_0_, nodefieldf0_.delta 
as delta3_15_0_, nodefieldf0_.field_fenlei_target_id as field_fe4_15_0_, nodefieldf0_.langcode 
as langcode5_15_0_, nodefieldf0_.revision_id as revision6_15_0_ from node_revision__field_fenlei 
nodefieldf0_ where nodefieldf0_.entity_id=1081 
 {executed in 0 msec}
2020-11-25 10:12:48.455 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|-----------------------|---------|------------|
|entity_id |bundle |delta |field_fenlei_target_id |langcode |revision_id |
|----------|-------|------|-----------------------|---------|------------|
|[unread]  |book   |0     |1                      |zh-hans  |1081        |
|----------|-------|------|-----------------------|---------|------------|

2020-11-25 10:12:48.457 INFO  jdbc.sqltiming Line:373 - select bookchecke0_.item_id as item_id1_2_, bookchecke0_.fsid as fsid2_2_, bookchecke0_.got 
as got3_2_, bookchecke0_.name as name4_2_, bookchecke0_.parse_fail as parse_fa5_2_, bookchecke0_.parsed 
as parsed6_2_, bookchecke0_.path as path7_2_, bookchecke0_.title as title8_2_, bookchecke0_.vid 
as vid9_2_ from book_check bookchecke0_ where bookchecke0_.fsid='988859210832392' and bookchecke0_.name='net_content' 
 {executed in 0 msec}
2020-11-25 10:12:48.458 INFO  jdbc.resultsettable Line:610 - 
|--------|---------|---------|---------|-----------|---------|---------|---------|---------|
|item_id |fsid     |got      |name     |parse_fail |parsed   |path     |title    |vid      |
|--------|---------|---------|---------|-----------|---------|---------|---------|---------|
|1082    |[unread] |[unread] |[unread] |[unread]   |[unread] |[unread] |[unread] |[unread] |
|--------|---------|---------|---------|-----------|---------|---------|---------|---------|

2020-11-25 10:15:39.121 INFO  jdbc.sqltiming Line:373 - update book_check set fsid='988859210832392', got=1, name='net_content', parse_fail='comment_', 
parsed=0, path='12-Linux性能优化实战/06-综合实战篇 (13讲)/49丨案例篇：内核线程CPU利用率太高，我该怎么办？.html', title='49丨案例篇：内核线程CPU利用率太高，我该怎么办？', 
vid=1082 where item_id=1082 
 {executed in 1 msec}
2020-11-25 10:15:39.125 INFO  jdbc.sqltiming Line:373 - select nodebodyen0_.entity_id as entity_i1_4_, nodebodyen0_.body_value as body_val2_4_, nodebodyen0_.body_summary 
as body_sum3_4_, nodebodyen0_.bundle as bundle4_4_, nodebodyen0_.delta as delta5_4_, nodebodyen0_.body_format 
as body_for6_4_, nodebodyen0_.langcode as langcode7_4_, nodebodyen0_.revision_id as revision8_4_ 
from node__body nodebodyen0_ where nodebodyen0_.entity_id=1082 
 {executed in 1 msec}
2020-11-25 10:15:39.125 INFO  jdbc.resultsettable Line:610 - 
|----------|-----------|-------------|-------|------|------------|---------|------------|
|entity_id |body_value |body_summary |bundle |delta |body_format |langcode |revision_id |
|----------|-----------|-------------|-------|------|------------|---------|------------|
|1082      |           |             |book   |0     |full_html   |zh-hans  |1082        |
|----------|-----------|-------------|-------|------|------------|---------|------------|

2020-11-25 10:15:39.126 INFO  jdbc.sqltiming Line:373 - select nodebodyre0_.entity_id as entity_i1_13_0_, nodebodyre0_.body_value as body_val2_13_0_, 
nodebodyre0_.body_summary as body_sum3_13_0_, nodebodyre0_.bundle as bundle4_13_0_, nodebodyre0_.delta 
as delta5_13_0_, nodebodyre0_.body_format as body_for6_13_0_, nodebodyre0_.langcode as langcode7_13_0_, 
nodebodyre0_.revision_id as revision8_13_0_ from node_revision__body nodebodyre0_ where nodebodyre0_.entity_id=1082 
 {executed in 0 msec}
2020-11-25 10:15:39.126 INFO  jdbc.resultsettable Line:610 - 
|----------|-----------|-------------|-------|------|------------|---------|------------|
|entity_id |body_value |body_summary |bundle |delta |body_format |langcode |revision_id |
|----------|-----------|-------------|-------|------|------------|---------|------------|
|[unread]  |           |             |book   |0     |full_html   |zh-hans  |1082        |
|----------|-----------|-------------|-------|------|------------|---------|------------|

2020-11-25 10:15:39.129 INFO  jdbc.sqltiming Line:373 - update node__body set body_value='<p>你好，我是倪朋飞。</p> <p>上一期，我们一起梳理了，网络时不时丢包的分析定位和优化方法。先简单回顾一下。</p> 
<p>网络丢包，通常会带来严重的性能下降，特别是对 TCP 来说，丢包通常意味着网络拥塞和重传，进而会导致网络延迟增大以及吞吐量降低。</p> <p>而分析丢包问题，还是用我们的老套路，从 
Linux 网络收发的流程入手，结合 TCP/IP 协议栈的原理来逐层分析。</p> <p>其实，在排查网络问题时，我们还经常碰到的一个问题，就是内核线程的 CPU 使用率很高。比如，在高并发的场景中，内核线程 
ksoftirqd 的 CPU 使用率通常就会比较高。回顾一下前面学过的 CPU 和网络模块，你应该知道，这是网络收发的软中断导致的。</p> <p>而要分析 ksoftirqd 这类 
CPU 使用率比较高的内核线程，如果用我前面介绍过的那些分析方法，你一般需要借助于其他性能工具，进行辅助分析。</p> <p>比如，还是以 ksoftirqd 为例，如果你怀疑是网络问题，就可以用 
sar、tcpdump 等分析网络流量，进一步确认网络问题的根源。</p> <p>不过，显然，这种方法在实际操作中需要步骤比较多，可能并不算快捷。你肯定也很想知道，有没有其他更简单的方法，可以直接观察内核线程的行为，更快定位瓶颈呢？</p> 
<p>今天，我就继续以 ksoftirqd 为例，带你一起看看，如何分析内核线程的性能问题。</p><!-- [[[read_end]]] --> <h2>内核线程</h2> <p>既然要讲内核线程的性能问题，在案例开始之前，我们就先来看看，有哪些常见的内核线程。</p> 
<p>我们知道，在 Linux 中，用户态进程的“祖先”，都是 PID 号为 1 的 init 进程。比如，现在主流的 Linux 发行版中，init 都是 systemd 进程；而其他的用户态进程，会通过 
systemd 来进行管理。</p> <p>稍微想一下 Linux 中的各种进程，除了用户态进程外，还有大量的内核态线程。按说内核态的线程，应该先于用户态进程启动，可是 systemd 
只管理用户态进程。那么，内核态线程又是谁来管理的呢？</p> <p>实际上，Linux 在启动过程中，有三个特殊的进程，也就是 PID 号最小的三个进程。</p> <ul> <li> 
<p>0 号进程为 idle 进程，这也是系统创建的第一个进程，它在初始化 1 号和 2 号进程后，演变为空闲任务。当 CPU 上没有其他任务执行时，就会运行它。</p> </li> 
<li> <p>1 号进程为 init 进程，通常是 systemd 进程，在用户态运行，用来管理其他用户态进程。</p> </li> <li> <p>2 号进程为 kthreadd 
进程，在内核态运行，用来管理内核线程。</p> </li> </ul> <p>所以，要查找内核线程，我们只需要从 2 号进程开始，查找它的子孙进程即可。比如，你可以使用 ps 命令，来查找 
kthreadd 的子进程：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ ps -f --ppid 2 -p 2 </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> UID PID PPID C STIME TTY TIME CMD </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> root 2 0 0 12:02 ? 00:00:01 [kthreadd] 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> root 9 2 0 12:02 ? 00:00:21 [ksoftirqd/0] 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> root 10 2 0 12:02 ? 00:11:47 [rcu_sched] 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> root 11 2 0 12:02 ? 00:00:18 [migration/0] 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> ... </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> root 11094 2 0 14:20 ? 00:00:00 [kworker/1:0-eve] </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> root 11647 2 0 14:27 ? 00:00:00 [kworker/0:2-cgr] 
</div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>从上面的输出，你能够看到，内核线程的名称（CMD）都在中括号里（这一点，我们前面内容也有提到过）。所以，更简单的方法，就是直接查找名称包含中括号的进程。比如：</p> 
<pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> $ ps -ef | grep "\[.*\]" </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> root 2 0 0 08:14 ? 00:00:00 [kthreadd] </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> root 3 2 0 08:14 ? 00:00:00 [rcu_gp] </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> root 4 2 0 08:14 ? 00:00:00 [rcu_par_gp] 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> ... </div></td> </tr> </tbody> </table></code> 
<div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 </div></pre> <p>了解内核线程的基本功能，对我们排查问题有非常大的帮助。比如，我们曾经在软中断案例中提到过 
ksoftirqd。它是一个用来处理软中断的内核线程，并且每个 CPU 上都有一个。</p> <p>如果你知道了这一点，那么，以后遇到 ksoftirqd 的 CPU 使用高的情况，就会首先怀疑是软中断的问题，然后从软中断的角度来进一步分析。</p> 
<p>其实，除了刚才看到的 kthreadd 和 ksoftirqd 外，还有很多常见的内核线程，我们在性能分析中都经常会碰到，比如下面这几个内核线程。</p> <ul> <li> 
<p><strong>kswapd0</strong>：用于内存回收。在 <a href="https://time.geekbang.org/column/article/75797">Swap 
变高</a> 案例中，我曾介绍过它的工作原理。</p> </li> <li> <p><strong>kworker</strong>：用于执行内核工作队列，分为绑定 CPU （名称格式为 
kworker/CPU86330）和未绑定 CPU（名称格式为 kworker/uPOOL86330）两类。</p> </li> <li> <p><strong>migration</strong>：在负载均衡过程中，把进程迁移到 
CPU 上。每个 CPU 都有一个 migration 内核线程。</p> </li> <li> <p><strong>jbd2</strong>/sda1-8：jbd 是 Journaling 
Block Device 的缩写，用来为文件系统提供日志功能，以保证数据的完整性；名称中的 sda1-8，表示磁盘分区名称和设备号。每个使用了 ext4 文件系统的磁盘分区，都会有一个 
jbd2 内核线程。</p> </li> <li> <p><strong>pdflush</strong>：用于将内存中的脏页（被修改过，但还未写入磁盘的文件页）写入磁盘（已经在 3.10 
中合并入了 kworker 中）。</p> </li> </ul> <p>了解这几个容易发生性能问题的内核线程，有助于我们更快地定位性能瓶颈。接下来，我们来看今天的案例。</p> <h2>案例准备</h2> 
<p>今天的案例还是基于 Ubuntu 18.04，同样适用于其他的 Linux 系统。我使用的案例环境如下所示：</p> <ul> <li> <p>机器配置：2 CPU，8GB 内存。</p> 
</li> <li> <p>预先安装 docker、perf、hping3、curl 等工具，如 apt install docker.io linux-tools-common hping3。</p> 
</li> </ul> <p>本次案例用到两台虚拟机，我画了一张图来表示它们的关系。</p> <p><img src="https://static001.geekbang.org/resource/image/7d/11/7dd0763a14713940e7c762a62387dd11.png" 
alt=""></p> <p>你需要打开两个终端，分别登录这两台虚拟机中，并安装上述工具。</p> <p>注意，以下所有命令都默认以 root 用户运行，如果你用普通用户身份登陆系统，请运行 
sudo su root 命令，切换到 root 用户。</p> <blockquote> <p>如果安装过程有问题，你可以先上网搜索解决，实在解决不了的，记得在留言区向我提问。</p> 
</blockquote> <p>到这里，准备工作就完成了。接下来，我们正式进入操作环节。</p> <h2>案例分析</h2> <p>安装完成后，我们先在第一个终端，执行下面的命令运行案例，也就是一个最基本的 
Nginx 应用：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> <tr> 
<td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> # 运行 Nginx 服务并对外开放 80 端口 </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ docker run -itd --name=nginx -p 80:80 
nginx </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>然后，在第二个终端，使用 curl 访问 Nginx 监听的端口，确认 Nginx 正常启动。假设 192.168.0.30 是 Nginx 所在虚拟机的 
IP 地址，运行 curl 命令后，你应该会看到下面这个输出界面：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> 
<tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ curl http://192.168.0.30/ </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> &lt;!DOCTYPE html&gt; </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> &lt;html&gt; </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> &lt;head&gt; </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> &lt;title&gt;Welcome to nginx!&lt;/title&gt; 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> ... </div></td> </tr> </tbody> </table></code> 
<div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 </div></pre> <p>接着，还是在第二个终端中，运行 
hping3 命令，模拟 Nginx 的客户端请求：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> 
<tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> # -S 参数表示设置 TCP 协议的 SYN（同步序列号），-p 表示目的端口为 
80 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> # -i 
u10 表示每隔 10 微秒发送一个网络帧 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
# 注：如果你在实践过程中现象不明显，可以尝试把 10 调小，比如调成 5 甚至 1 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> $ hping3 -S -p 80 -i u10 192.168.0.30 </div></td> </tr> </tbody> 
</table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 </div></pre> 
<p>现在，我们再回到第一个终端，你应该就会发现异常——系统的响应明显变慢了。我们不妨执行 top，观察一下系统和进程的 CPU 使用情况：</p> <pre style="position: 
relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
$ top </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> top - 
08:31:43 up 17 min, 1 user, load average: 0.00, 0.00, 0.02 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> Tasks: 128 total, 1 running, 69 sleeping, 0 stopped, 0 zombie </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> %Cpu0 : 0.3 us, 0.3 sy, 0.0 ni, 66.8 id, 
0.3 wa, 0.0 hi, 32.4 si, 0.0 st </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="5"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
%Cpu1 : 0.0 us, 0.3 sy, 0.0 ni, 65.2 id, 0.0 wa, 0.0 hi, 34.5 si, 0.0 st </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> KiB Mem : 8167040 total, 7234236 free, 
358976 used, 573828 buff/cache </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="7"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
KiB Swap: 0 total, 0 free, 0 used. 7560460 avail Mem </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="9"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 9 root 20 0 0 0 0 S 7.0 0.0 0:00.48 ksoftirqd/0 </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 18 root 20 0 0 0 0 S 6.9 0.0 0:00.56 ksoftirqd/1 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 2489 root 20 0 876896 38408 21520 S 0.3 
0.5 0:01.50 docker-containe </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="13"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
3008 root 20 0 44536 3936 3304 R 0.3 0.0 0:00.09 top </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="14"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 1 root 20 0 78116 9000 6432 S 0.0 0.1 0:11.77 systemd </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="15"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> ... </div></td> </tr> </tbody> </table></code> 
<div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 </div></pre> <p>从 top 
的输出中，你可以看到，两个 CPU 的软中断使用率都超过了 30%；而 CPU 使用率最高的进程，正好是软中断内核线程 ksoftirqd/0 和 ksoftirqd/1。</p> 
<p>虽然，我们已经知道了 ksoftirqd 的基本功能，可以猜测是因为大量网络收发，引起了 CPU 使用率升高；但它到底在执行什么逻辑，我们却并不知道。</p> <p>对于普通进程，我们要观察其行为有很多方法，比如 
strace、pstack、lsof 等等。但这些工具并不适合内核线程，比如，如果你用 pstack ，或者通过 /proc/pid/stack 查看 ksoftirqd/0（进程号为 
9）的调用栈时，分别可以得到以下输出：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ pstack 9 </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> Could not attach to target 9: Operation 
not permitted. </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
detach: No such process </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <pre style="position: relative;"><code> <table 
class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> $ cat 
/proc/9/stack </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
[&lt;0&gt;] smpboot_thread_fn+0x166/0x170 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> [&lt;0&gt;] kthread+0x121/0x140 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> [&lt;0&gt;] ret_from_fork+0x35/0x40 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> [&lt;0&gt;] 0xffffffffffffffff </div></td> </tr> </tbody> </table></code> 
<div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 </div></pre> <p>显然，pstack 
报出的是不允许挂载进程的错误；而 /proc/9/stack 方式虽然有输出，但输出中并没有详细的调用栈情况。</p> <p>那还有没有其他方法，来观察内核线程 ksoftirqd 
的行为呢？</p> <p>既然是内核线程，自然应该用到内核中提供的机制。回顾一下我们之前用过的 CPU 性能工具，我想你肯定还记得 perf ，这个内核自带的性能剖析工具。</p> 
<p>perf 可以对指定的进程或者事件进行采样，并且还可以用调用栈的形式，输出整个调用链上的汇总信息。 我们不妨就用 perf ，来试着分析一下进程号为 9 的 ksoftirqd。</p> 
<p>继续在终端一中，执行下面的 perf record 命令；并指定进程号 9 ，以便记录 ksoftirqd 的行为:</p> <pre style="position: relative;"><code> 
<table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
# 采样 30s 后退出 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> $ perf 
record -a -g -p 9 -- sleep 30 </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <p>稍等一会儿，在上述命令结束后，继续执行 <code>perf report</code>命令，你就可以得到 
perf 的汇总报告。按上下方向键以及回车键，展开比例最高的 ksoftirqd 后，你就可以得到下面这个调用关系链图：</p> <p><img src="https://static001.geekbang.org/resource/image/73/01/73f5e9a9e510b9f3bf634c5e94e67801.png" 
alt=""></p> <p>从这个图中，你可以清楚看到 ksoftirqd 执行最多的调用过程。虽然你可能不太熟悉内核源码，但通过这些函数，我们可以大致看出它的调用栈过程。</p> 
<ul> <li> <p>net_rx_action 和 netif_receive_skb，表明这是接收网络包（rx 表示 receive）。</p> </li> <li> <p>br_handle_frame 
，表明网络包经过了网桥（br 表示 bridge）。</p> </li> <li> <p>br_nf_pre_routing ，表明在网桥上执行了 netfilter 的 PREROUTING（nf 
表示 netfilter）。而我们已经知道 PREROUTING 主要用来执行 DNAT，所以可以猜测这里有 DNAT 发生。</p> </li> <li> <p>br_pass_frame_up，表明网桥处理后，再交给桥接的其他桥接网卡进一步处理。比如，在新的网卡上接收网络包、执行 
netfilter 过滤规则等等。</p> </li> </ul> <p>我们的猜测对不对呢？实际上，我们案例最开始用 Docker 启动了容器，而 Docker 会自动为容器创建虚拟网卡、桥接到 
docker0 网桥并配置 NAT 规则。这一过程，如下图所示：</p> <p><img src="https://static001.geekbang.org/resource/image/72/70/72f2f1fa7a464e4465108d4eadcc1b70.png" 
alt=""></p> <p>当然了，前面 perf report 界面的调用链还可以继续展开。但很不幸，我的屏幕不够大，如果展开更多的层级，最后几个层级会超出屏幕范围。这样，即使我们能看到大部分的调用过程，却也不能说明后面层级就没问题。</p> 
<p>那么，有没有更好的方法，来查看整个调用栈的信息呢？</p> <h2>火焰图</h2> <p>针对 perf 汇总数据的展示问题，Brendan Gragg 发明了<a href="http://www.brendangregg.com/flamegraphs.html">火焰图</a>，通过矢量图的形式，更直观展示汇总结果。下图就是一个针对 
mysql 的火焰图示例。</p> <p><img src="https://static001.geekbang.org/resource/image/68/61/68b80d299b23b0cee518001f78960f61.png" 
alt=""></p> <p>（图片来自 Brendan Gregg <a href="http://www.brendangregg.com/flamegraphs.html">博客</a>）</p> 
<p>这张图看起来像是跳动的火焰，因此也就被称为火焰图。要理解火焰图，我们最重要的是区分清楚横轴和纵轴的含义。</p> <ul> <li> <p><strong>横轴表示采样数和采样比例</strong>。一个函数占用的横轴越宽，就代表它的执行时间越长。同一层的多个函数，则是按照字母来排序。</p> 
</li> <li> <p><strong>纵轴表示调用栈</strong>，由下往上根据调用关系逐个展开。换句话说，上下相邻的两个函数中，下面的函数，是上面函数的父函数。这样，调用栈越深，纵轴就越高。</p> 
</li> </ul> <p>另外，要注意图中的颜色，并没有特殊含义，只是用来区分不同的函数。</p> <p>火焰图是动态的矢量图格式，所以它还支持一些动态特性。比如，鼠标悬停到某个函数上时，就会自动显示这个函数的采样数和采样比例。而当你用鼠标点击函数时，火焰图就会把该层及其上的各层放大，方便你观察这些处于火焰图顶部的调用栈的细节。</p> 
<p>上面 mysql 火焰图的示例，就表示了 CPU 的繁忙情况，这种火焰图也被称为 on-CPU 火焰图。如果我们根据性能分析的目标来划分，火焰图可以分为下面这几种。</p> <ul> 
<li> <p><strong>on-CPU 火焰图</strong>：表示 CPU 的繁忙情况，用在 CPU 使用率比较高的场景中。</p> </li> <li> <p><strong>off-CPU 
火焰图</strong>：表示 CPU 等待 I/O、锁等各种资源的阻塞情况。</p> </li> <li> <p><strong>内存火焰图</strong>：表示内存的分配和释放情况。</p> 
</li> <li> <p><strong>热 / 冷火焰图</strong>：表示将 on-CPU 和 off-CPU 结合在一起综合展示。</p> </li> <li> <p><strong>差分火焰图</strong>：表示两个火焰图的差分情况，红色表示增长，蓝色表示衰减。差分火焰图常用来比较不同场景和不同时期的火焰图，以便分析系统变化前后对性能的影响情况。</p> 
</li> </ul> <p>了解了火焰图的含义和查看方法后，接下来，我们再回到案例，运用火焰图来观察刚才 perf record 得到的记录。</p> <h2>火焰图分析</h2> 
<p>首先，我们需要生成火焰图。我们先下载几个能从 perf record 记录生成火焰图的工具，这些工具都放在 <a href="https://github.com/brendangregg/FlameGraph">https://github.com/brendangregg/FlameGraph</a> 
上面。你可以执行下面的命令来下载：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ git clone https://github.com/brendangregg/FlameGraph 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ cd FlameGraph </div></td> </tr> </tbody> 
</table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 </div></pre> 
<p>安装好工具后，要生成火焰图，其实主要需要三个步骤：</p> <ol> <li> <p>执行 perf script ，将 perf record 的记录转换成可读的采样记录；</p> 
</li> <li> <p>执行 stackcollapse-perf.pl 脚本，合并调用栈信息；</p> </li> <li> <p>执行 flamegraph.pl 脚本，生成火焰图。</p> 
</li> </ol> <p>不过，在 Linux 中，我们可以使用管道，来简化这三个步骤的执行过程。假设刚才用 perf record 生成的文件路径为 /root/perf.data，执行下面的命令，你就可以直接生成火焰图：</p> 
<pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> $ perf script -i /root/perf.data | ./stackcollapse-perf.pl --all 
| ./flamegraph.pl &gt; ksoftirqd.svg </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <p>执行成功后，使用浏览器打开 ksoftirqd.svg ，你就可以看到生成的火焰图了。如下图所示：</p> 
<p><img src="https://static001.geekbang.org/resource/image/6d/cd/6d4f1fece12407906aacedf5078e53cd.png" 
alt=""></p> <p>根据刚刚讲过的火焰图原理，这个图应该从下往上看，沿着调用栈中最宽的函数来分析执行次数最多的函数。这儿看到的结果，其实跟刚才的 perf report 类似，但直观了很多，中间这一团火，很明显就是最需要我们关注的地方。</p> 
<p>我们顺着调用栈由下往上看（顺着图中蓝色箭头），就可以得到跟刚才 perf report 中一样的结果：</p> <ul> <li> <p>最开始，还是 net_rx_action 
到 netif_receive_skb 处理网络收包；</p> </li> <li> <p>然后， br_handle_frame 到 br_nf_pre_routing ，在网桥中接收并执行 
netfilter 钩子函数；</p> </li> <li> <p>再向上， br_pass_frame_up 到 netif_receive_skb ，从网桥转到其他网络设备又一次接收。</p> 
</li> </ul> <p>不过最后，到了 ip_forward 这里，已经看不清函数名称了。所以我们需要点击 ip_forward，展开最上面这一块调用栈：</p> <p><img 
src="https://static001.geekbang.org/resource/image/41/a3/416291ba2f9c039a0507f913572a21a3.png" 
alt=""></p> <p>这样，就可以进一步看到 ip_forward 后的行为，也就是把网络包发送出去。根据这个调用过程，再结合我们前面学习的网络收发和 TCP/IP 协议栈原理，这个流程中的网络接收、网桥以及 
netfilter 调用等，都是导致软中断 CPU 升高的重要因素，也就是影响网络性能的潜在瓶颈。</p> <p>不过，回想一下网络收发的流程，你可能会觉得它缺了好多步骤。</p> 
<p>比如，这个堆栈中并没有 TCP 相关的调用，也没有连接跟踪 conntrack 相关的函数。实际上，这些流程都在其他更小的火焰中，你可以点击上图左上角的“Reset Zoom”，回到完整火焰图中，再去查看其他小火焰的堆栈。</p> 
<p>所以，在理解这个调用栈时要注意。从任何一个点出发、纵向来看的整个调用栈，其实只是最顶端那一个函数的调用堆栈，而非完整的内核网络执行流程。</p> <p>另外，整个火焰图不包含任何时间的因素，所以并不能看出横向各个函数的执行次序。</p> 
<p>到这里，我们就找出了内核线程 ksoftirqd 执行最频繁的函数调用堆栈，而这个堆栈中的各层级函数，就是潜在的性能瓶颈来源。这样，后面想要进一步分析、优化时，也就有了根据。</p> 
<h2>小结</h2> <p>今天这个案例，你可能会觉得比较熟悉。实际上，这个案例，正是我们专栏 CPU 模块中的 <a href="https://time.geekbang.org/column/article/72147">软中断案例</a>。</p> 
<p>当时，我们从软中断 CPU 使用率的角度入手，用网络抓包的方法找出了瓶颈来源，确认是测试机器发送的大量 SYN 包导致的。而通过今天的 perf 和火焰图方法，我们进一步找出了软中断内核线程的热点函数，其实也就找出了潜在的瓶颈和优化方向。</p> 
<p>其实，如果遇到的是内核线程的资源使用异常，很多常用的进程级性能工具并不能帮上忙。这时，你就可以用内核自带的 perf 来观察它们的行为，找出热点函数，进一步定位性能瓶。当然，perf 
产生的汇总报告并不够直观，所以我也推荐你用火焰图来协助排查。</p> <p>实际上，火焰图方法同样适用于普通进程。比如，在分析 Nginx、MySQL 等各种应用场景的性能问题时，火焰图也能帮你更快定位热点函数，找出潜在性能问题。</p> 
<h2>思考</h2> <p>最后，我想邀请你一起来聊聊，你碰到过的内核线程性能问题。你是怎么分析它们的根源？又是怎么解决的？你可以结合我的讲述，总结自己的思路。</p> <p>欢迎在留言区和我讨论，也欢迎把这篇文章分享给你的同事、朋友。我们一起在实战中演练，在交流中进步。</p> 
<p></p>', body_summary='', bundle='book', delta=0, body_format='full_html', langcode='zh-hans', 
revision_id=1082 where entity_id=1082 
 {executed in 1 msec}
2020-11-25 10:15:39.131 INFO  jdbc.sqltiming Line:373 - update node_revision__body set body_value='<p>你好，我是倪朋飞。</p> <p>上一期，我们一起梳理了，网络时不时丢包的分析定位和优化方法。先简单回顾一下。</p> 
<p>网络丢包，通常会带来严重的性能下降，特别是对 TCP 来说，丢包通常意味着网络拥塞和重传，进而会导致网络延迟增大以及吞吐量降低。</p> <p>而分析丢包问题，还是用我们的老套路，从 
Linux 网络收发的流程入手，结合 TCP/IP 协议栈的原理来逐层分析。</p> <p>其实，在排查网络问题时，我们还经常碰到的一个问题，就是内核线程的 CPU 使用率很高。比如，在高并发的场景中，内核线程 
ksoftirqd 的 CPU 使用率通常就会比较高。回顾一下前面学过的 CPU 和网络模块，你应该知道，这是网络收发的软中断导致的。</p> <p>而要分析 ksoftirqd 这类 
CPU 使用率比较高的内核线程，如果用我前面介绍过的那些分析方法，你一般需要借助于其他性能工具，进行辅助分析。</p> <p>比如，还是以 ksoftirqd 为例，如果你怀疑是网络问题，就可以用 
sar、tcpdump 等分析网络流量，进一步确认网络问题的根源。</p> <p>不过，显然，这种方法在实际操作中需要步骤比较多，可能并不算快捷。你肯定也很想知道，有没有其他更简单的方法，可以直接观察内核线程的行为，更快定位瓶颈呢？</p> 
<p>今天，我就继续以 ksoftirqd 为例，带你一起看看，如何分析内核线程的性能问题。</p><!-- [[[read_end]]] --> <h2>内核线程</h2> <p>既然要讲内核线程的性能问题，在案例开始之前，我们就先来看看，有哪些常见的内核线程。</p> 
<p>我们知道，在 Linux 中，用户态进程的“祖先”，都是 PID 号为 1 的 init 进程。比如，现在主流的 Linux 发行版中，init 都是 systemd 进程；而其他的用户态进程，会通过 
systemd 来进行管理。</p> <p>稍微想一下 Linux 中的各种进程，除了用户态进程外，还有大量的内核态线程。按说内核态的线程，应该先于用户态进程启动，可是 systemd 
只管理用户态进程。那么，内核态线程又是谁来管理的呢？</p> <p>实际上，Linux 在启动过程中，有三个特殊的进程，也就是 PID 号最小的三个进程。</p> <ul> <li> 
<p>0 号进程为 idle 进程，这也是系统创建的第一个进程，它在初始化 1 号和 2 号进程后，演变为空闲任务。当 CPU 上没有其他任务执行时，就会运行它。</p> </li> 
<li> <p>1 号进程为 init 进程，通常是 systemd 进程，在用户态运行，用来管理其他用户态进程。</p> </li> <li> <p>2 号进程为 kthreadd 
进程，在内核态运行，用来管理内核线程。</p> </li> </ul> <p>所以，要查找内核线程，我们只需要从 2 号进程开始，查找它的子孙进程即可。比如，你可以使用 ps 命令，来查找 
kthreadd 的子进程：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ ps -f --ppid 2 -p 2 </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> UID PID PPID C STIME TTY TIME CMD </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> root 2 0 0 12:02 ? 00:00:01 [kthreadd] 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> root 9 2 0 12:02 ? 00:00:21 [ksoftirqd/0] 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> root 10 2 0 12:02 ? 00:11:47 [rcu_sched] 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> root 11 2 0 12:02 ? 00:00:18 [migration/0] 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> ... </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> root 11094 2 0 14:20 ? 00:00:00 [kworker/1:0-eve] </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> root 11647 2 0 14:27 ? 00:00:00 [kworker/0:2-cgr] 
</div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>从上面的输出，你能够看到，内核线程的名称（CMD）都在中括号里（这一点，我们前面内容也有提到过）。所以，更简单的方法，就是直接查找名称包含中括号的进程。比如：</p> 
<pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> $ ps -ef | grep "\[.*\]" </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> root 2 0 0 08:14 ? 00:00:00 [kthreadd] </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> root 3 2 0 08:14 ? 00:00:00 [rcu_gp] </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> root 4 2 0 08:14 ? 00:00:00 [rcu_par_gp] 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> ... </div></td> </tr> </tbody> </table></code> 
<div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 </div></pre> <p>了解内核线程的基本功能，对我们排查问题有非常大的帮助。比如，我们曾经在软中断案例中提到过 
ksoftirqd。它是一个用来处理软中断的内核线程，并且每个 CPU 上都有一个。</p> <p>如果你知道了这一点，那么，以后遇到 ksoftirqd 的 CPU 使用高的情况，就会首先怀疑是软中断的问题，然后从软中断的角度来进一步分析。</p> 
<p>其实，除了刚才看到的 kthreadd 和 ksoftirqd 外，还有很多常见的内核线程，我们在性能分析中都经常会碰到，比如下面这几个内核线程。</p> <ul> <li> 
<p><strong>kswapd0</strong>：用于内存回收。在 <a href="https://time.geekbang.org/column/article/75797">Swap 
变高</a> 案例中，我曾介绍过它的工作原理。</p> </li> <li> <p><strong>kworker</strong>：用于执行内核工作队列，分为绑定 CPU （名称格式为 
kworker/CPU86330）和未绑定 CPU（名称格式为 kworker/uPOOL86330）两类。</p> </li> <li> <p><strong>migration</strong>：在负载均衡过程中，把进程迁移到 
CPU 上。每个 CPU 都有一个 migration 内核线程。</p> </li> <li> <p><strong>jbd2</strong>/sda1-8：jbd 是 Journaling 
Block Device 的缩写，用来为文件系统提供日志功能，以保证数据的完整性；名称中的 sda1-8，表示磁盘分区名称和设备号。每个使用了 ext4 文件系统的磁盘分区，都会有一个 
jbd2 内核线程。</p> </li> <li> <p><strong>pdflush</strong>：用于将内存中的脏页（被修改过，但还未写入磁盘的文件页）写入磁盘（已经在 3.10 
中合并入了 kworker 中）。</p> </li> </ul> <p>了解这几个容易发生性能问题的内核线程，有助于我们更快地定位性能瓶颈。接下来，我们来看今天的案例。</p> <h2>案例准备</h2> 
<p>今天的案例还是基于 Ubuntu 18.04，同样适用于其他的 Linux 系统。我使用的案例环境如下所示：</p> <ul> <li> <p>机器配置：2 CPU，8GB 内存。</p> 
</li> <li> <p>预先安装 docker、perf、hping3、curl 等工具，如 apt install docker.io linux-tools-common hping3。</p> 
</li> </ul> <p>本次案例用到两台虚拟机，我画了一张图来表示它们的关系。</p> <p><img src="https://static001.geekbang.org/resource/image/7d/11/7dd0763a14713940e7c762a62387dd11.png" 
alt=""></p> <p>你需要打开两个终端，分别登录这两台虚拟机中，并安装上述工具。</p> <p>注意，以下所有命令都默认以 root 用户运行，如果你用普通用户身份登陆系统，请运行 
sudo su root 命令，切换到 root 用户。</p> <blockquote> <p>如果安装过程有问题，你可以先上网搜索解决，实在解决不了的，记得在留言区向我提问。</p> 
</blockquote> <p>到这里，准备工作就完成了。接下来，我们正式进入操作环节。</p> <h2>案例分析</h2> <p>安装完成后，我们先在第一个终端，执行下面的命令运行案例，也就是一个最基本的 
Nginx 应用：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> <tr> 
<td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> # 运行 Nginx 服务并对外开放 80 端口 </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ docker run -itd --name=nginx -p 80:80 
nginx </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>然后，在第二个终端，使用 curl 访问 Nginx 监听的端口，确认 Nginx 正常启动。假设 192.168.0.30 是 Nginx 所在虚拟机的 
IP 地址，运行 curl 命令后，你应该会看到下面这个输出界面：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> 
<tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ curl http://192.168.0.30/ </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> &lt;!DOCTYPE html&gt; </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> &lt;html&gt; </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> &lt;head&gt; </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> &lt;title&gt;Welcome to nginx!&lt;/title&gt; 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> ... </div></td> </tr> </tbody> </table></code> 
<div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 </div></pre> <p>接着，还是在第二个终端中，运行 
hping3 命令，模拟 Nginx 的客户端请求：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> 
<tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> # -S 参数表示设置 TCP 协议的 SYN（同步序列号），-p 表示目的端口为 
80 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> # -i 
u10 表示每隔 10 微秒发送一个网络帧 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
# 注：如果你在实践过程中现象不明显，可以尝试把 10 调小，比如调成 5 甚至 1 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> $ hping3 -S -p 80 -i u10 192.168.0.30 </div></td> </tr> </tbody> 
</table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 </div></pre> 
<p>现在，我们再回到第一个终端，你应该就会发现异常——系统的响应明显变慢了。我们不妨执行 top，观察一下系统和进程的 CPU 使用情况：</p> <pre style="position: 
relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
$ top </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> top - 
08:31:43 up 17 min, 1 user, load average: 0.00, 0.00, 0.02 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> Tasks: 128 total, 1 running, 69 sleeping, 0 stopped, 0 zombie </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> %Cpu0 : 0.3 us, 0.3 sy, 0.0 ni, 66.8 id, 
0.3 wa, 0.0 hi, 32.4 si, 0.0 st </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="5"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
%Cpu1 : 0.0 us, 0.3 sy, 0.0 ni, 65.2 id, 0.0 wa, 0.0 hi, 34.5 si, 0.0 st </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> KiB Mem : 8167040 total, 7234236 free, 
358976 used, 573828 buff/cache </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="7"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
KiB Swap: 0 total, 0 free, 0 used. 7560460 avail Mem </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="9"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 9 root 20 0 0 0 0 S 7.0 0.0 0:00.48 ksoftirqd/0 </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 18 root 20 0 0 0 0 S 6.9 0.0 0:00.56 ksoftirqd/1 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 2489 root 20 0 876896 38408 21520 S 0.3 
0.5 0:01.50 docker-containe </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="13"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
3008 root 20 0 44536 3936 3304 R 0.3 0.0 0:00.09 top </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="14"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 1 root 20 0 78116 9000 6432 S 0.0 0.1 0:11.77 systemd </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="15"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> ... </div></td> </tr> </tbody> </table></code> 
<div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 </div></pre> <p>从 top 
的输出中，你可以看到，两个 CPU 的软中断使用率都超过了 30%；而 CPU 使用率最高的进程，正好是软中断内核线程 ksoftirqd/0 和 ksoftirqd/1。</p> 
<p>虽然，我们已经知道了 ksoftirqd 的基本功能，可以猜测是因为大量网络收发，引起了 CPU 使用率升高；但它到底在执行什么逻辑，我们却并不知道。</p> <p>对于普通进程，我们要观察其行为有很多方法，比如 
strace、pstack、lsof 等等。但这些工具并不适合内核线程，比如，如果你用 pstack ，或者通过 /proc/pid/stack 查看 ksoftirqd/0（进程号为 
9）的调用栈时，分别可以得到以下输出：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ pstack 9 </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> Could not attach to target 9: Operation 
not permitted. </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
detach: No such process </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <pre style="position: relative;"><code> <table 
class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> $ cat 
/proc/9/stack </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
[&lt;0&gt;] smpboot_thread_fn+0x166/0x170 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> [&lt;0&gt;] kthread+0x121/0x140 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> [&lt;0&gt;] ret_from_fork+0x35/0x40 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> [&lt;0&gt;] 0xffffffffffffffff </div></td> </tr> </tbody> </table></code> 
<div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 </div></pre> <p>显然，pstack 
报出的是不允许挂载进程的错误；而 /proc/9/stack 方式虽然有输出，但输出中并没有详细的调用栈情况。</p> <p>那还有没有其他方法，来观察内核线程 ksoftirqd 
的行为呢？</p> <p>既然是内核线程，自然应该用到内核中提供的机制。回顾一下我们之前用过的 CPU 性能工具，我想你肯定还记得 perf ，这个内核自带的性能剖析工具。</p> 
<p>perf 可以对指定的进程或者事件进行采样，并且还可以用调用栈的形式，输出整个调用链上的汇总信息。 我们不妨就用 perf ，来试着分析一下进程号为 9 的 ksoftirqd。</p> 
<p>继续在终端一中，执行下面的 perf record 命令；并指定进程号 9 ，以便记录 ksoftirqd 的行为:</p> <pre style="position: relative;"><code> 
<table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
# 采样 30s 后退出 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> $ perf 
record -a -g -p 9 -- sleep 30 </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <p>稍等一会儿，在上述命令结束后，继续执行 <code>perf report</code>命令，你就可以得到 
perf 的汇总报告。按上下方向键以及回车键，展开比例最高的 ksoftirqd 后，你就可以得到下面这个调用关系链图：</p> <p><img src="https://static001.geekbang.org/resource/image/73/01/73f5e9a9e510b9f3bf634c5e94e67801.png" 
alt=""></p> <p>从这个图中，你可以清楚看到 ksoftirqd 执行最多的调用过程。虽然你可能不太熟悉内核源码，但通过这些函数，我们可以大致看出它的调用栈过程。</p> 
<ul> <li> <p>net_rx_action 和 netif_receive_skb，表明这是接收网络包（rx 表示 receive）。</p> </li> <li> <p>br_handle_frame 
，表明网络包经过了网桥（br 表示 bridge）。</p> </li> <li> <p>br_nf_pre_routing ，表明在网桥上执行了 netfilter 的 PREROUTING（nf 
表示 netfilter）。而我们已经知道 PREROUTING 主要用来执行 DNAT，所以可以猜测这里有 DNAT 发生。</p> </li> <li> <p>br_pass_frame_up，表明网桥处理后，再交给桥接的其他桥接网卡进一步处理。比如，在新的网卡上接收网络包、执行 
netfilter 过滤规则等等。</p> </li> </ul> <p>我们的猜测对不对呢？实际上，我们案例最开始用 Docker 启动了容器，而 Docker 会自动为容器创建虚拟网卡、桥接到 
docker0 网桥并配置 NAT 规则。这一过程，如下图所示：</p> <p><img src="https://static001.geekbang.org/resource/image/72/70/72f2f1fa7a464e4465108d4eadcc1b70.png" 
alt=""></p> <p>当然了，前面 perf report 界面的调用链还可以继续展开。但很不幸，我的屏幕不够大，如果展开更多的层级，最后几个层级会超出屏幕范围。这样，即使我们能看到大部分的调用过程，却也不能说明后面层级就没问题。</p> 
<p>那么，有没有更好的方法，来查看整个调用栈的信息呢？</p> <h2>火焰图</h2> <p>针对 perf 汇总数据的展示问题，Brendan Gragg 发明了<a href="http://www.brendangregg.com/flamegraphs.html">火焰图</a>，通过矢量图的形式，更直观展示汇总结果。下图就是一个针对 
mysql 的火焰图示例。</p> <p><img src="https://static001.geekbang.org/resource/image/68/61/68b80d299b23b0cee518001f78960f61.png" 
alt=""></p> <p>（图片来自 Brendan Gregg <a href="http://www.brendangregg.com/flamegraphs.html">博客</a>）</p> 
<p>这张图看起来像是跳动的火焰，因此也就被称为火焰图。要理解火焰图，我们最重要的是区分清楚横轴和纵轴的含义。</p> <ul> <li> <p><strong>横轴表示采样数和采样比例</strong>。一个函数占用的横轴越宽，就代表它的执行时间越长。同一层的多个函数，则是按照字母来排序。</p> 
</li> <li> <p><strong>纵轴表示调用栈</strong>，由下往上根据调用关系逐个展开。换句话说，上下相邻的两个函数中，下面的函数，是上面函数的父函数。这样，调用栈越深，纵轴就越高。</p> 
</li> </ul> <p>另外，要注意图中的颜色，并没有特殊含义，只是用来区分不同的函数。</p> <p>火焰图是动态的矢量图格式，所以它还支持一些动态特性。比如，鼠标悬停到某个函数上时，就会自动显示这个函数的采样数和采样比例。而当你用鼠标点击函数时，火焰图就会把该层及其上的各层放大，方便你观察这些处于火焰图顶部的调用栈的细节。</p> 
<p>上面 mysql 火焰图的示例，就表示了 CPU 的繁忙情况，这种火焰图也被称为 on-CPU 火焰图。如果我们根据性能分析的目标来划分，火焰图可以分为下面这几种。</p> <ul> 
<li> <p><strong>on-CPU 火焰图</strong>：表示 CPU 的繁忙情况，用在 CPU 使用率比较高的场景中。</p> </li> <li> <p><strong>off-CPU 
火焰图</strong>：表示 CPU 等待 I/O、锁等各种资源的阻塞情况。</p> </li> <li> <p><strong>内存火焰图</strong>：表示内存的分配和释放情况。</p> 
</li> <li> <p><strong>热 / 冷火焰图</strong>：表示将 on-CPU 和 off-CPU 结合在一起综合展示。</p> </li> <li> <p><strong>差分火焰图</strong>：表示两个火焰图的差分情况，红色表示增长，蓝色表示衰减。差分火焰图常用来比较不同场景和不同时期的火焰图，以便分析系统变化前后对性能的影响情况。</p> 
</li> </ul> <p>了解了火焰图的含义和查看方法后，接下来，我们再回到案例，运用火焰图来观察刚才 perf record 得到的记录。</p> <h2>火焰图分析</h2> 
<p>首先，我们需要生成火焰图。我们先下载几个能从 perf record 记录生成火焰图的工具，这些工具都放在 <a href="https://github.com/brendangregg/FlameGraph">https://github.com/brendangregg/FlameGraph</a> 
上面。你可以执行下面的命令来下载：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ git clone https://github.com/brendangregg/FlameGraph 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ cd FlameGraph </div></td> </tr> </tbody> 
</table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 </div></pre> 
<p>安装好工具后，要生成火焰图，其实主要需要三个步骤：</p> <ol> <li> <p>执行 perf script ，将 perf record 的记录转换成可读的采样记录；</p> 
</li> <li> <p>执行 stackcollapse-perf.pl 脚本，合并调用栈信息；</p> </li> <li> <p>执行 flamegraph.pl 脚本，生成火焰图。</p> 
</li> </ol> <p>不过，在 Linux 中，我们可以使用管道，来简化这三个步骤的执行过程。假设刚才用 perf record 生成的文件路径为 /root/perf.data，执行下面的命令，你就可以直接生成火焰图：</p> 
<pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> $ perf script -i /root/perf.data | ./stackcollapse-perf.pl --all 
| ./flamegraph.pl &gt; ksoftirqd.svg </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <p>执行成功后，使用浏览器打开 ksoftirqd.svg ，你就可以看到生成的火焰图了。如下图所示：</p> 
<p><img src="https://static001.geekbang.org/resource/image/6d/cd/6d4f1fece12407906aacedf5078e53cd.png" 
alt=""></p> <p>根据刚刚讲过的火焰图原理，这个图应该从下往上看，沿着调用栈中最宽的函数来分析执行次数最多的函数。这儿看到的结果，其实跟刚才的 perf report 类似，但直观了很多，中间这一团火，很明显就是最需要我们关注的地方。</p> 
<p>我们顺着调用栈由下往上看（顺着图中蓝色箭头），就可以得到跟刚才 perf report 中一样的结果：</p> <ul> <li> <p>最开始，还是 net_rx_action 
到 netif_receive_skb 处理网络收包；</p> </li> <li> <p>然后， br_handle_frame 到 br_nf_pre_routing ，在网桥中接收并执行 
netfilter 钩子函数；</p> </li> <li> <p>再向上， br_pass_frame_up 到 netif_receive_skb ，从网桥转到其他网络设备又一次接收。</p> 
</li> </ul> <p>不过最后，到了 ip_forward 这里，已经看不清函数名称了。所以我们需要点击 ip_forward，展开最上面这一块调用栈：</p> <p><img 
src="https://static001.geekbang.org/resource/image/41/a3/416291ba2f9c039a0507f913572a21a3.png" 
alt=""></p> <p>这样，就可以进一步看到 ip_forward 后的行为，也就是把网络包发送出去。根据这个调用过程，再结合我们前面学习的网络收发和 TCP/IP 协议栈原理，这个流程中的网络接收、网桥以及 
netfilter 调用等，都是导致软中断 CPU 升高的重要因素，也就是影响网络性能的潜在瓶颈。</p> <p>不过，回想一下网络收发的流程，你可能会觉得它缺了好多步骤。</p> 
<p>比如，这个堆栈中并没有 TCP 相关的调用，也没有连接跟踪 conntrack 相关的函数。实际上，这些流程都在其他更小的火焰中，你可以点击上图左上角的“Reset Zoom”，回到完整火焰图中，再去查看其他小火焰的堆栈。</p> 
<p>所以，在理解这个调用栈时要注意。从任何一个点出发、纵向来看的整个调用栈，其实只是最顶端那一个函数的调用堆栈，而非完整的内核网络执行流程。</p> <p>另外，整个火焰图不包含任何时间的因素，所以并不能看出横向各个函数的执行次序。</p> 
<p>到这里，我们就找出了内核线程 ksoftirqd 执行最频繁的函数调用堆栈，而这个堆栈中的各层级函数，就是潜在的性能瓶颈来源。这样，后面想要进一步分析、优化时，也就有了根据。</p> 
<h2>小结</h2> <p>今天这个案例，你可能会觉得比较熟悉。实际上，这个案例，正是我们专栏 CPU 模块中的 <a href="https://time.geekbang.org/column/article/72147">软中断案例</a>。</p> 
<p>当时，我们从软中断 CPU 使用率的角度入手，用网络抓包的方法找出了瓶颈来源，确认是测试机器发送的大量 SYN 包导致的。而通过今天的 perf 和火焰图方法，我们进一步找出了软中断内核线程的热点函数，其实也就找出了潜在的瓶颈和优化方向。</p> 
<p>其实，如果遇到的是内核线程的资源使用异常，很多常用的进程级性能工具并不能帮上忙。这时，你就可以用内核自带的 perf 来观察它们的行为，找出热点函数，进一步定位性能瓶。当然，perf 
产生的汇总报告并不够直观，所以我也推荐你用火焰图来协助排查。</p> <p>实际上，火焰图方法同样适用于普通进程。比如，在分析 Nginx、MySQL 等各种应用场景的性能问题时，火焰图也能帮你更快定位热点函数，找出潜在性能问题。</p> 
<h2>思考</h2> <p>最后，我想邀请你一起来聊聊，你碰到过的内核线程性能问题。你是怎么分析它们的根源？又是怎么解决的？你可以结合我的讲述，总结自己的思路。</p> <p>欢迎在留言区和我讨论，也欢迎把这篇文章分享给你的同事、朋友。我们一起在实战中演练，在交流中进步。</p> 
<p></p>', body_summary='', bundle='book', delta=0, body_format='full_html', langcode='zh-hans', 
revision_id=1082 where entity_id=1082 
 {executed in 1 msec}
2020-11-25 10:15:39.136 INFO  jdbc.sqltiming Line:373 - select nodefiledd0_.nid as nid1_10_, nodefiledd0_.changed as changed2_10_, nodefiledd0_.created 
as created3_10_, nodefiledd0_.default_langcode as default_4_10_, nodefiledd0_.langcode as langcode5_10_, 
nodefiledd0_.promote as promote6_10_, nodefiledd0_.revision_translation_affected as revision7_10_, 
nodefiledd0_.status as status8_10_, nodefiledd0_.sticky as sticky9_10_, nodefiledd0_.title 
as title10_10_, nodefiledd0_.type as type11_10_, nodefiledd0_.uid as uid12_10_, nodefiledd0_.vid 
as vid13_10_ from node_field_data nodefiledd0_ where nodefiledd0_.nid=1082 
 {executed in 0 msec}
2020-11-25 10:15:39.137 INFO  jdbc.resultsettable Line:610 - 
|-----|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|---------------------------|-----|----|-----|
|nid  |changed    |created    |default_langcode |langcode |promote |revision_translation_affected |status |sticky |title                      |type |uid |vid  |
|-----|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|---------------------------|-----|----|-----|
|1082 |1606114981 |1606114981 |1                |zh-hans  |0       |1                             |1      |0      |49丨案例篇：内核线程CPU利用率太高，我该怎么办？ |book |1   |1082 |
|-----|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|---------------------------|-----|----|-----|

2020-11-25 10:15:39.138 INFO  jdbc.sqltiming Line:373 - select nodefieldr0_.nid as nid1_11_0_, nodefieldr0_.changed as changed2_11_0_, nodefieldr0_.created 
as created3_11_0_, nodefieldr0_.default_langcode as default_4_11_0_, nodefieldr0_.langcode 
as langcode5_11_0_, nodefieldr0_.promote as promote6_11_0_, nodefieldr0_.revision_translation_affected 
as revision7_11_0_, nodefieldr0_.status as status8_11_0_, nodefieldr0_.sticky as sticky9_11_0_, 
nodefieldr0_.title as title10_11_0_, nodefieldr0_.uid as uid11_11_0_, nodefieldr0_.vid as vid12_11_0_ 
from node_field_revision nodefieldr0_ where nodefieldr0_.nid=1082 
 {executed in 0 msec}
2020-11-25 10:15:39.138 INFO  jdbc.resultsettable Line:610 - 
|---------|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|---------------------------|----|-----|
|nid      |changed    |created    |default_langcode |langcode |promote |revision_translation_affected |status |sticky |title                      |uid |vid  |
|---------|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|---------------------------|----|-----|
|[unread] |1606114981 |1606114981 |1                |zh-hans  |0       |1                             |1      |0      |49丨案例篇：内核线程CPU利用率太高，我该怎么办？ |1   |1082 |
|---------|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|---------------------------|----|-----|

2020-11-25 10:15:39.140 INFO  jdbc.sqltiming Line:373 - update node_field_data set changed=1606270539, created=1606270539, default_langcode=1, langcode='zh-hans', 
promote=0, revision_translation_affected=1, status=1, sticky=0, title='49丨案例篇：内核线程CPU利用率太高，我该怎么办？', 
type='book', uid=1, vid=1082 where nid=1082 
 {executed in 0 msec}
2020-11-25 10:15:39.140 INFO  jdbc.sqltiming Line:373 - update node_field_revision set changed=1606270539, created=1606270539, default_langcode=1, 
langcode='zh-hans', promote=0, revision_translation_affected=1, status=1, sticky=0, title='49丨案例篇：内核线程CPU利用率太高，我该怎么办？', 
uid=1, vid=1082 where nid=1082 
 {executed in 0 msec}
2020-11-25 10:15:39.145 INFO  jdbc.sqltiming Line:373 - select bookfieldm0_.entity_id as entity_i1_8_, bookfieldm0_.bundle as bundle2_8_, bookfieldm0_.delta 
as delta3_8_, bookfieldm0_.langcode as langcode4_8_, bookfieldm0_.field_media_value as field_me5_8_, 
bookfieldm0_.revision_id as revision6_8_ from node__field_media bookfieldm0_ where bookfieldm0_.entity_id=1082 
 {executed in 1 msec}
2020-11-25 10:15:39.145 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------------|------------|
|entity_id |bundle |delta |langcode |field_media_value |revision_id |
|----------|-------|------|---------|------------------|------------|
|1082      |book   |0     |zh-hans  |                  |1082        |
|----------|-------|------|---------|------------------|------------|

2020-11-25 10:15:39.147 INFO  jdbc.sqltiming Line:373 - select nodefieldm0_.entity_id as entity_i1_17_0_, nodefieldm0_.bundle as bundle2_17_0_, nodefieldm0_.delta 
as delta3_17_0_, nodefieldm0_.langcode as langcode4_17_0_, nodefieldm0_.field_media_value as 
field_me5_17_0_, nodefieldm0_.revision_id as revision6_17_0_ from node_revision__field_media 
nodefieldm0_ where nodefieldm0_.entity_id=1082 
 {executed in 0 msec}
2020-11-25 10:15:39.147 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------------|------------|
|entity_id |bundle |delta |langcode |field_media_value |revision_id |
|----------|-------|------|---------|------------------|------------|
|[unread]  |book   |0     |zh-hans  |                  |1082        |
|----------|-------|------|---------|------------------|------------|

2020-11-25 10:15:39.148 INFO  jdbc.sqltiming Line:373 - select bookfieldc0_.entity_id as entity_i1_5_, bookfieldc0_.bundle as bundle2_5_, bookfieldc0_.field_comment_value 
as field_co3_5_, bookfieldc0_.delta as delta4_5_, bookfieldc0_.field_comment_format as field_co5_5_, 
bookfieldc0_.langcode as langcode6_5_, bookfieldc0_.revision_id as revision7_5_ from node__field_comment 
bookfieldc0_ where bookfieldc0_.entity_id=1082 
 {executed in 0 msec}
2020-11-25 10:15:39.149 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|--------------------|------|---------------------|---------|------------|
|entity_id |bundle |field_comment_value |delta |field_comment_format |langcode |revision_id |
|----------|-------|--------------------|------|---------------------|---------|------------|
|1082      |book   |                    |0     |full_html            |zh-hans  |1082        |
|----------|-------|--------------------|------|---------------------|---------|------------|

2020-11-25 10:15:39.150 INFO  jdbc.sqltiming Line:373 - select nodefieldc0_.entity_id as entity_i1_14_0_, nodefieldc0_.bundle as bundle2_14_0_, nodefieldc0_.field_comment_value 
as field_co3_14_0_, nodefieldc0_.delta as delta4_14_0_, nodefieldc0_.field_comment_format as 
field_co5_14_0_, nodefieldc0_.langcode as langcode6_14_0_, nodefieldc0_.revision_id as revision7_14_0_ 
from node_revision__field_comment nodefieldc0_ where nodefieldc0_.entity_id=1082 
 {executed in 0 msec}
2020-11-25 10:15:39.151 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|--------------------|------|---------------------|---------|------------|
|entity_id |bundle |field_comment_value |delta |field_comment_format |langcode |revision_id |
|----------|-------|--------------------|------|---------------------|---------|------------|
|[unread]  |book   |                    |0     |full_html            |zh-hans  |1082        |
|----------|-------|--------------------|------|---------------------|---------|------------|

2020-11-25 10:15:39.152 INFO  jdbc.sqltiming Line:373 - select bookfieldt0_.entity_id as entity_i1_9_, bookfieldt0_.bundle as bundle2_9_, bookfieldt0_.delta 
as delta3_9_, bookfieldt0_.langcode as langcode4_9_, bookfieldt0_.revision_id as revision5_9_, 
bookfieldt0_.field_thumb_value as field_th6_9_ from node__field_thumb bookfieldt0_ where bookfieldt0_.entity_id=1082 
 {executed in 0 msec}
2020-11-25 10:15:39.153 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------|------------------|
|entity_id |bundle |delta |langcode |revision_id |field_thumb_value |
|----------|-------|------|---------|------------|------------------|
|1082      |book   |0     |zh-hans  |1082        |                  |
|----------|-------|------|---------|------------|------------------|

2020-11-25 10:15:39.154 INFO  jdbc.sqltiming Line:373 - update node__field_thumb set bundle='book', delta=0, langcode='zh-hans', revision_id=1082, 
field_thumb_value='https://static001.geekbang.org/resource/image/70/64/7008393b944dcc90d25cce9a2e63cb64.jpg' 
where entity_id=1082 
 {executed in 0 msec}
2020-11-25 10:15:39.158 INFO  jdbc.sqltiming Line:373 - select nodefieldt0_.entity_id as entity_i1_18_0_, nodefieldt0_.bundle as bundle2_18_0_, nodefieldt0_.delta 
as delta3_18_0_, nodefieldt0_.langcode as langcode4_18_0_, nodefieldt0_.revision_id as revision5_18_0_, 
nodefieldt0_.field_thumb_value as field_th6_18_0_ from node_revision__field_thumb nodefieldt0_ 
where nodefieldt0_.entity_id=1082 
 {executed in 0 msec}
2020-11-25 10:15:39.158 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------|------------------|
|entity_id |bundle |delta |langcode |revision_id |field_thumb_value |
|----------|-------|------|---------|------------|------------------|
|[unread]  |book   |0     |zh-hans  |1082        |                  |
|----------|-------|------|---------|------------|------------------|

2020-11-25 10:15:39.159 INFO  jdbc.sqltiming Line:373 - update node_revision__field_thumb set bundle='book', delta=0, langcode='zh-hans', revision_id=1082, 
field_thumb_value='https://static001.geekbang.org/resource/image/70/64/7008393b944dcc90d25cce9a2e63cb64.jpg' 
where entity_id=1082 
 {executed in 0 msec}
2020-11-25 10:15:39.163 INFO  jdbc.sqltiming Line:373 - select bookfieldf0_.entity_id as entity_i1_6_0_, bookfieldf0_.bundle as bundle2_6_0_, bookfieldf0_.delta 
as delta3_6_0_, bookfieldf0_.field_fenlei_target_id as field_fe4_6_0_, bookfieldf0_.langcode 
as langcode5_6_0_, bookfieldf0_.revision_id as revision6_6_0_ from node__field_fenlei bookfieldf0_ 
where bookfieldf0_.entity_id=1082 
 {executed in 0 msec}
2020-11-25 10:15:39.163 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|-----------------------|---------|------------|
|entity_id |bundle |delta |field_fenlei_target_id |langcode |revision_id |
|----------|-------|------|-----------------------|---------|------------|
|[unread]  |book   |0     |1                      |zh-hans  |1082        |
|----------|-------|------|-----------------------|---------|------------|

2020-11-25 10:15:39.165 INFO  jdbc.sqltiming Line:373 - select nodefieldf0_.entity_id as entity_i1_15_0_, nodefieldf0_.bundle as bundle2_15_0_, nodefieldf0_.delta 
as delta3_15_0_, nodefieldf0_.field_fenlei_target_id as field_fe4_15_0_, nodefieldf0_.langcode 
as langcode5_15_0_, nodefieldf0_.revision_id as revision6_15_0_ from node_revision__field_fenlei 
nodefieldf0_ where nodefieldf0_.entity_id=1082 
 {executed in 0 msec}
2020-11-25 10:15:39.165 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|-----------------------|---------|------------|
|entity_id |bundle |delta |field_fenlei_target_id |langcode |revision_id |
|----------|-------|------|-----------------------|---------|------------|
|[unread]  |book   |0     |1                      |zh-hans  |1082        |
|----------|-------|------|-----------------------|---------|------------|

2020-11-25 10:15:39.167 INFO  jdbc.sqltiming Line:373 - select bookchecke0_.item_id as item_id1_2_, bookchecke0_.fsid as fsid2_2_, bookchecke0_.got 
as got3_2_, bookchecke0_.name as name4_2_, bookchecke0_.parse_fail as parse_fa5_2_, bookchecke0_.parsed 
as parsed6_2_, bookchecke0_.path as path7_2_, bookchecke0_.title as title8_2_, bookchecke0_.vid 
as vid9_2_ from book_check bookchecke0_ where bookchecke0_.fsid='974773883790250' and bookchecke0_.name='net_content' 
 {executed in 0 msec}
2020-11-25 10:15:39.167 INFO  jdbc.resultsettable Line:610 - 
|--------|---------|---------|---------|-----------|---------|---------|---------|---------|
|item_id |fsid     |got      |name     |parse_fail |parsed   |path     |title    |vid      |
|--------|---------|---------|---------|-----------|---------|---------|---------|---------|
|1083    |[unread] |[unread] |[unread] |[unread]   |[unread] |[unread] |[unread] |[unread] |
|--------|---------|---------|---------|-----------|---------|---------|---------|---------|

2020-11-25 10:16:52.920 INFO  jdbc.sqltiming Line:373 - update book_check set fsid='974773883790250', got=1, name='net_content', parse_fail='', parsed=1, 
path='12-Linux性能优化实战/06-综合实战篇 (13讲)/50丨案例篇：动态追踪怎么用？（上）.html', title='50丨案例篇：动态追踪怎么用？（上）', vid=1083 
where item_id=1083 
 {executed in 0 msec}
2020-11-25 10:16:52.927 INFO  jdbc.sqltiming Line:373 - select nodebodyen0_.entity_id as entity_i1_4_, nodebodyen0_.body_value as body_val2_4_, nodebodyen0_.body_summary 
as body_sum3_4_, nodebodyen0_.bundle as bundle4_4_, nodebodyen0_.delta as delta5_4_, nodebodyen0_.body_format 
as body_for6_4_, nodebodyen0_.langcode as langcode7_4_, nodebodyen0_.revision_id as revision8_4_ 
from node__body nodebodyen0_ where nodebodyen0_.entity_id=1083 
 {executed in 0 msec}
2020-11-25 10:16:52.928 INFO  jdbc.resultsettable Line:610 - 
|----------|-----------|-------------|-------|------|------------|---------|------------|
|entity_id |body_value |body_summary |bundle |delta |body_format |langcode |revision_id |
|----------|-----------|-------------|-------|------|------------|---------|------------|
|1083      |           |             |book   |0     |full_html   |zh-hans  |1083        |
|----------|-----------|-------------|-------|------|------------|---------|------------|

2020-11-25 10:16:52.929 INFO  jdbc.sqltiming Line:373 - select nodebodyre0_.entity_id as entity_i1_13_0_, nodebodyre0_.body_value as body_val2_13_0_, 
nodebodyre0_.body_summary as body_sum3_13_0_, nodebodyre0_.bundle as bundle4_13_0_, nodebodyre0_.delta 
as delta5_13_0_, nodebodyre0_.body_format as body_for6_13_0_, nodebodyre0_.langcode as langcode7_13_0_, 
nodebodyre0_.revision_id as revision8_13_0_ from node_revision__body nodebodyre0_ where nodebodyre0_.entity_id=1083 
 {executed in 1 msec}
2020-11-25 10:16:52.929 INFO  jdbc.resultsettable Line:610 - 
|----------|-----------|-------------|-------|------|------------|---------|------------|
|entity_id |body_value |body_summary |bundle |delta |body_format |langcode |revision_id |
|----------|-----------|-------------|-------|------|------------|---------|------------|
|[unread]  |           |             |book   |0     |full_html   |zh-hans  |1083        |
|----------|-----------|-------------|-------|------|------------|---------|------------|

2020-11-25 10:16:52.931 INFO  jdbc.sqltiming Line:373 - update node__body set body_value='<p>你好，我是倪朋飞。</p> <p>上一节，我以 ksoftirqd CPU 使用率高的问题为例，带你一起学习了内核线程 
CPU 使用率高时的分析方法。先简单回顾一下。</p> <p>当碰到内核线程的资源使用异常时，很多常用的进程级性能工具，并不能直接用到内核线程上。这时，我们就可以使用内核自带的 perf 
来观察它们的行为，找出热点函数，进一步定位性能瓶颈。不过，perf 产生的汇总报告并不直观，所以我通常也推荐用火焰图来协助排查。</p> <p>其实，使用 perf 对系统内核线程进行分析时，内核线程依然还在正常运行中，所以这种方法也被称为动态追踪技术。</p> 
<p><strong>动态追踪技术，通过探针机制，来采集内核或者应用程序的运行信息，从而可以不用修改内核和应用程序的代码，就获得丰富的信息，帮你分析、定位想要排查的问题。</strong></p> 
<p>以往，在排查和调试性能问题时，我们往往需要先为应用程序设置一系列的断点（比如使用 GDB），然后以手动或者脚本（比如 GDB 的 Python 扩展）的方式，在这些断点处分析应用程序的状态。或者，增加一系列的日志，从日志中寻找线索。</p> 
<p>不过，断点往往会中断应用的正常运行；而增加新的日志，往往需要重新编译和部署。这些方法虽然在今天依然广泛使用，但在排查复杂的性能问题时，往往耗时耗力，更会对应用的正常运行造成巨大影响。</p><!-- 
[[[read_end]]] --> <p>此外，这类方式还有大量的性能问题。比如，出现的概率小，只有线上环境才能碰到。这种难以复现的问题，亦是一个巨大挑战。</p> <p>而动态追踪技术的出现，就为这些问题提供了完美的方案：它既不需要停止服务，也不需要修改应用程序的代码；所有一切还按照原来的方式正常运行时，就可以帮你分析出问题的根源。</p> 
<p>同时，相比以往的进程级跟踪方法（比如 ptrace），动态追踪往往只会带来很小的性能损耗（通常在 5% 或者更少）。</p> <p>既然动态追踪有这么多好处，那么，都有哪些动态追踪的方法，又该如何使用这些动态追踪方法呢？今天，我就带你一起来看看这个问题。由于动态追踪涉及的知识比较多，我将分为上、下两篇为你讲解，先来看今天这部分内容。</p> 
<h2>动态追踪</h2> <p>说到动态追踪（Dynamic Tracing），就不得不提源于 Solaris 系统的 DTrace。DTrace 是动态追踪技术的鼻祖，它提供了一个通用的观测框架，并可以使用 
D 语言进行自由扩展。</p> <p>DTrace 的工作原理如下图所示。<strong>它的运行常驻在内核中，用户可以通过 dtrace 命令，把 D 语言编写的追踪脚本，提交到内核中的运行时来执行</strong>。DTrace 
可以跟踪用户态和内核态的所有事件，并通过一些列的优化措施，保证最小的性能开销。</p> <p><img src="https://static001.geekbang.org/resource/image/61/a6/6144b1947373bd5668010502bd0e45a6.png" 
alt=""></p> <p>（图片来自 <a href="https://www.bsdcan.org/2017/schedule/attachments/433_dtrace_internals.html#(24)">BSDCan</a>）</p> 
<p>虽然直到今天，DTrace 本身依然无法在 Linux 中运行，但它同样对 Linux 动态追踪产生了巨大的影响。很多工程师都尝试过把 DTrace 移植到 Linux 中，这其中，最著名的就是 
RedHat 主推的 SystemTap。</p> <p>同 DTrace 一样，SystemTap 也定义了一种类似的脚本语言，方便用户根据需要自由扩展。不过，不同于 DTrace，SystemTap 
并没有常驻内核的运行时，它需要先把脚本编译为内核模块，然后再插入到内核中执行。这也导致 SystemTap 启动比较缓慢，并且依赖于完整的调试符号表。</p> <p><img src="https://static001.geekbang.org/resource/image/e0/db/e09aa4a00aee93f27f0d666a2bb1c4db.png" 
alt=""></p> <p>（图片来自<a href="https://openresty.org/posts/dynamic-tracing/">动态追踪技术漫谈</a>）</p> 
<p>总的来说，为了追踪内核或用户空间的事件，Dtrace 和 SystemTap 都会把用户传入的追踪处理函数（一般称为 Action），关联到被称为探针的检测点上。这些探针，实际上也就是各种动态追踪技术所依赖的事件源。</p> 
<h3>动态追踪的事件源</h3> <p>根据事件类型的不同，<strong>动态追踪所使用的事件源，可以分为静态探针、动态探针以及硬件事件等三类</strong>。它们的关系如下图所示：</p> 
<p><img src="https://static001.geekbang.org/resource/image/ba/61/ba6c9ed0dcccc7f4f46bb19c69946e61.png" 
alt=""></p> <p>（图片来自 <a href="http://www.brendangregg.com/perf.html#Events">Brendan Gregg Blog</a>）</p> 
<p>其中，<strong>硬件事件通常由性能监控计数器 PMC（Performance Monitoring Counter）产生</strong>，包括了各种硬件的性能情况，比如 
CPU 的缓存、指令周期、分支预测等等。</p> <p><strong>静态探针，是指事先在代码中定义好，并编译到应用程序或者内核中的探针</strong>。这些探针只有在开启探测功能时，才会被执行到；未开启时并不会执行。常见的静态探针包括内核中的跟踪点（tracepoints）和 
USDT（Userland Statically Defined Tracing）探针。</p> <ul> <li> <p>跟踪点（tracepoints），实际上就是在源码中插入的一些带有控制条件的探测点，这些探测点允许事后再添加处理函数。比如在内核中，最常见的静态跟踪方法就是 
printk，即输出日志。Linux 内核定义了大量的跟踪点，可以通过内核编译选项，来开启或者关闭。</p> </li> <li> <p>USDT 探针，全称是用户级静态定义跟踪，需要在源码中插入 
DTRACE_PROBE() 代码，并编译到应用程序中。不过，也有很多应用程序内置了 USDT 探针，比如 MySQL、PostgreSQL 等。</p> </li> </ul> <p><strong>动态探针，则是指没有事先在代码中定义，但却可以在运行时动态添加的探针</strong>，比如函数的调用和返回等。动态探针支持按需在内核或者应用程序中添加探测点，具有更高的灵活性。常见的动态探针有两种，即用于内核态的 
kprobes 和用于用户态的 uprobes。</p> <ul> <li> <p>kprobes 用来跟踪内核态的函数，包括用于函数调用的 kprobe 和用于函数返回的 kretprobe。</p> 
</li> <li> <p>uprobes 用来跟踪用户态的函数，包括用于函数调用的 uprobe 和用于函数返回的 uretprobe。</p> </li> </ul> <blockquote> 
<p>注意，kprobes 需要内核编译时开启 CONFIG_KPROBE_EVENTS；而 uprobes 则需要内核编译时开启 CONFIG_UPROBE_EVENTS。</p> 
</blockquote> <h3>动态追踪机制</h3> <p>而在这些探针的基础上，Linux 也提供了一系列的动态追踪机制，比如 ftrace、perf、eBPF 等。</p> 
<p><strong>ftrace</strong> 最早用于函数跟踪，后来又扩展支持了各种事件跟踪功能。ftrace 的使用接口跟我们之前提到的 procfs 类似，它通过 debugfs（4.1 
以后也支持 tracefs），以普通文件的形式，向用户空间提供访问接口。</p> <p>这样，不需要额外的工具，你就可以通过挂载点（通常为 /sys/kernel/debug/tracing 
目录）内的文件读写，来跟 ftrace 交互，跟踪内核或者应用程序的运行事件。</p> <p><strong>perf</strong> 是我们的老朋友了，我们在前面的好多案例中，都使用了它的事件记录和分析功能，这实际上只是一种最简单的静态跟踪机制。你也可以通过 
perf ，来自定义动态事件（perf probe），只关注真正感兴趣的事件。</p> <p><strong>eBPF</strong> 则在 BPF（Berkeley Packet 
Filter）的基础上扩展而来，不仅支持事件跟踪机制，还可以通过自定义的 BPF 代码（使用 C 语言）来自由扩展。所以，eBPF 实际上就是常驻于内核的运行时，可以说就是 Linux 
版的 DTrace。</p> <p>除此之外，还有很多内核外的工具，也提供了丰富的动态追踪功能。最常见的就是前面提到的 <strong>SystemTap</strong>，我们之前多次使用过的 
<strong>BCC</strong>（BPF Compiler Collection），以及常用于容器性能分析的 <strong>sysdig</strong> 等。</p> <p>而在分析大量事件时，使用我们上节课提到的火焰图，可以将大量数据可视化展示，让你更直观发现潜在的问题。</p> 
<p>接下来，我就通过几个例子，带你来看看，要怎么使用这些机制，来动态追踪内核和应用程序的执行情况。以下案例还是基于 Ubuntu 18.04 系统，同样适用于其他系统。</p> <blockquote> 
<p>注意，以下所有命令都默认以 root 用户运行，如果你用普通用户身份登陆系统，请运行 sudo su root 命令切换到 root 用户。</p> </blockquote> 
<h2>ftrace</h2> <p>我们先来看 ftrace。刚刚提到过，ftrace 通过 debugfs（或者 tracefs），为用户空间提供接口。所以使用 ftrace，往往是从切换到 
debugfs 的挂载点开始。</p> <pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ cd /sys/kernel/debug/tracing </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ ls </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> README instances set_ftrace_notrace trace_marker_raw </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> available_events kprobe_events set_ftrace_pid 
trace_options </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="5"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
... </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>如果这个目录不存在，则说明你的系统还没有挂载 debugfs，你可以执行下面的命令来挂载它：</p> <pre style="position: relative;"><code> 
<table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
$ mount -t debugfs nodev /sys/kernel/debug </div></td> </tr> </tbody> </table></code> <div 
class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 </div></pre> <p>ftrace 提供了多个跟踪器，用于跟踪不同类型的信息，比如函数调用、中断关闭、进程调度等。具体支持的跟踪器取决于系统配置，你可以执行下面的命令，来查询所有支持的跟踪器：</p> 
<pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> $ cat available_tracers </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> hwlat blk mmiotrace function_graph wakeup_dl wakeup_rt wakeup function 
nop </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>这其中，function 表示跟踪函数的执行，function_graph 则是跟踪函数的调用关系，也就是生成直观的调用关系图。这便是最常用的两种跟踪器。</p> 
<p>除了跟踪器外，使用 ftrace 前，还需要确认跟踪目标，包括内核函数和内核事件。其中，</p> <ul> <li> <p>函数就是内核中的函数名。</p> </li> <li> 
<p>而事件，则是内核源码中预先定义的跟踪点。</p> </li> </ul> <p>同样地，你可以执行下面的命令，来查询支持的函数和事件：</p> <pre style="position: 
relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
$ cat available_filter_functions </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
$ cat available_events </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <p>明白了这些基本信息，接下来，我就以 ls 命令为例，带你一起看看 ftrace 
的使用方法。</p> <p>为了列出文件，ls 命令会通过 open 系统调用打开目录文件，而 open 在内核中对应的函数名为 do_sys_open。 所以，我们要做的第一步，就是把要跟踪的函数设置为 
do_sys_open：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> <tr> 
<td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ echo do_sys_open &gt; set_graph_function 
</div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>接下来，第二步，配置跟踪选项，开启函数调用跟踪，并跟踪调用进程：</p> <pre style="position: relative;"><code> 
<table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
$ echo function_graph &gt; current_tracer </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> $ echo funcgraph-proc &gt; trace_options </div></td> </tr> </tbody> 
</table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 </div></pre> 
<p>接着，第三步，也就是开启跟踪：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ echo 1 &gt; tracing_on </div></td> </tr> 
</tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>第四步，执行一个 ls 命令后，再关闭跟踪：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> 
<tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ ls </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> $ echo 0 &gt; tracing_on </div></td> </tr> </tbody> </table></code> 
<div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 </div></pre> <p>第五步，也是最后一步，查看跟踪结果：</p> 
<pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> $ cat trace </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> # tracer: function_graph </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> # </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
# CPU TASK/PID DURATION FUNCTION CALLS </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> # | | | | | | | | | </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 0) ls-12276 | | do_sys_open() { </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 0) ls-12276 | | getname() { </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 0) ls-12276 | | getname_flags() { </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 0) ls-12276 | | kmem_cache_alloc() { </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 0) ls-12276 | | _cond_resched() { </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 0) ls-12276 | 0.049 us | rcu_all_qs(); 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 0) ls-12276 | 0.791 us | } </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="13"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 0) ls-12276 | 0.041 us | should_failslab(); 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="14"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 0) ls-12276 | 0.040 us | prefetch_freepointer(); 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="15"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 0) ls-12276 | 0.039 us | memcg_kmem_put_cache(); 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="16"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 0) ls-12276 | 2.895 us | } </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="17"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 0) ls-12276 | | __check_object_size() 
{ </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="18"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 0) ls-12276 | 0.067 us | __virt_addr_valid(); 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="19"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 0) ls-12276 | 0.044 us | __check_heap_object(); 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="20"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 0) ls-12276 | 0.039 us | check_stack_object(); 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="21"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 0) ls-12276 | 1.570 us | } </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="22"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 0) ls-12276 | 5.790 us | } </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="23"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 0) ls-12276 | 6.325 us | } </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="24"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> ... </div></td> </tr> </tbody> </table></code> 
<div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 </div></pre> <p>在最后得到的输出中：</p> 
<ul> <li> <p>第一列表示运行的 CPU；</p> </li> <li> <p>第二列是任务名称和进程 PID；</p> </li> <li> <p>第三列是函数执行延迟；</p> 
</li> <li> <p>最后一列，则是函数调用关系图。</p> </li> </ul> <p>你可以看到，函数调用图，通过不同级别的缩进，直观展示了各函数间的调用关系。</p> 
<p>当然，我想你应该也发现了 ftrace 的使用缺点——五个步骤实在是麻烦，用起来并不方便。不过，不用担心， <a href="https://git.kernel.org/pub/scm/utils/trace-cmd/trace-cmd.git/">trace-cmd</a> 
已经帮你把这些步骤给包装了起来。这样，你就可以在同一个命令行工具里，完成上述所有过程。</p> <p>你可以执行下面的命令，来安装 trace-cmd ：</p> <pre style="position: 
relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
# Ubuntu </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> $ apt-get 
install trace-cmd </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
# CentOS </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="4"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> $ yum 
install trace-cmd </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <p>安装好后，原本的五步跟踪过程，就可以简化为下面这两步：</p> <pre style="position: 
relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
$ trace-cmd record -p function_graph -g do_sys_open -O funcgraph-proc ls </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ trace-cmd report </div></td> </tr> <tr> 
<td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> ... </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> ls-12418 [000] 85558.075341: funcgraph_entry: | do_sys_open() { 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> ls-12418 [000] 85558.075363: funcgraph_entry: 
| getname() { </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="6"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
ls-12418 [000] 85558.075364: funcgraph_entry: | getname_flags() { </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> ls-12418 [000] 85558.075364: funcgraph_entry: 
| kmem_cache_alloc() { </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="8"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
ls-12418 [000] 85558.075365: funcgraph_entry: | _cond_resched() { </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> ls-12418 [000] 85558.075365: funcgraph_entry: 
0.074 us | rcu_all_qs(); </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="10"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
ls-12418 [000] 85558.075366: funcgraph_exit: 1.143 us | } </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> ls-12418 [000] 85558.075366: funcgraph_entry: 0.064 us | should_failslab(); 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> ls-12418 [000] 85558.075367: funcgraph_entry: 
0.075 us | prefetch_freepointer(); </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="13"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> ls-12418 [000] 85558.075368: funcgraph_entry: 0.085 us | memcg_kmem_put_cache(); 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="14"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> ls-12418 [000] 85558.075369: funcgraph_exit: 
4.447 us | } </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="15"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> ls-12418 
[000] 85558.075369: funcgraph_entry: | __check_object_size() { </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="16"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> ls-12418 [000] 85558.075370: funcgraph_entry: 0.132 us | __virt_addr_valid(); 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="17"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> ls-12418 [000] 85558.075370: funcgraph_entry: 
0.093 us | __check_heap_object(); </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="18"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> ls-12418 [000] 85558.075371: funcgraph_entry: 0.059 us | check_stack_object(); 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="19"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> ls-12418 [000] 85558.075372: funcgraph_exit: 
2.323 us | } </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="20"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> ls-12418 
[000] 85558.075372: funcgraph_exit: 8.411 us | } </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="21"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> ls-12418 [000] 85558.075373: funcgraph_exit: 9.195 us | } </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="22"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> ... </div></td> </tr> </tbody> </table></code> 
<div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 </div></pre> <p>你会发现，trace-cmd 
的输出，跟上述 cat trace 的输出是类似的。</p> <p>通过这个例子我们知道，当你想要了解某个内核函数的调用过程时，使用 ftrace ，就可以跟踪到它的执行过程。</p> 
<h2>小结</h2> <p>今天，我带你一起学习了常见的动态追踪方法。所谓动态追踪，就是在系统或应用程序正常运行时，通过内核中提供的探针来动态追踪它们的行为，从而辅助排查出性能瓶颈。</p> 
<p>而在 Linux 系统中，常见的动态追踪方法包括 ftrace、perf、eBPF 以及 SystemTap 等。当你已经定位了某个内核函数，但不清楚它的实现原理时，就可以用 
ftrace 来跟踪它的执行过程。至于其他动态追踪方法，我将在下节课继续为你详细解读。</p> <h2>思考</h2> <p>最后，给你留一个思考题。今天的案例中，我们使用 Linux 
内核提供的 ftrace 机制，来了解内核函数的执行过程；而上节课我们则用了 perf 和火焰图，来观察内核的调用堆栈。</p> <p>根据这两个案例，你觉得这两种方法有什么不一样的地方？当需要了解内核的行为时，如何在二者中选择，或者说，这两种方法分别适用于什么样的场景呢？你可以结合今天的内容，和你自己的操作记录，来总结思路。</p> 
<p>欢迎在留言区和我讨论，也欢迎把这篇文章分享给你的同事、朋友。我们一起在实战中演练，在交流中进步。</p> <p><img src="https://static001.geekbang.org/resource/image/a3/e9/a396aed4116c2c989771c1295736abe9.jpg" 
alt=""></p>', body_summary='', bundle='book', delta=0, body_format='full_html', langcode='zh-hans', 
revision_id=1083 where entity_id=1083 
 {executed in 1 msec}
2020-11-25 10:16:52.933 INFO  jdbc.sqltiming Line:373 - update node_revision__body set body_value='<p>你好，我是倪朋飞。</p> <p>上一节，我以 ksoftirqd CPU 使用率高的问题为例，带你一起学习了内核线程 
CPU 使用率高时的分析方法。先简单回顾一下。</p> <p>当碰到内核线程的资源使用异常时，很多常用的进程级性能工具，并不能直接用到内核线程上。这时，我们就可以使用内核自带的 perf 
来观察它们的行为，找出热点函数，进一步定位性能瓶颈。不过，perf 产生的汇总报告并不直观，所以我通常也推荐用火焰图来协助排查。</p> <p>其实，使用 perf 对系统内核线程进行分析时，内核线程依然还在正常运行中，所以这种方法也被称为动态追踪技术。</p> 
<p><strong>动态追踪技术，通过探针机制，来采集内核或者应用程序的运行信息，从而可以不用修改内核和应用程序的代码，就获得丰富的信息，帮你分析、定位想要排查的问题。</strong></p> 
<p>以往，在排查和调试性能问题时，我们往往需要先为应用程序设置一系列的断点（比如使用 GDB），然后以手动或者脚本（比如 GDB 的 Python 扩展）的方式，在这些断点处分析应用程序的状态。或者，增加一系列的日志，从日志中寻找线索。</p> 
<p>不过，断点往往会中断应用的正常运行；而增加新的日志，往往需要重新编译和部署。这些方法虽然在今天依然广泛使用，但在排查复杂的性能问题时，往往耗时耗力，更会对应用的正常运行造成巨大影响。</p><!-- 
[[[read_end]]] --> <p>此外，这类方式还有大量的性能问题。比如，出现的概率小，只有线上环境才能碰到。这种难以复现的问题，亦是一个巨大挑战。</p> <p>而动态追踪技术的出现，就为这些问题提供了完美的方案：它既不需要停止服务，也不需要修改应用程序的代码；所有一切还按照原来的方式正常运行时，就可以帮你分析出问题的根源。</p> 
<p>同时，相比以往的进程级跟踪方法（比如 ptrace），动态追踪往往只会带来很小的性能损耗（通常在 5% 或者更少）。</p> <p>既然动态追踪有这么多好处，那么，都有哪些动态追踪的方法，又该如何使用这些动态追踪方法呢？今天，我就带你一起来看看这个问题。由于动态追踪涉及的知识比较多，我将分为上、下两篇为你讲解，先来看今天这部分内容。</p> 
<h2>动态追踪</h2> <p>说到动态追踪（Dynamic Tracing），就不得不提源于 Solaris 系统的 DTrace。DTrace 是动态追踪技术的鼻祖，它提供了一个通用的观测框架，并可以使用 
D 语言进行自由扩展。</p> <p>DTrace 的工作原理如下图所示。<strong>它的运行常驻在内核中，用户可以通过 dtrace 命令，把 D 语言编写的追踪脚本，提交到内核中的运行时来执行</strong>。DTrace 
可以跟踪用户态和内核态的所有事件，并通过一些列的优化措施，保证最小的性能开销。</p> <p><img src="https://static001.geekbang.org/resource/image/61/a6/6144b1947373bd5668010502bd0e45a6.png" 
alt=""></p> <p>（图片来自 <a href="https://www.bsdcan.org/2017/schedule/attachments/433_dtrace_internals.html#(24)">BSDCan</a>）</p> 
<p>虽然直到今天，DTrace 本身依然无法在 Linux 中运行，但它同样对 Linux 动态追踪产生了巨大的影响。很多工程师都尝试过把 DTrace 移植到 Linux 中，这其中，最著名的就是 
RedHat 主推的 SystemTap。</p> <p>同 DTrace 一样，SystemTap 也定义了一种类似的脚本语言，方便用户根据需要自由扩展。不过，不同于 DTrace，SystemTap 
并没有常驻内核的运行时，它需要先把脚本编译为内核模块，然后再插入到内核中执行。这也导致 SystemTap 启动比较缓慢，并且依赖于完整的调试符号表。</p> <p><img src="https://static001.geekbang.org/resource/image/e0/db/e09aa4a00aee93f27f0d666a2bb1c4db.png" 
alt=""></p> <p>（图片来自<a href="https://openresty.org/posts/dynamic-tracing/">动态追踪技术漫谈</a>）</p> 
<p>总的来说，为了追踪内核或用户空间的事件，Dtrace 和 SystemTap 都会把用户传入的追踪处理函数（一般称为 Action），关联到被称为探针的检测点上。这些探针，实际上也就是各种动态追踪技术所依赖的事件源。</p> 
<h3>动态追踪的事件源</h3> <p>根据事件类型的不同，<strong>动态追踪所使用的事件源，可以分为静态探针、动态探针以及硬件事件等三类</strong>。它们的关系如下图所示：</p> 
<p><img src="https://static001.geekbang.org/resource/image/ba/61/ba6c9ed0dcccc7f4f46bb19c69946e61.png" 
alt=""></p> <p>（图片来自 <a href="http://www.brendangregg.com/perf.html#Events">Brendan Gregg Blog</a>）</p> 
<p>其中，<strong>硬件事件通常由性能监控计数器 PMC（Performance Monitoring Counter）产生</strong>，包括了各种硬件的性能情况，比如 
CPU 的缓存、指令周期、分支预测等等。</p> <p><strong>静态探针，是指事先在代码中定义好，并编译到应用程序或者内核中的探针</strong>。这些探针只有在开启探测功能时，才会被执行到；未开启时并不会执行。常见的静态探针包括内核中的跟踪点（tracepoints）和 
USDT（Userland Statically Defined Tracing）探针。</p> <ul> <li> <p>跟踪点（tracepoints），实际上就是在源码中插入的一些带有控制条件的探测点，这些探测点允许事后再添加处理函数。比如在内核中，最常见的静态跟踪方法就是 
printk，即输出日志。Linux 内核定义了大量的跟踪点，可以通过内核编译选项，来开启或者关闭。</p> </li> <li> <p>USDT 探针，全称是用户级静态定义跟踪，需要在源码中插入 
DTRACE_PROBE() 代码，并编译到应用程序中。不过，也有很多应用程序内置了 USDT 探针，比如 MySQL、PostgreSQL 等。</p> </li> </ul> <p><strong>动态探针，则是指没有事先在代码中定义，但却可以在运行时动态添加的探针</strong>，比如函数的调用和返回等。动态探针支持按需在内核或者应用程序中添加探测点，具有更高的灵活性。常见的动态探针有两种，即用于内核态的 
kprobes 和用于用户态的 uprobes。</p> <ul> <li> <p>kprobes 用来跟踪内核态的函数，包括用于函数调用的 kprobe 和用于函数返回的 kretprobe。</p> 
</li> <li> <p>uprobes 用来跟踪用户态的函数，包括用于函数调用的 uprobe 和用于函数返回的 uretprobe。</p> </li> </ul> <blockquote> 
<p>注意，kprobes 需要内核编译时开启 CONFIG_KPROBE_EVENTS；而 uprobes 则需要内核编译时开启 CONFIG_UPROBE_EVENTS。</p> 
</blockquote> <h3>动态追踪机制</h3> <p>而在这些探针的基础上，Linux 也提供了一系列的动态追踪机制，比如 ftrace、perf、eBPF 等。</p> 
<p><strong>ftrace</strong> 最早用于函数跟踪，后来又扩展支持了各种事件跟踪功能。ftrace 的使用接口跟我们之前提到的 procfs 类似，它通过 debugfs（4.1 
以后也支持 tracefs），以普通文件的形式，向用户空间提供访问接口。</p> <p>这样，不需要额外的工具，你就可以通过挂载点（通常为 /sys/kernel/debug/tracing 
目录）内的文件读写，来跟 ftrace 交互，跟踪内核或者应用程序的运行事件。</p> <p><strong>perf</strong> 是我们的老朋友了，我们在前面的好多案例中，都使用了它的事件记录和分析功能，这实际上只是一种最简单的静态跟踪机制。你也可以通过 
perf ，来自定义动态事件（perf probe），只关注真正感兴趣的事件。</p> <p><strong>eBPF</strong> 则在 BPF（Berkeley Packet 
Filter）的基础上扩展而来，不仅支持事件跟踪机制，还可以通过自定义的 BPF 代码（使用 C 语言）来自由扩展。所以，eBPF 实际上就是常驻于内核的运行时，可以说就是 Linux 
版的 DTrace。</p> <p>除此之外，还有很多内核外的工具，也提供了丰富的动态追踪功能。最常见的就是前面提到的 <strong>SystemTap</strong>，我们之前多次使用过的 
<strong>BCC</strong>（BPF Compiler Collection），以及常用于容器性能分析的 <strong>sysdig</strong> 等。</p> <p>而在分析大量事件时，使用我们上节课提到的火焰图，可以将大量数据可视化展示，让你更直观发现潜在的问题。</p> 
<p>接下来，我就通过几个例子，带你来看看，要怎么使用这些机制，来动态追踪内核和应用程序的执行情况。以下案例还是基于 Ubuntu 18.04 系统，同样适用于其他系统。</p> <blockquote> 
<p>注意，以下所有命令都默认以 root 用户运行，如果你用普通用户身份登陆系统，请运行 sudo su root 命令切换到 root 用户。</p> </blockquote> 
<h2>ftrace</h2> <p>我们先来看 ftrace。刚刚提到过，ftrace 通过 debugfs（或者 tracefs），为用户空间提供接口。所以使用 ftrace，往往是从切换到 
debugfs 的挂载点开始。</p> <pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ cd /sys/kernel/debug/tracing </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ ls </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> README instances set_ftrace_notrace trace_marker_raw </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> available_events kprobe_events set_ftrace_pid 
trace_options </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="5"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
... </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>如果这个目录不存在，则说明你的系统还没有挂载 debugfs，你可以执行下面的命令来挂载它：</p> <pre style="position: relative;"><code> 
<table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
$ mount -t debugfs nodev /sys/kernel/debug </div></td> </tr> </tbody> </table></code> <div 
class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 </div></pre> <p>ftrace 提供了多个跟踪器，用于跟踪不同类型的信息，比如函数调用、中断关闭、进程调度等。具体支持的跟踪器取决于系统配置，你可以执行下面的命令，来查询所有支持的跟踪器：</p> 
<pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> $ cat available_tracers </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> hwlat blk mmiotrace function_graph wakeup_dl wakeup_rt wakeup function 
nop </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>这其中，function 表示跟踪函数的执行，function_graph 则是跟踪函数的调用关系，也就是生成直观的调用关系图。这便是最常用的两种跟踪器。</p> 
<p>除了跟踪器外，使用 ftrace 前，还需要确认跟踪目标，包括内核函数和内核事件。其中，</p> <ul> <li> <p>函数就是内核中的函数名。</p> </li> <li> 
<p>而事件，则是内核源码中预先定义的跟踪点。</p> </li> </ul> <p>同样地，你可以执行下面的命令，来查询支持的函数和事件：</p> <pre style="position: 
relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
$ cat available_filter_functions </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
$ cat available_events </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <p>明白了这些基本信息，接下来，我就以 ls 命令为例，带你一起看看 ftrace 
的使用方法。</p> <p>为了列出文件，ls 命令会通过 open 系统调用打开目录文件，而 open 在内核中对应的函数名为 do_sys_open。 所以，我们要做的第一步，就是把要跟踪的函数设置为 
do_sys_open：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> <tr> 
<td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ echo do_sys_open &gt; set_graph_function 
</div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>接下来，第二步，配置跟踪选项，开启函数调用跟踪，并跟踪调用进程：</p> <pre style="position: relative;"><code> 
<table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
$ echo function_graph &gt; current_tracer </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> $ echo funcgraph-proc &gt; trace_options </div></td> </tr> </tbody> 
</table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 </div></pre> 
<p>接着，第三步，也就是开启跟踪：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ echo 1 &gt; tracing_on </div></td> </tr> 
</tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>第四步，执行一个 ls 命令后，再关闭跟踪：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> 
<tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ ls </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> $ echo 0 &gt; tracing_on </div></td> </tr> </tbody> </table></code> 
<div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 </div></pre> <p>第五步，也是最后一步，查看跟踪结果：</p> 
<pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> $ cat trace </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> # tracer: function_graph </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> # </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
# CPU TASK/PID DURATION FUNCTION CALLS </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> # | | | | | | | | | </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 0) ls-12276 | | do_sys_open() { </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 0) ls-12276 | | getname() { </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 0) ls-12276 | | getname_flags() { </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 0) ls-12276 | | kmem_cache_alloc() { </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 0) ls-12276 | | _cond_resched() { </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 0) ls-12276 | 0.049 us | rcu_all_qs(); 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 0) ls-12276 | 0.791 us | } </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="13"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 0) ls-12276 | 0.041 us | should_failslab(); 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="14"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 0) ls-12276 | 0.040 us | prefetch_freepointer(); 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="15"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 0) ls-12276 | 0.039 us | memcg_kmem_put_cache(); 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="16"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 0) ls-12276 | 2.895 us | } </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="17"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 0) ls-12276 | | __check_object_size() 
{ </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="18"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 0) ls-12276 | 0.067 us | __virt_addr_valid(); 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="19"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 0) ls-12276 | 0.044 us | __check_heap_object(); 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="20"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 0) ls-12276 | 0.039 us | check_stack_object(); 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="21"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 0) ls-12276 | 1.570 us | } </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="22"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 0) ls-12276 | 5.790 us | } </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="23"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 0) ls-12276 | 6.325 us | } </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="24"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> ... </div></td> </tr> </tbody> </table></code> 
<div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 </div></pre> <p>在最后得到的输出中：</p> 
<ul> <li> <p>第一列表示运行的 CPU；</p> </li> <li> <p>第二列是任务名称和进程 PID；</p> </li> <li> <p>第三列是函数执行延迟；</p> 
</li> <li> <p>最后一列，则是函数调用关系图。</p> </li> </ul> <p>你可以看到，函数调用图，通过不同级别的缩进，直观展示了各函数间的调用关系。</p> 
<p>当然，我想你应该也发现了 ftrace 的使用缺点——五个步骤实在是麻烦，用起来并不方便。不过，不用担心， <a href="https://git.kernel.org/pub/scm/utils/trace-cmd/trace-cmd.git/">trace-cmd</a> 
已经帮你把这些步骤给包装了起来。这样，你就可以在同一个命令行工具里，完成上述所有过程。</p> <p>你可以执行下面的命令，来安装 trace-cmd ：</p> <pre style="position: 
relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
# Ubuntu </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> $ apt-get 
install trace-cmd </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
# CentOS </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="4"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> $ yum 
install trace-cmd </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <p>安装好后，原本的五步跟踪过程，就可以简化为下面这两步：</p> <pre style="position: 
relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
$ trace-cmd record -p function_graph -g do_sys_open -O funcgraph-proc ls </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ trace-cmd report </div></td> </tr> <tr> 
<td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> ... </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> ls-12418 [000] 85558.075341: funcgraph_entry: | do_sys_open() { 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> ls-12418 [000] 85558.075363: funcgraph_entry: 
| getname() { </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="6"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
ls-12418 [000] 85558.075364: funcgraph_entry: | getname_flags() { </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> ls-12418 [000] 85558.075364: funcgraph_entry: 
| kmem_cache_alloc() { </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="8"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
ls-12418 [000] 85558.075365: funcgraph_entry: | _cond_resched() { </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> ls-12418 [000] 85558.075365: funcgraph_entry: 
0.074 us | rcu_all_qs(); </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="10"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
ls-12418 [000] 85558.075366: funcgraph_exit: 1.143 us | } </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> ls-12418 [000] 85558.075366: funcgraph_entry: 0.064 us | should_failslab(); 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> ls-12418 [000] 85558.075367: funcgraph_entry: 
0.075 us | prefetch_freepointer(); </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="13"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> ls-12418 [000] 85558.075368: funcgraph_entry: 0.085 us | memcg_kmem_put_cache(); 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="14"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> ls-12418 [000] 85558.075369: funcgraph_exit: 
4.447 us | } </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="15"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> ls-12418 
[000] 85558.075369: funcgraph_entry: | __check_object_size() { </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="16"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> ls-12418 [000] 85558.075370: funcgraph_entry: 0.132 us | __virt_addr_valid(); 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="17"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> ls-12418 [000] 85558.075370: funcgraph_entry: 
0.093 us | __check_heap_object(); </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="18"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> ls-12418 [000] 85558.075371: funcgraph_entry: 0.059 us | check_stack_object(); 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="19"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> ls-12418 [000] 85558.075372: funcgraph_exit: 
2.323 us | } </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="20"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> ls-12418 
[000] 85558.075372: funcgraph_exit: 8.411 us | } </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="21"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> ls-12418 [000] 85558.075373: funcgraph_exit: 9.195 us | } </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="22"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> ... </div></td> </tr> </tbody> </table></code> 
<div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 </div></pre> <p>你会发现，trace-cmd 
的输出，跟上述 cat trace 的输出是类似的。</p> <p>通过这个例子我们知道，当你想要了解某个内核函数的调用过程时，使用 ftrace ，就可以跟踪到它的执行过程。</p> 
<h2>小结</h2> <p>今天，我带你一起学习了常见的动态追踪方法。所谓动态追踪，就是在系统或应用程序正常运行时，通过内核中提供的探针来动态追踪它们的行为，从而辅助排查出性能瓶颈。</p> 
<p>而在 Linux 系统中，常见的动态追踪方法包括 ftrace、perf、eBPF 以及 SystemTap 等。当你已经定位了某个内核函数，但不清楚它的实现原理时，就可以用 
ftrace 来跟踪它的执行过程。至于其他动态追踪方法，我将在下节课继续为你详细解读。</p> <h2>思考</h2> <p>最后，给你留一个思考题。今天的案例中，我们使用 Linux 
内核提供的 ftrace 机制，来了解内核函数的执行过程；而上节课我们则用了 perf 和火焰图，来观察内核的调用堆栈。</p> <p>根据这两个案例，你觉得这两种方法有什么不一样的地方？当需要了解内核的行为时，如何在二者中选择，或者说，这两种方法分别适用于什么样的场景呢？你可以结合今天的内容，和你自己的操作记录，来总结思路。</p> 
<p>欢迎在留言区和我讨论，也欢迎把这篇文章分享给你的同事、朋友。我们一起在实战中演练，在交流中进步。</p> <p><img src="https://static001.geekbang.org/resource/image/a3/e9/a396aed4116c2c989771c1295736abe9.jpg" 
alt=""></p>', body_summary='', bundle='book', delta=0, body_format='full_html', langcode='zh-hans', 
revision_id=1083 where entity_id=1083 
 {executed in 0 msec}
2020-11-25 10:16:52.938 INFO  jdbc.sqltiming Line:373 - select nodefiledd0_.nid as nid1_10_, nodefiledd0_.changed as changed2_10_, nodefiledd0_.created 
as created3_10_, nodefiledd0_.default_langcode as default_4_10_, nodefiledd0_.langcode as langcode5_10_, 
nodefiledd0_.promote as promote6_10_, nodefiledd0_.revision_translation_affected as revision7_10_, 
nodefiledd0_.status as status8_10_, nodefiledd0_.sticky as sticky9_10_, nodefiledd0_.title 
as title10_10_, nodefiledd0_.type as type11_10_, nodefiledd0_.uid as uid12_10_, nodefiledd0_.vid 
as vid13_10_ from node_field_data nodefiledd0_ where nodefiledd0_.nid=1083 
 {executed in 0 msec}
2020-11-25 10:16:52.938 INFO  jdbc.resultsettable Line:610 - 
|-----|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|-------------------|-----|----|-----|
|nid  |changed    |created    |default_langcode |langcode |promote |revision_translation_affected |status |sticky |title              |type |uid |vid  |
|-----|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|-------------------|-----|----|-----|
|1083 |1606114986 |1606114986 |1                |zh-hans  |0       |1                             |1      |0      |50丨案例篇：动态追踪怎么用？（上） |book |1   |1083 |
|-----|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|-------------------|-----|----|-----|

2020-11-25 10:16:52.939 INFO  jdbc.sqltiming Line:373 - select nodefieldr0_.nid as nid1_11_0_, nodefieldr0_.changed as changed2_11_0_, nodefieldr0_.created 
as created3_11_0_, nodefieldr0_.default_langcode as default_4_11_0_, nodefieldr0_.langcode 
as langcode5_11_0_, nodefieldr0_.promote as promote6_11_0_, nodefieldr0_.revision_translation_affected 
as revision7_11_0_, nodefieldr0_.status as status8_11_0_, nodefieldr0_.sticky as sticky9_11_0_, 
nodefieldr0_.title as title10_11_0_, nodefieldr0_.uid as uid11_11_0_, nodefieldr0_.vid as vid12_11_0_ 
from node_field_revision nodefieldr0_ where nodefieldr0_.nid=1083 
 {executed in 0 msec}
2020-11-25 10:16:52.939 INFO  jdbc.resultsettable Line:610 - 
|---------|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|-------------------|----|-----|
|nid      |changed    |created    |default_langcode |langcode |promote |revision_translation_affected |status |sticky |title              |uid |vid  |
|---------|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|-------------------|----|-----|
|[unread] |1606114986 |1606114986 |1                |zh-hans  |0       |1                             |1      |0      |50丨案例篇：动态追踪怎么用？（上） |1   |1083 |
|---------|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|-------------------|----|-----|

2020-11-25 10:16:52.941 INFO  jdbc.sqltiming Line:373 - update node_field_data set changed=1606270612, created=1606270612, default_langcode=1, langcode='zh-hans', 
promote=0, revision_translation_affected=1, status=1, sticky=0, title='50丨案例篇：动态追踪怎么用？（上）', 
type='book', uid=1, vid=1083 where nid=1083 
 {executed in 0 msec}
2020-11-25 10:16:52.941 INFO  jdbc.sqltiming Line:373 - update node_field_revision set changed=1606270612, created=1606270612, default_langcode=1, 
langcode='zh-hans', promote=0, revision_translation_affected=1, status=1, sticky=0, title='50丨案例篇：动态追踪怎么用？（上）', 
uid=1, vid=1083 where nid=1083 
 {executed in 0 msec}
2020-11-25 10:16:52.945 INFO  jdbc.sqltiming Line:373 - select bookfieldm0_.entity_id as entity_i1_8_, bookfieldm0_.bundle as bundle2_8_, bookfieldm0_.delta 
as delta3_8_, bookfieldm0_.langcode as langcode4_8_, bookfieldm0_.field_media_value as field_me5_8_, 
bookfieldm0_.revision_id as revision6_8_ from node__field_media bookfieldm0_ where bookfieldm0_.entity_id=1083 
 {executed in 0 msec}
2020-11-25 10:16:52.945 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------------|------------|
|entity_id |bundle |delta |langcode |field_media_value |revision_id |
|----------|-------|------|---------|------------------|------------|
|1083      |book   |0     |zh-hans  |                  |1083        |
|----------|-------|------|---------|------------------|------------|

2020-11-25 10:16:52.947 INFO  jdbc.sqltiming Line:373 - select nodefieldm0_.entity_id as entity_i1_17_0_, nodefieldm0_.bundle as bundle2_17_0_, nodefieldm0_.delta 
as delta3_17_0_, nodefieldm0_.langcode as langcode4_17_0_, nodefieldm0_.field_media_value as 
field_me5_17_0_, nodefieldm0_.revision_id as revision6_17_0_ from node_revision__field_media 
nodefieldm0_ where nodefieldm0_.entity_id=1083 
 {executed in 0 msec}
2020-11-25 10:16:52.947 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------------|------------|
|entity_id |bundle |delta |langcode |field_media_value |revision_id |
|----------|-------|------|---------|------------------|------------|
|[unread]  |book   |0     |zh-hans  |                  |1083        |
|----------|-------|------|---------|------------------|------------|

2020-11-25 10:16:52.949 INFO  jdbc.sqltiming Line:373 - select bookfieldc0_.entity_id as entity_i1_5_, bookfieldc0_.bundle as bundle2_5_, bookfieldc0_.field_comment_value 
as field_co3_5_, bookfieldc0_.delta as delta4_5_, bookfieldc0_.field_comment_format as field_co5_5_, 
bookfieldc0_.langcode as langcode6_5_, bookfieldc0_.revision_id as revision7_5_ from node__field_comment 
bookfieldc0_ where bookfieldc0_.entity_id=1083 
 {executed in 0 msec}
2020-11-25 10:16:52.949 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|--------------------|------|---------------------|---------|------------|
|entity_id |bundle |field_comment_value |delta |field_comment_format |langcode |revision_id |
|----------|-------|--------------------|------|---------------------|---------|------------|
|1083      |book   |                    |0     |full_html            |zh-hans  |1083        |
|----------|-------|--------------------|------|---------------------|---------|------------|

2020-11-25 10:16:52.952 INFO  jdbc.sqltiming Line:373 - update node__field_comment set bundle='book', field_comment_value='<li class="reJj6Thl_0"><img 
src="https://static001.geekbang.org/account/avatar/00/15/2c/51/fdf460ba.jpg" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>lizh</span> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-20 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">9</span> </div> <!----> 
<!----> </div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 早些时间整理过的一篇文章，和这个主题很match，分享在这里^_^。https://leezhenghui.github.io/linux/2019/03/05/exploring-usdt-on-linux.html 
</div> <!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 👍谢谢分享</p> </div> </div></li> 
<li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/0f/bd/ac/c9154dfe.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>Huayra</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-20 </div> </div> <div 
class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">4</span> 
</div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0"> 将性能优化大师Brendan Gregg的blog阅读一遍，就能够更深刻地理解这一章。据说，OpenResty的作者张亦春也阅读过Brendan 
Gregg的所有博客，他现在更进一步地开发了一个将高级编程语言编译成动态追踪脚本的工具 </div> <div class="_2r3UB1GX_0"> <span>展开</span><i 
class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 👍</p> 
</div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>我来也</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-20 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">2</span> </div> <!----> 
<!----> </div> </div> <div class="_3M6kV3zb_0"> [D50打卡] <br>课后思考题,我的思考,不一定准确. <br>我觉得昨天的perf和火焰图,是采样. 
而今天的ftrace是实实在在的分析每次一的调用. <br>虽然都可以看调用堆栈和耗时比例. 但是ftrace应该是非常准确,而perf只是一个采样,比如采样频率1%. <br> <br>我觉得找大方向时,使用perf和火焰图, 
找具体问题时,用ftrace.毕竟ftrace需要知道调用的系统函数. <br>ftrace需要追踪的信息可以来源于perf的分析结果. </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 
嗯嗯，非常准确。函数跟踪需要实现知道函数名，而perf/火焰图就可以找出热点函数。</p> </div> </div></li> <li class="reJj6Thl_0"><img 
src="https://static001.geekbang.org/account/avatar/00/14/5b/ae/3d639ea4.jpg" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>佳</span> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-23 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> </div> <!----> 
<!----> </div> </div> <div class="_3M6kV3zb_0"> 在和同事讨论nodejs使用从thrift转化到grpc时候会性能下降问题就用老师介绍 
<br> <br>strace -T -ttt -p pid <br> <br>找到根源。 <br> <br>grpc -node版本发送分两次writev系统调用，第一次发送 grpc路径，第二次发送参数。比thrift协议一次效率一些。 
<br> <br>再发现node并发次数多，回调算时间往往是多个调用所花的时间。这些效率都用strace看到，在前面时间 </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 
👍谢谢分享</p> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/12/8c/2b/3ab96998.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>青石</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-22 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> </div> <!----> 
<!----> </div> </div> <div class="_3M6kV3zb_0"> #echo function_graph &gt; current_trace <br>-bash: 
current_trace: Permission denied <br> <br>报上面错误的同学，可以尝试下面的命令，环境是CentOS 7.6 <br><span class="MathJax_Preview" 
style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-1-Frame" 
tabindex="0" style="position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>e</mi><mi>c</mi><mi>h</mi><mi>o</mi><mi>f</mi><mi>u</mi><mi>n</mi><mi>c</mi><mi>t</mi><mi>i</mi><mi>o</mi><msub><mi>n</mi><mi>g</mi></msub><mi>r</mi><mi>a</mi><mi>p</mi><mi>h</mi><mo>></mo><mi>c</mi><mi>u</mi><mi>r</mi><mi>r</mi><mi>e</mi><mi>n</mi><msub><mi>t</mi><mi>t</mi></msub><mi>r</mi><mi>a</mi><mi>c</mi><mi>e</mi><mi>r</mi></math>" 
role="presentation"> <nobr aria-hidden="true"> <span class="math" id="MathJax-Span-1" style="width: 
19.703em; display: inline-block;"><span style="display: inline-block; position: relative; width: 
15.753em; height: 0px; font-size: 125%;"><span style="position: absolute; clip: rect(1.502em, 
1015.75em, 2.802em, -999.998em); top: -2.348em; left: 0em;"><span class="mrow" id="MathJax-Span-2"><span 
class="mi" id="MathJax-Span-3" style="font-family: MathJax_Math-italic;">e</span><span class="mi" 
id="MathJax-Span-4" style="font-family: MathJax_Math-italic;">c</span><span class="mi" id="MathJax-Span-5" 
style="font-family: MathJax_Math-italic;">h</span><span class="mi" id="MathJax-Span-6" style="font-family: 
MathJax_Math-italic;">o</span><span class="mi" id="MathJax-Span-7" style="font-family: MathJax_Math-italic;">f<span 
style="display: inline-block; overflow: hidden; height: 1px; width: 0.053em;"></span></span><span 
class="mi" id="MathJax-Span-8" style="font-family: MathJax_Math-italic;">u</span><span class="mi" 
id="MathJax-Span-9" style="font-family: MathJax_Math-italic;">n</span><span class="mi" id="MathJax-Span-10" 
style="font-family: MathJax_Math-italic;">c</span><span class="mi" id="MathJax-Span-11" style="font-family: 
MathJax_Math-italic;">t</span><span class="mi" id="MathJax-Span-12" style="font-family: MathJax_Math-italic;">i</span><span 
class="mi" id="MathJax-Span-13" style="font-family: MathJax_Math-italic;">o</span><span class="msubsup" 
id="MathJax-Span-14"><span style="display: inline-block; position: relative; width: 1.002em; 
height: 0px;"><span style="position: absolute; clip: rect(3.402em, 1000.6em, 4.152em, -999.998em); 
top: -3.998em; left: 0em;"><span class="mi" id="MathJax-Span-15" style="font-family: MathJax_Math-italic;">n</span><span 
style="display: inline-block; width: 0px; height: 4.002em;"></span></span><span style="position: 
absolute; top: -3.848em; left: 0.603em;"><span class="mi" id="MathJax-Span-16" style="font-size: 
70.7%; font-family: MathJax_Math-italic;">g<span style="display: inline-block; overflow: hidden; 
height: 1px; width: 0.003em;"></span></span><span style="display: inline-block; width: 0px; 
height: 4.002em;"></span></span></span></span><span class="mi" id="MathJax-Span-17" style="font-family: 
MathJax_Math-italic;">r</span><span class="mi" id="MathJax-Span-18" style="font-family: MathJax_Math-italic;">a</span><span 
class="mi" id="MathJax-Span-19" style="font-family: MathJax_Math-italic;">p</span><span class="mi" 
id="MathJax-Span-20" style="font-family: MathJax_Math-italic;">h</span><span class="mo" id="MathJax-Span-21" 
style="font-family: MathJax_Main; padding-left: 0.302em;">&gt;</span><span class="mi" id="MathJax-Span-22" 
style="font-family: MathJax_Math-italic; padding-left: 0.302em;">c</span><span class="mi" id="MathJax-Span-23" 
style="font-family: MathJax_Math-italic;">u</span><span class="mi" id="MathJax-Span-24" style="font-family: 
MathJax_Math-italic;">r</span><span class="mi" id="MathJax-Span-25" style="font-family: MathJax_Math-italic;">r</span><span 
class="mi" id="MathJax-Span-26" style="font-family: MathJax_Math-italic;">e</span><span class="mi" 
id="MathJax-Span-27" style="font-family: MathJax_Math-italic;">n</span><span class="msubsup" 
id="MathJax-Span-28"><span style="display: inline-block; position: relative; width: 0.703em; 
height: 0px;"><span style="position: absolute; clip: rect(3.202em, 1000.35em, 4.152em, -999.998em); 
top: -3.998em; left: 0em;"><span class="mi" id="MathJax-Span-29" style="font-family: MathJax_Math-italic;">t</span><span 
style="display: inline-block; width: 0px; height: 4.002em;"></span></span><span style="position: 
absolute; top: -3.848em; left: 0.352em;"><span class="mi" id="MathJax-Span-30" style="font-size: 
70.7%; font-family: MathJax_Math-italic;">t</span><span style="display: inline-block; width: 
0px; height: 4.002em;"></span></span></span></span><span class="mi" id="MathJax-Span-31" style="font-family: 
MathJax_Math-italic;">r</span><span class="mi" id="MathJax-Span-32" style="font-family: MathJax_Math-italic;">a</span><span 
class="mi" id="MathJax-Span-33" style="font-family: MathJax_Math-italic;">c</span><span class="mi" 
id="MathJax-Span-34" style="font-family: MathJax_Math-italic;">e</span><span class="mi" id="MathJax-Span-35" 
style="font-family: MathJax_Math-italic;">r</span></span><span style="display: inline-block; 
width: 0px; height: 2.353em;"></span></span></span><span style="display: inline-block; overflow: 
hidden; vertical-align: -0.434em; border-left: 0px solid; width: 0px; height: 1.378em;"></span></span> 
</nobr><span class="MJX_Assistive_MathML" role="presentation"> <math xmlns="http://www.w3.org/1998/Math/MathML"> 
<mi> e </mi><mi> c </mi><mi> h </mi><mi> o </mi><mi> f </mi><mi> u </mi><mi> n </mi><mi> c 
</mi><mi> t </mi><mi> i </mi><mi> o </mi><msub> <mi> n </mi> <mi> g </mi> </msub><mi> r </mi><mi> 
a </mi><mi> p </mi><mi> h </mi><mo> &gt; </mo><mi> c </mi><mi> u </mi><mi> r </mi><mi> r </mi><mi> 
e </mi><mi> n </mi><msub> <mi> t </mi> <mi> t </mi> </msub><mi> r </mi><mi> a </mi><mi> c </mi><mi> 
e </mi><mi> r </mi> </math></span></span> <script type="math/tex" id="MathJax-Element-1"></script> 
echo funcgraph-proc &gt; trace_options </div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> 
</div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 谢谢分享</p> </div> </div></li> <li 
class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/14/11/4b/fa64f061.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>xfan</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-22 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> </div> <!----> 
<!----> </div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 我的机器一运行 <br>echo function_graph 
&gt; current_trace或trace-cmd的命令就卡死，tty1也输入不了，我现在是ubuntu18.04 双处理器 1G内存 <br> </div> <!----> 
<div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 这个问题我也是第一次见到，检查下系统日志里面有没有错误？</p> </div> 
</div></li> <li class="reJj6Thl_0"><img src="https://wx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEKQMM4m7NHuicr55aRiblTSEWIYe0QqbpyHweaoAbG7j2v7UUElqqeP3Ihrm3UfDPDRb1Hv8LvPwXqA/132" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>ninuxer</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-20 </div> </div> <div 
class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> 
</div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0"> 打卡day53 <br>个人认为perf的功能全面，可用于系统和内核的分析，ftrace用于内核级别的分析～ 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <!----> </div></li> 
<li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/0f/42/76/abb7bfe3.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>松花皮蛋me</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-20 </div> </div> <div 
class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> 
</div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0"> 这篇完全听不懂 </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <!----> </div></li> <li class="reJj6Thl_0"><img 
src="https://static001.geekbang.org/account/avatar/00/12/05/7f/d35ab9a1.jpg" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>z.l</span> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2019-04-21 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 请教下java里常用的btrace和今天讲的几个工具是什么关系啊 </div> 
<!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 今天介绍的工具都是系统级工具，可以用在任何应用；而btrace是应用级的，只能用在Java应用上。</p> 
</div> </div></li> <li class="reJj6Thl_0"><img src="" class="_2273kGdT_0"> <div class="_2CG0SquK_0"> 
<div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>如果</span> <!----> </div> <div 
class="_1H1Z49Dr_0"> 2019-04-18 </div> </div> <div class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> 
<i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> </div> </div> <div 
class="_3M6kV3zb_0"> DAY50，打卡 </div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> 
</div> <!----> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/14/3a/6e/e39e90ca.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>大坏狐狸</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-04-12 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> $ trace-cmd record -p function_graph -g 
do_sys_open -O funcgraph-proc ls 这个执行之后就弹出一个框，说宿主机CPU巴拉巴拉，就把我机器卡死了。。。只能用网管重启大法。。。 </div> <!----> 
<!----> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/14/14/2e/400913b1.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>金波</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-25 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> 请教老师个问题，遇到一个问题是，嵌入式linux系统上，几秒钟之内某个进城突然导致OOM。 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请问有没有什么好的方法调查或者捕捉谁短时间占用大量内存吗？ 
脚本几秒检测maps试过，捕捉不到。内存钩子一是不线程安全，再就是应该用了tcmalloc，应该也不行。 valgrind太重量级，大程序跑不动。多谢 </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 
动态追踪（比如bcc或者systemtap）应该是最好用的方法了。如果发送了OOM，从系统日志里面也可以找到线索</p> </div> </div></li> <li class="reJj6Thl_0"><img 
src="https://static001.geekbang.org/account/avatar/00/12/58/4d/fec92a8d.jpg" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>arron</span> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-21 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> 执行第二步报错： <br>#echo function_graph &gt; current_trace 
<br>-bash: current_trace: Permission denied <br> <br>用root用户操作的，这是为何？ </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 
试试留言中青石的方法可以吗</p> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/12/58/4d/fec92a8d.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>arron</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-21 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> 执行第二步是报错： <br>#echo function_graph &gt; current_trace 
<br>-bash: current_trace: Permission denied <br> <br>root用户执行的，为何没权限，何解？ </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 
试试留言中青石的方法可以吗</p> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/13/9c/47/50cf2cab.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>Chn.K</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-20 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> 老师，请教个问题，对于踩内存导致的coredump问题（从core文件大致能看出来内存已经乱了，但是看不出来是哪里把内存搞乱了），有没有好的定位方法？ 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: coredump提供了问题的现场，从coredump分析（比如使用GDB）应该就是最好的方法了，</p> </div> </div></li> 
<li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/11/9b/ba/333b59e5.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>Linuxer</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-20 </div> </div> <div 
class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> 
</div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0"> 楼上这位可以翻译分享吗？ </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <!----> </div></li> <li class="reJj6Thl_0"><img 
src="https://static001.geekbang.org/account/avatar/00/10/5c/cb/3ebdcc49.jpg" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>怀特</span> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-20 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> 这一节有些跟不上了。越来越深入内核了。 </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 
这里有些工具也适用于用户态分析的</p> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/11/9b/ba/333b59e5.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>Linuxer</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-20 </div> </div> <div 
class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> 
</div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 老师，碰到一个问题怎么选择tracepoint和tracefunction呢？然后怎么结合输出分析问题呢？ 
</div> <!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 先要用其他工具定位出大概的位置，比如用perf或者bcc等等。有了函数之后，再回来跟踪函数的内部。</p> 
</div> </div></li> <li class="reJj6Thl_0"><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJLm7IbU8V19ENfAnAaeibr4X5zQDw2yI8pHy1xtRgVC7S0YjdqI6jKlcQ0ueicuCaIkebSTNelRibsA/132" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>全大神啊</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-20 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> 这个专栏很不错，学了很多干货，老师挺负责任的，希望老师以后多多开点专栏，分享新知识，开了记得通知😙 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 谢谢支持😊</p> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/11/97/82/cdf57a77.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>西红柿牛腩</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-20 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> 新技能Get✅ </div> <div class="_2r3UB1GX_0"> <span>展开</span><i 
class="iconfont"></i> </div> <!----> </div></li>', delta=0, field_comment_format='full_html', 
langcode='zh-hans', revision_id=1083 where entity_id=1083 
 {executed in 1 msec}
2020-11-25 10:16:52.955 INFO  jdbc.sqltiming Line:373 - select nodefieldc0_.entity_id as entity_i1_14_0_, nodefieldc0_.bundle as bundle2_14_0_, nodefieldc0_.field_comment_value 
as field_co3_14_0_, nodefieldc0_.delta as delta4_14_0_, nodefieldc0_.field_comment_format as 
field_co5_14_0_, nodefieldc0_.langcode as langcode6_14_0_, nodefieldc0_.revision_id as revision7_14_0_ 
from node_revision__field_comment nodefieldc0_ where nodefieldc0_.entity_id=1083 
 {executed in 0 msec}
2020-11-25 10:16:52.955 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|--------------------|------|---------------------|---------|------------|
|entity_id |bundle |field_comment_value |delta |field_comment_format |langcode |revision_id |
|----------|-------|--------------------|------|---------------------|---------|------------|
|[unread]  |book   |                    |0     |full_html            |zh-hans  |1083        |
|----------|-------|--------------------|------|---------------------|---------|------------|

2020-11-25 10:16:52.958 INFO  jdbc.sqltiming Line:373 - update node_revision__field_comment set bundle='book', field_comment_value='<li class="reJj6Thl_0"><img 
src="https://static001.geekbang.org/account/avatar/00/15/2c/51/fdf460ba.jpg" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>lizh</span> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-20 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">9</span> </div> <!----> 
<!----> </div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 早些时间整理过的一篇文章，和这个主题很match，分享在这里^_^。https://leezhenghui.github.io/linux/2019/03/05/exploring-usdt-on-linux.html 
</div> <!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 👍谢谢分享</p> </div> </div></li> 
<li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/0f/bd/ac/c9154dfe.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>Huayra</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-20 </div> </div> <div 
class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">4</span> 
</div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0"> 将性能优化大师Brendan Gregg的blog阅读一遍，就能够更深刻地理解这一章。据说，OpenResty的作者张亦春也阅读过Brendan 
Gregg的所有博客，他现在更进一步地开发了一个将高级编程语言编译成动态追踪脚本的工具 </div> <div class="_2r3UB1GX_0"> <span>展开</span><i 
class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 👍</p> 
</div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>我来也</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-20 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">2</span> </div> <!----> 
<!----> </div> </div> <div class="_3M6kV3zb_0"> [D50打卡] <br>课后思考题,我的思考,不一定准确. <br>我觉得昨天的perf和火焰图,是采样. 
而今天的ftrace是实实在在的分析每次一的调用. <br>虽然都可以看调用堆栈和耗时比例. 但是ftrace应该是非常准确,而perf只是一个采样,比如采样频率1%. <br> <br>我觉得找大方向时,使用perf和火焰图, 
找具体问题时,用ftrace.毕竟ftrace需要知道调用的系统函数. <br>ftrace需要追踪的信息可以来源于perf的分析结果. </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 
嗯嗯，非常准确。函数跟踪需要实现知道函数名，而perf/火焰图就可以找出热点函数。</p> </div> </div></li> <li class="reJj6Thl_0"><img 
src="https://static001.geekbang.org/account/avatar/00/14/5b/ae/3d639ea4.jpg" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>佳</span> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-23 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> </div> <!----> 
<!----> </div> </div> <div class="_3M6kV3zb_0"> 在和同事讨论nodejs使用从thrift转化到grpc时候会性能下降问题就用老师介绍 
<br> <br>strace -T -ttt -p pid <br> <br>找到根源。 <br> <br>grpc -node版本发送分两次writev系统调用，第一次发送 grpc路径，第二次发送参数。比thrift协议一次效率一些。 
<br> <br>再发现node并发次数多，回调算时间往往是多个调用所花的时间。这些效率都用strace看到，在前面时间 </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 
👍谢谢分享</p> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/12/8c/2b/3ab96998.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>青石</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-22 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> </div> <!----> 
<!----> </div> </div> <div class="_3M6kV3zb_0"> #echo function_graph &gt; current_trace <br>-bash: 
current_trace: Permission denied <br> <br>报上面错误的同学，可以尝试下面的命令，环境是CentOS 7.6 <br><span class="MathJax_Preview" 
style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-1-Frame" 
tabindex="0" style="position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>e</mi><mi>c</mi><mi>h</mi><mi>o</mi><mi>f</mi><mi>u</mi><mi>n</mi><mi>c</mi><mi>t</mi><mi>i</mi><mi>o</mi><msub><mi>n</mi><mi>g</mi></msub><mi>r</mi><mi>a</mi><mi>p</mi><mi>h</mi><mo>></mo><mi>c</mi><mi>u</mi><mi>r</mi><mi>r</mi><mi>e</mi><mi>n</mi><msub><mi>t</mi><mi>t</mi></msub><mi>r</mi><mi>a</mi><mi>c</mi><mi>e</mi><mi>r</mi></math>" 
role="presentation"> <nobr aria-hidden="true"> <span class="math" id="MathJax-Span-1" style="width: 
19.703em; display: inline-block;"><span style="display: inline-block; position: relative; width: 
15.753em; height: 0px; font-size: 125%;"><span style="position: absolute; clip: rect(1.502em, 
1015.75em, 2.802em, -999.998em); top: -2.348em; left: 0em;"><span class="mrow" id="MathJax-Span-2"><span 
class="mi" id="MathJax-Span-3" style="font-family: MathJax_Math-italic;">e</span><span class="mi" 
id="MathJax-Span-4" style="font-family: MathJax_Math-italic;">c</span><span class="mi" id="MathJax-Span-5" 
style="font-family: MathJax_Math-italic;">h</span><span class="mi" id="MathJax-Span-6" style="font-family: 
MathJax_Math-italic;">o</span><span class="mi" id="MathJax-Span-7" style="font-family: MathJax_Math-italic;">f<span 
style="display: inline-block; overflow: hidden; height: 1px; width: 0.053em;"></span></span><span 
class="mi" id="MathJax-Span-8" style="font-family: MathJax_Math-italic;">u</span><span class="mi" 
id="MathJax-Span-9" style="font-family: MathJax_Math-italic;">n</span><span class="mi" id="MathJax-Span-10" 
style="font-family: MathJax_Math-italic;">c</span><span class="mi" id="MathJax-Span-11" style="font-family: 
MathJax_Math-italic;">t</span><span class="mi" id="MathJax-Span-12" style="font-family: MathJax_Math-italic;">i</span><span 
class="mi" id="MathJax-Span-13" style="font-family: MathJax_Math-italic;">o</span><span class="msubsup" 
id="MathJax-Span-14"><span style="display: inline-block; position: relative; width: 1.002em; 
height: 0px;"><span style="position: absolute; clip: rect(3.402em, 1000.6em, 4.152em, -999.998em); 
top: -3.998em; left: 0em;"><span class="mi" id="MathJax-Span-15" style="font-family: MathJax_Math-italic;">n</span><span 
style="display: inline-block; width: 0px; height: 4.002em;"></span></span><span style="position: 
absolute; top: -3.848em; left: 0.603em;"><span class="mi" id="MathJax-Span-16" style="font-size: 
70.7%; font-family: MathJax_Math-italic;">g<span style="display: inline-block; overflow: hidden; 
height: 1px; width: 0.003em;"></span></span><span style="display: inline-block; width: 0px; 
height: 4.002em;"></span></span></span></span><span class="mi" id="MathJax-Span-17" style="font-family: 
MathJax_Math-italic;">r</span><span class="mi" id="MathJax-Span-18" style="font-family: MathJax_Math-italic;">a</span><span 
class="mi" id="MathJax-Span-19" style="font-family: MathJax_Math-italic;">p</span><span class="mi" 
id="MathJax-Span-20" style="font-family: MathJax_Math-italic;">h</span><span class="mo" id="MathJax-Span-21" 
style="font-family: MathJax_Main; padding-left: 0.302em;">&gt;</span><span class="mi" id="MathJax-Span-22" 
style="font-family: MathJax_Math-italic; padding-left: 0.302em;">c</span><span class="mi" id="MathJax-Span-23" 
style="font-family: MathJax_Math-italic;">u</span><span class="mi" id="MathJax-Span-24" style="font-family: 
MathJax_Math-italic;">r</span><span class="mi" id="MathJax-Span-25" style="font-family: MathJax_Math-italic;">r</span><span 
class="mi" id="MathJax-Span-26" style="font-family: MathJax_Math-italic;">e</span><span class="mi" 
id="MathJax-Span-27" style="font-family: MathJax_Math-italic;">n</span><span class="msubsup" 
id="MathJax-Span-28"><span style="display: inline-block; position: relative; width: 0.703em; 
height: 0px;"><span style="position: absolute; clip: rect(3.202em, 1000.35em, 4.152em, -999.998em); 
top: -3.998em; left: 0em;"><span class="mi" id="MathJax-Span-29" style="font-family: MathJax_Math-italic;">t</span><span 
style="display: inline-block; width: 0px; height: 4.002em;"></span></span><span style="position: 
absolute; top: -3.848em; left: 0.352em;"><span class="mi" id="MathJax-Span-30" style="font-size: 
70.7%; font-family: MathJax_Math-italic;">t</span><span style="display: inline-block; width: 
0px; height: 4.002em;"></span></span></span></span><span class="mi" id="MathJax-Span-31" style="font-family: 
MathJax_Math-italic;">r</span><span class="mi" id="MathJax-Span-32" style="font-family: MathJax_Math-italic;">a</span><span 
class="mi" id="MathJax-Span-33" style="font-family: MathJax_Math-italic;">c</span><span class="mi" 
id="MathJax-Span-34" style="font-family: MathJax_Math-italic;">e</span><span class="mi" id="MathJax-Span-35" 
style="font-family: MathJax_Math-italic;">r</span></span><span style="display: inline-block; 
width: 0px; height: 2.353em;"></span></span></span><span style="display: inline-block; overflow: 
hidden; vertical-align: -0.434em; border-left: 0px solid; width: 0px; height: 1.378em;"></span></span> 
</nobr><span class="MJX_Assistive_MathML" role="presentation"> <math xmlns="http://www.w3.org/1998/Math/MathML"> 
<mi> e </mi><mi> c </mi><mi> h </mi><mi> o </mi><mi> f </mi><mi> u </mi><mi> n </mi><mi> c 
</mi><mi> t </mi><mi> i </mi><mi> o </mi><msub> <mi> n </mi> <mi> g </mi> </msub><mi> r </mi><mi> 
a </mi><mi> p </mi><mi> h </mi><mo> &gt; </mo><mi> c </mi><mi> u </mi><mi> r </mi><mi> r </mi><mi> 
e </mi><mi> n </mi><msub> <mi> t </mi> <mi> t </mi> </msub><mi> r </mi><mi> a </mi><mi> c </mi><mi> 
e </mi><mi> r </mi> </math></span></span> <script type="math/tex" id="MathJax-Element-1"></script> 
echo funcgraph-proc &gt; trace_options </div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> 
</div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 谢谢分享</p> </div> </div></li> <li 
class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/14/11/4b/fa64f061.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>xfan</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-22 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> </div> <!----> 
<!----> </div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 我的机器一运行 <br>echo function_graph 
&gt; current_trace或trace-cmd的命令就卡死，tty1也输入不了，我现在是ubuntu18.04 双处理器 1G内存 <br> </div> <!----> 
<div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 这个问题我也是第一次见到，检查下系统日志里面有没有错误？</p> </div> 
</div></li> <li class="reJj6Thl_0"><img src="https://wx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEKQMM4m7NHuicr55aRiblTSEWIYe0QqbpyHweaoAbG7j2v7UUElqqeP3Ihrm3UfDPDRb1Hv8LvPwXqA/132" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>ninuxer</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-20 </div> </div> <div 
class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> 
</div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0"> 打卡day53 <br>个人认为perf的功能全面，可用于系统和内核的分析，ftrace用于内核级别的分析～ 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <!----> </div></li> 
<li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/0f/42/76/abb7bfe3.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>松花皮蛋me</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-20 </div> </div> <div 
class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> 
</div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0"> 这篇完全听不懂 </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <!----> </div></li> <li class="reJj6Thl_0"><img 
src="https://static001.geekbang.org/account/avatar/00/12/05/7f/d35ab9a1.jpg" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>z.l</span> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2019-04-21 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 请教下java里常用的btrace和今天讲的几个工具是什么关系啊 </div> 
<!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 今天介绍的工具都是系统级工具，可以用在任何应用；而btrace是应用级的，只能用在Java应用上。</p> 
</div> </div></li> <li class="reJj6Thl_0"><img src="" class="_2273kGdT_0"> <div class="_2CG0SquK_0"> 
<div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>如果</span> <!----> </div> <div 
class="_1H1Z49Dr_0"> 2019-04-18 </div> </div> <div class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> 
<i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> </div> </div> <div 
class="_3M6kV3zb_0"> DAY50，打卡 </div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> 
</div> <!----> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/14/3a/6e/e39e90ca.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>大坏狐狸</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-04-12 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> $ trace-cmd record -p function_graph -g 
do_sys_open -O funcgraph-proc ls 这个执行之后就弹出一个框，说宿主机CPU巴拉巴拉，就把我机器卡死了。。。只能用网管重启大法。。。 </div> <!----> 
<!----> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/14/14/2e/400913b1.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>金波</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-25 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> 请教老师个问题，遇到一个问题是，嵌入式linux系统上，几秒钟之内某个进城突然导致OOM。 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请问有没有什么好的方法调查或者捕捉谁短时间占用大量内存吗？ 
脚本几秒检测maps试过，捕捉不到。内存钩子一是不线程安全，再就是应该用了tcmalloc，应该也不行。 valgrind太重量级，大程序跑不动。多谢 </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 
动态追踪（比如bcc或者systemtap）应该是最好用的方法了。如果发送了OOM，从系统日志里面也可以找到线索</p> </div> </div></li> <li class="reJj6Thl_0"><img 
src="https://static001.geekbang.org/account/avatar/00/12/58/4d/fec92a8d.jpg" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>arron</span> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-21 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> 执行第二步报错： <br>#echo function_graph &gt; current_trace 
<br>-bash: current_trace: Permission denied <br> <br>用root用户操作的，这是为何？ </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 
试试留言中青石的方法可以吗</p> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/12/58/4d/fec92a8d.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>arron</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-21 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> 执行第二步是报错： <br>#echo function_graph &gt; current_trace 
<br>-bash: current_trace: Permission denied <br> <br>root用户执行的，为何没权限，何解？ </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 
试试留言中青石的方法可以吗</p> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/13/9c/47/50cf2cab.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>Chn.K</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-20 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> 老师，请教个问题，对于踩内存导致的coredump问题（从core文件大致能看出来内存已经乱了，但是看不出来是哪里把内存搞乱了），有没有好的定位方法？ 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: coredump提供了问题的现场，从coredump分析（比如使用GDB）应该就是最好的方法了，</p> </div> </div></li> 
<li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/11/9b/ba/333b59e5.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>Linuxer</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-20 </div> </div> <div 
class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> 
</div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0"> 楼上这位可以翻译分享吗？ </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <!----> </div></li> <li class="reJj6Thl_0"><img 
src="https://static001.geekbang.org/account/avatar/00/10/5c/cb/3ebdcc49.jpg" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>怀特</span> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-20 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> 这一节有些跟不上了。越来越深入内核了。 </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 
这里有些工具也适用于用户态分析的</p> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/11/9b/ba/333b59e5.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>Linuxer</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-20 </div> </div> <div 
class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> 
</div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 老师，碰到一个问题怎么选择tracepoint和tracefunction呢？然后怎么结合输出分析问题呢？ 
</div> <!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 先要用其他工具定位出大概的位置，比如用perf或者bcc等等。有了函数之后，再回来跟踪函数的内部。</p> 
</div> </div></li> <li class="reJj6Thl_0"><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJLm7IbU8V19ENfAnAaeibr4X5zQDw2yI8pHy1xtRgVC7S0YjdqI6jKlcQ0ueicuCaIkebSTNelRibsA/132" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>全大神啊</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-20 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> 这个专栏很不错，学了很多干货，老师挺负责任的，希望老师以后多多开点专栏，分享新知识，开了记得通知😙 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 谢谢支持😊</p> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/11/97/82/cdf57a77.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>西红柿牛腩</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-20 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> 新技能Get✅ </div> <div class="_2r3UB1GX_0"> <span>展开</span><i 
class="iconfont"></i> </div> <!----> </div></li>', delta=0, field_comment_format='full_html', 
langcode='zh-hans', revision_id=1083 where entity_id=1083 
 {executed in 0 msec}
2020-11-25 10:16:52.961 INFO  jdbc.sqltiming Line:373 - select bookfieldt0_.entity_id as entity_i1_9_, bookfieldt0_.bundle as bundle2_9_, bookfieldt0_.delta 
as delta3_9_, bookfieldt0_.langcode as langcode4_9_, bookfieldt0_.revision_id as revision5_9_, 
bookfieldt0_.field_thumb_value as field_th6_9_ from node__field_thumb bookfieldt0_ where bookfieldt0_.entity_id=1083 
 {executed in 0 msec}
2020-11-25 10:16:52.961 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------|------------------|
|entity_id |bundle |delta |langcode |revision_id |field_thumb_value |
|----------|-------|------|---------|------------|------------------|
|1083      |book   |0     |zh-hans  |1083        |                  |
|----------|-------|------|---------|------------|------------------|

2020-11-25 10:16:52.963 INFO  jdbc.sqltiming Line:373 - update node__field_thumb set bundle='book', delta=0, langcode='zh-hans', revision_id=1083, 
field_thumb_value='https://static001.geekbang.org/resource/image/3a/1c/3a7edc929e0c27e18fe9f1c90505b51c.jpg' 
where entity_id=1083 
 {executed in 0 msec}
2020-11-25 10:16:52.965 INFO  jdbc.sqltiming Line:373 - select nodefieldt0_.entity_id as entity_i1_18_0_, nodefieldt0_.bundle as bundle2_18_0_, nodefieldt0_.delta 
as delta3_18_0_, nodefieldt0_.langcode as langcode4_18_0_, nodefieldt0_.revision_id as revision5_18_0_, 
nodefieldt0_.field_thumb_value as field_th6_18_0_ from node_revision__field_thumb nodefieldt0_ 
where nodefieldt0_.entity_id=1083 
 {executed in 0 msec}
2020-11-25 10:16:52.966 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------|------------------|
|entity_id |bundle |delta |langcode |revision_id |field_thumb_value |
|----------|-------|------|---------|------------|------------------|
|[unread]  |book   |0     |zh-hans  |1083        |                  |
|----------|-------|------|---------|------------|------------------|

2020-11-25 10:16:52.967 INFO  jdbc.sqltiming Line:373 - update node_revision__field_thumb set bundle='book', delta=0, langcode='zh-hans', revision_id=1083, 
field_thumb_value='https://static001.geekbang.org/resource/image/3a/1c/3a7edc929e0c27e18fe9f1c90505b51c.jpg' 
where entity_id=1083 
 {executed in 0 msec}
2020-11-25 10:16:52.970 INFO  jdbc.sqltiming Line:373 - select bookfieldf0_.entity_id as entity_i1_6_0_, bookfieldf0_.bundle as bundle2_6_0_, bookfieldf0_.delta 
as delta3_6_0_, bookfieldf0_.field_fenlei_target_id as field_fe4_6_0_, bookfieldf0_.langcode 
as langcode5_6_0_, bookfieldf0_.revision_id as revision6_6_0_ from node__field_fenlei bookfieldf0_ 
where bookfieldf0_.entity_id=1083 
 {executed in 1 msec}
2020-11-25 10:16:52.970 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|-----------------------|---------|------------|
|entity_id |bundle |delta |field_fenlei_target_id |langcode |revision_id |
|----------|-------|------|-----------------------|---------|------------|
|[unread]  |book   |0     |1                      |zh-hans  |1083        |
|----------|-------|------|-----------------------|---------|------------|

2020-11-25 10:16:52.971 INFO  jdbc.sqltiming Line:373 - select nodefieldf0_.entity_id as entity_i1_15_0_, nodefieldf0_.bundle as bundle2_15_0_, nodefieldf0_.delta 
as delta3_15_0_, nodefieldf0_.field_fenlei_target_id as field_fe4_15_0_, nodefieldf0_.langcode 
as langcode5_15_0_, nodefieldf0_.revision_id as revision6_15_0_ from node_revision__field_fenlei 
nodefieldf0_ where nodefieldf0_.entity_id=1083 
 {executed in 0 msec}
2020-11-25 10:16:52.972 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|-----------------------|---------|------------|
|entity_id |bundle |delta |field_fenlei_target_id |langcode |revision_id |
|----------|-------|------|-----------------------|---------|------------|
|[unread]  |book   |0     |1                      |zh-hans  |1083        |
|----------|-------|------|-----------------------|---------|------------|

2020-11-25 10:16:52.973 INFO  jdbc.sqltiming Line:373 - select bookchecke0_.item_id as item_id1_2_, bookchecke0_.fsid as fsid2_2_, bookchecke0_.got 
as got3_2_, bookchecke0_.name as name4_2_, bookchecke0_.parse_fail as parse_fa5_2_, bookchecke0_.parsed 
as parsed6_2_, bookchecke0_.path as path7_2_, bookchecke0_.title as title8_2_, bookchecke0_.vid 
as vid9_2_ from book_check bookchecke0_ where bookchecke0_.fsid='795796920256182' and bookchecke0_.name='net_content' 
 {executed in 0 msec}
2020-11-25 10:16:52.974 INFO  jdbc.resultsettable Line:610 - 
|--------|---------|---------|---------|-----------|---------|---------|---------|---------|
|item_id |fsid     |got      |name     |parse_fail |parsed   |path     |title    |vid      |
|--------|---------|---------|---------|-----------|---------|---------|---------|---------|
|1084    |[unread] |[unread] |[unread] |[unread]   |[unread] |[unread] |[unread] |[unread] |
|--------|---------|---------|---------|-----------|---------|---------|---------|---------|

2020-11-25 10:17:27.722 INFO  jdbc.sqltiming Line:373 - update book_check set fsid='795796920256182', got=1, name='net_content', parse_fail='', parsed=1, 
path='12-Linux性能优化实战/06-综合实战篇 (13讲)/51丨案例篇：动态追踪怎么用？（下）.html', title='51丨案例篇：动态追踪怎么用？（下）', vid=1084 
where item_id=1084 
 {executed in 0 msec}
2020-11-25 10:17:27.729 INFO  jdbc.sqltiming Line:373 - select nodebodyen0_.entity_id as entity_i1_4_, nodebodyen0_.body_value as body_val2_4_, nodebodyen0_.body_summary 
as body_sum3_4_, nodebodyen0_.bundle as bundle4_4_, nodebodyen0_.delta as delta5_4_, nodebodyen0_.body_format 
as body_for6_4_, nodebodyen0_.langcode as langcode7_4_, nodebodyen0_.revision_id as revision8_4_ 
from node__body nodebodyen0_ where nodebodyen0_.entity_id=1084 
 {executed in 0 msec}
2020-11-25 10:17:27.730 INFO  jdbc.resultsettable Line:610 - 
|----------|-----------|-------------|-------|------|------------|---------|------------|
|entity_id |body_value |body_summary |bundle |delta |body_format |langcode |revision_id |
|----------|-----------|-------------|-------|------|------------|---------|------------|
|1084      |           |             |book   |0     |full_html   |zh-hans  |1084        |
|----------|-----------|-------------|-------|------|------------|---------|------------|

2020-11-25 10:17:27.731 INFO  jdbc.sqltiming Line:373 - select nodebodyre0_.entity_id as entity_i1_13_0_, nodebodyre0_.body_value as body_val2_13_0_, 
nodebodyre0_.body_summary as body_sum3_13_0_, nodebodyre0_.bundle as bundle4_13_0_, nodebodyre0_.delta 
as delta5_13_0_, nodebodyre0_.body_format as body_for6_13_0_, nodebodyre0_.langcode as langcode7_13_0_, 
nodebodyre0_.revision_id as revision8_13_0_ from node_revision__body nodebodyre0_ where nodebodyre0_.entity_id=1084 
 {executed in 0 msec}
2020-11-25 10:17:27.732 INFO  jdbc.resultsettable Line:610 - 
|----------|-----------|-------------|-------|------|------------|---------|------------|
|entity_id |body_value |body_summary |bundle |delta |body_format |langcode |revision_id |
|----------|-----------|-------------|-------|------|------------|---------|------------|
|[unread]  |           |             |book   |0     |full_html   |zh-hans  |1084        |
|----------|-----------|-------------|-------|------|------------|---------|------------|

2020-11-25 10:17:27.735 INFO  jdbc.sqltiming Line:373 - update node__body set body_value='<p>你好，我是倪朋飞。</p> <p>上一节，我带你一起学习了常见的动态追踪方法。所谓动态追踪，就是在系统或者应用程序正常运行的时候，通过内核中提供的探针，来动态追踪它们的行为，从而辅助排查出性能问题的瓶颈。</p> 
<p>使用动态追踪，可以在不修改代码、不重启服务的情况下，动态了解应用程序或者内核的行为，这对排查线上问题、特别是不容易重现的问题尤其有效。</p> <p>在 Linux 系统中，常见的动态追踪方法包括 
ftrace、perf、eBPF 以及 SystemTap 等。上节课，我们具体学习了 ftrace 的使用方法。今天，我们再来一起看看其他几种方法。</p> <h2>perf</h2> 
<p>perf 已经是我们的老朋友了。在前面的案例中，我们多次用到它，来查找应用程序或者内核中的热点函数，从而定位性能瓶颈。而在内核线程 CPU 高的案例中，我们还使用火焰图动态展示 
perf 的事件记录，从而更直观地发现了问题。</p> <p>不过，我们前面使用 perf record/top 时，都是先对事件进行采样，然后再根据采样数，评估各个函数的调用频率。实际上，perf 
的功能远不止于此。比如，</p> <ul> <li> <p>perf 可以用来分析 CPU cache、CPU 迁移、分支预测、指令周期等各种硬件事件；</p> </li> <li> 
<p>perf 也可以只对感兴趣的事件进行动态追踪。</p> </li> </ul><!-- [[[read_end]]] --> <p>接下来，我们还是以内核函数 do_sys_open，以及用户空间函数 
readline 为例，看一看 perf 动态追踪的使用方法。</p> <p>同 ftrace 一样，你也可以通过 perf list ，查询所有支持的事件：</p> <pre style="position: 
relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
$ perf list </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span 
class="iconfont"></span>复制代码 </div></pre> <p>然后，在 perf 的各个子命令中添加 --event 选项，设置追踪感兴趣的事件。如果这些预定义的事件不满足实际需要，你还可以使用 
perf probe 来动态添加。而且，除了追踪内核事件外，perf 还可以用来跟踪用户空间的函数。</p> <p><strong>我们先来看第一个 perf 示例，内核函数 do_sys_open 
的例子</strong>。你可以执行 perf probe 命令，添加 do_sys_open 探针：</p> <pre style="position: relative;"><code> 
<table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
$ perf probe --add do_sys_open </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
Added new event: </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
probe:do_sys_open (on do_sys_open) </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> <div 
class="hljs-ln-line"> You can now use it in all perf tools, such as: </div></td> </tr> <tr> 
<td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> perf record -e probe:do_sys_open -aR sleep 
1 </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>探针添加成功后，就可以在所有的 perf 子命令中使用。比如，上述输出就是一个 perf record 的示例，执行它就可以对 10s 内的 do_sys_open 
进行采样：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ perf record -e probe:do_sys_open -aR 
sleep 10 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> [ perf 
record: Woken up 1 times to write data ] </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> [ perf record: Captured and wrote 0.148 MB perf.data (19 samples) 
] </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>而采样成功后，就可以执行 perf script ，来查看采样结果了：</p> <pre style="position: relative;"><code> 
<table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
$ perf script </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
perf 12886 [000] 89565.879875: probe:do_sys_open: (ffffffffa807b290) </div></td> </tr> <tr> 
<td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> sleep 12889 [000] 89565.880362: probe:do_sys_open: 
(ffffffffa807b290) </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
sleep 12889 [000] 89565.880382: probe:do_sys_open: (ffffffffa807b290) </div></td> </tr> <tr> 
<td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> sleep 12889 [000] 89565.880635: probe:do_sys_open: 
(ffffffffa807b290) </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="6"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
sleep 12889 [000] 89565.880669: probe:do_sys_open: (ffffffffa807b290) </div></td> </tr> </tbody> 
</table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 </div></pre> 
<p>输出中，同样也列出了调用 do_sys_open 的任务名称、进程 PID 以及运行的 CPU 等信息。不过，对于 open 系统调用来说，只知道它被调用了并不够，我们需要知道的是，进程到底在打开哪些文件。所以，实际应用中，我们还希望追踪时能显示这些函数的参数。</p> 
<p>对于内核函数来说，你当然可以去查看内核源码，找出它的所有参数。不过还有更简单的方法，那就是直接从调试符号表中查询。执行下面的命令，你就可以知道 do_sys_open 的所有参数：</p> 
<pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> $ perf probe -V do_sys_open </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> Available variables at do_sys_open </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> @&lt;do_sys_open+0&gt; </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> char* filename </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> int dfd </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> <td class="hljs-ln-code"> <div 
class="hljs-ln-line"> int flags </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="7"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
struct open_flags op </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="8"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
umode_t mode </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <p>从这儿可以看出，我们关心的文件路径，就是第一个字符指针参数（也就是字符串），参数名称为 
filename。如果这个命令执行失败，就说明调试符号表还没有安装。那么，你可以执行下面的命令，安装调试信息后重试：</p> <pre style="position: relative;"><code> 
<table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
# Ubuntu </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> $ apt-get 
install linux-image-`uname -r`-dbgsym </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> <div 
class="hljs-ln-line"> # CentOS </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
$ yum --enablerepo=base-debuginfo install -y kernel-debuginfo-$(uname -r) </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> </div></td> </tr> </tbody> </table></code> 
<div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 </div></pre> <p>找出参数名称和类型后，就可以把参数加到探针中了。不过由于我们已经添加过同名探针，所以在这次添加前，需要先把旧探针给删掉：</p> 
<pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> # 先删除旧的探针 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> <div 
class="hljs-ln-line"> perf probe --del probe:do_sys_open </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
# 添加带参数的探针 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="5"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> $ perf 
probe --add ''do_sys_open filename:string'' </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> Added new event: </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> probe:do_sys_open (on do_sys_open with filename:string) </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> You can now use it in all perf tools, 
such as: </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="9"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> perf 
record -e probe:do_sys_open -aR sleep 1 </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <p>新的探针添加后，重新执行 record 和 script 子命令，采样并查看记录：</p> 
<pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> # 重新采样记录 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> <div 
class="hljs-ln-line"> $ perf record -e probe:do_sys_open -aR ls </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> # 查看结果 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> <td class="hljs-ln-code"> <div 
class="hljs-ln-line"> $ perf script </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> <td class="hljs-ln-code"> <div 
class="hljs-ln-line"> perf 13593 [000] 91846.053622: probe:do_sys_open: (ffffffffa807b290) 
filename_string="/proc/13596/status" </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></td> <td class="hljs-ln-code"> <div 
class="hljs-ln-line"> ls 13596 [000] 91846.053995: probe:do_sys_open: (ffffffffa807b290) filename_string="/etc/ld.so.cache" 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> ls 13596 [000] 91846.054011: probe:do_sys_open: 
(ffffffffa807b290) filename_string="/lib/x86_64-linux-gnu/libselinux.so.1" </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> ls 13596 [000] 91846.054066: probe:do_sys_open: 
(ffffffffa807b290) filename_string="/lib/x86_64-linux-gnu/libc.so.6” </div></td> </tr> <tr> 
<td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> ... </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> # 使用完成后不要忘记删除探针 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> $ perf probe --del probe:do_sys_open </div></td> </tr> </tbody> 
</table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 </div></pre> 
<p>现在，你就可以看到每次调用 open 时打开的文件了。不过，这个结果是不是看着很熟悉呢？</p> <p>其实，在我们使用 strace 跟踪进程的系统调用时，也经常会看到这些动态库的影子。比如，使用 
strace 跟踪 ls 时，你可以得到下面的结果：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> 
<tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ strace ls </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> ... </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or 
directory) </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="4"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> access("/etc/ld.so.preload", 
R_OK) = -1 ENOENT (No such file or directory) </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3 </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> ... </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or 
directory) </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="8"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> openat(AT_FDCWD, 
"/lib/x86_64-linux-gnu/libselinux.so.1", O_RDONLY|O_CLOEXEC) = 3 </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> ... </div></td> </tr> </tbody> </table></code> 
<div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 </div></pre> <p>你估计在想，既然 
strace 也能得到类似结果，本身又容易操作，为什么我们还要用 perf 呢？</p> <p>实际上，很多人只看到了 strace 简单易用的好处，却忽略了它对进程性能带来的影响。从原理上来说，<strong>strace 
基于系统调用 ptrace 实现</strong>，这就带来了两个问题。</p> <ul> <li> <p>由于 ptrace 是系统调用，就需要在内核态和用户态切换。当事件数量比较多时，繁忙的切换必然会影响原有服务的性能；</p> 
</li> <li> <p>ptrace 需要借助 SIGSTOP 信号挂起目标进程。这种信号控制和进程挂起，会影响目标进程的行为。</p> </li> </ul> <p>所以，在性能敏感的应用（比如数据库）中，我并不推荐你用 
strace （或者其他基于 ptrace 的性能工具）去排查和调试。</p> <p>在 strace 的启发下，结合内核中的 utrace 机制， perf 也提供了一个 trace 
子命令，是取代 strace 的首选工具。相对于 ptrace 机制来说，perf trace 基于内核事件，自然要比进程跟踪的性能好很多。</p> <p>perf trace 的使用方法如下所示，跟 
strace 其实很像：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> <tr> 
<td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ perf trace ls </div></td> </tr> <tr> 
<td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> ? ( ): ls/14234 ... [continued]: execve()) 
= 0 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="3"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 0.177 
( 0.013 ms): ls/14234 brk( ) = 0x555d96be7000 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 0.224 ( 0.014 ms): ls/14234 access(filename: 0xad98082 ) = -1 ENOENT 
No such file or directory </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="5"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
0.248 ( 0.009 ms): ls/14234 access(filename: 0xad9add0, mode: R ) = -1 ENOENT No such file 
or directory </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="6"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 0.267 
( 0.012 ms): ls/14234 openat(dfd: CWD, filename: 0xad98428, flags: CLOEXEC ) = 3 </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 0.288 ( 0.009 ms): ls/14234 fstat(fd: 
3&lt;/usr/lib/locale/C.UTF-8/LC_NAME&gt;, statbuf: 0x7ffd2015f230 ) = 0 </div></td> </tr> <tr> 
<td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 0.305 ( 0.011 ms): ls/14234 mmap(len: 
45560, prot: READ, flags: PRIVATE, fd: 3 ) = 0x7efe0af92000 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 0.324 Dockerfile test.sh </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> ( 0.008 ms): ls/14234 close(fd: 3&lt;/usr/lib/locale/C.UTF-8/LC_NAME&gt; 
) = 0 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="11"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> ... 
</div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>不过，perf trace 还可以进行系统级的系统调用跟踪（即跟踪所有进程），而 strace 只能跟踪特定的进程。</p> <p><strong>第二个 
perf 的例子是用户空间的库函数</strong>。以 bash 调用的库函数 readline 为例，使用类似的方法，可以跟踪库函数的调用（基于 uprobes）。</p> <p>readline 
的作用，是从终端中读取用户输入，并把这些数据返回调用方。所以，跟 open 系统调用不同的是，我们更关注 readline 的调用结果。</p> <p>我们执行下面的命令，通过 -x 
指定 bash 二进制文件的路径，就可以动态跟踪库函数。这其实就是跟踪了所有用户在 bash 中执行的命令：</p> <pre style="position: relative;"><code> 
<table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
# 为 /bin/bash 添加 readline 探针 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
$ perf probe -x /bin/bash ''readline%return +0($retval):string’ </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> # 采样记录 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> <td class="hljs-ln-code"> <div 
class="hljs-ln-line"> $ perf record -e probe_bash:readline__return -aR sleep 5 </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> # 查看结果 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></td> <td class="hljs-ln-code"> <div 
class="hljs-ln-line"> $ perf script </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></td> <td class="hljs-ln-code"> <div 
class="hljs-ln-line"> bash 13348 [000] 93939.142576: probe_bash:readline__return: (5626ffac1610 
&lt;- 5626ffa46739) arg1="ls" </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="10"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> # 跟踪完成后删除探针 </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ perf probe --del probe_bash:readline__return 
</div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>当然，如果你不确定探针格式，也可以通过下面的命令，查询所有支持的函数和函数参数：</p> <pre style="position: relative;"><code> 
<table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
# 查询所有的函数 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> $ perf 
probe -x /bin/bash —funcs </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> # 查询函数的参数 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> $ perf probe -x /bin/bash -V readline </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> Available variables at readline </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> @&lt;readline+0&gt; </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> char* prompt </div></td> </tr> </tbody> 
</table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 </div></pre> 
<p>跟内核函数类似，如果你想要查看普通应用的函数名称和参数，那么在应用程序的二进制文件中，同样需要包含调试信息。</p> <h2>eBPF 和 BCC</h2> <p>ftrace 
和 perf 的功能已经比较丰富了，不过，它们有一个共同的缺陷，那就是不够灵活，没法像 DTrace 那样通过脚本自由扩展。</p> <p>而 eBPF 就是 Linux 版的 DTrace，可以通过 
C 语言自由扩展（这些扩展通过 LLVM 转换为 BPF 字节码后，加载到内核中执行）。下面这张图，就表示了 eBPF 追踪的工作原理：</p> <p><img src="https://static001.geekbang.org/resource/image/a3/e9/a3547f2ac1d4d75b850a02a2735560e9.png" 
alt=""></p> <p>（图片来自 <a href="https://thenewstack.io/long-last-linux-gets-dynamic-tracing/">THE 
NEW STACK</a>）</p> <p>从图中你可以看到，eBPF 的执行需要三步：</p> <ul> <li> <p>从用户跟踪程序生成 BPF 字节码；</p> </li> 
<li> <p>加载到内核中运行；</p> </li> <li> <p>向用户空间输出结果。</p> </li> </ul> <p>所以，从使用上来说，eBPF 要比我们前面看到的 
ftrace 和 perf ，都更加繁杂。</p> <p>实际上，在 eBPF 执行过程中，编译、加载还有 maps 等操作，对所有的跟踪程序来说都是通用的。把这些过程通过 Python 
抽象起来，也就诞生了 BCC（BPF Compiler Collection）。</p> <p>BCC 把 eBPF 中的各种事件源（比如 kprobe、uprobe、tracepoint 
等）和数据操作（称为 Maps），也都转换成了 Python 接口（也支持 lua）。这样，使用 BCC 进行动态追踪时，编写简单的脚本就可以了。</p> <p>不过要注意，因为需要跟内核中的数据结构交互，真正核心的事件处理逻辑，还是需要我们用 
C 语言来编写。</p> <p>至于 BCC 的安装方法，在内存模块的<a href="https://time.geekbang.org/column/article/0?cid=140">缓存案例</a>中，我就已经介绍过了。如果你还没有安装过，可以执行下面的命令来安装（其他系统的安装请参考<a 
href="https://github.com/iovisor/bcc/blob/master/INSTALL.md">这里</a>）：</p> <pre style="position: 
relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
# Ubuntu </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> sudo 
apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 4052245BD4284CDD </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> echo "deb https://repo.iovisor.org/apt/$(lsb_release 
-cs) $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/iovisor.list </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> sudo apt-get update </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> sudo apt-get install bcc-tools libbcc-examples 
linux-headers-$(uname -r) </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="6"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> # REHL 7.6 </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> yum install bcc-tools </div></td> </tr> 
</tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>安装后，BCC 会把所有示例（包括 Python 和 lua），放到 /usr/share/bcc/examples 目录中：</p> <pre style="position: 
relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
$ ls /usr/share/bcc/examples </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
hello_world.py lua networking tracing </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <p>接下来，还是以 do_sys_open 为例，我们一起来看看，如何用 eBPF 
和 BCC 实现同样的动态跟踪。</p> <p>通常，我们可以把 BCC 应用，拆分为下面这四个步骤。</p> <p>第一，跟所有的 Python 模块使用方法一样，在使用之前，先导入要用到的模块：</p> 
<pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> from bcc import BPF </div></td> </tr> </tbody> </table></code> <div 
class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 </div></pre> <p>第二，需要定义事件以及处理事件的函数。这个函数需要用 
C 语言来编写，作用是初始化刚才导入的 BPF 对象。这些用 C 语言编写的处理函数，要以字符串的形式送到 BPF 模块中处理：</p> <pre style="position: 
relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
# define BPF program (""" is used for multi-line string). </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> # ''#'' indicates comments for python, while ''//'' indicates comments 
for C. </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="3"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> prog 
= """ </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="4"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> #include 
&lt;uapi/linux/ptrace.h&gt; </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="5"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
#include &lt;uapi/linux/limits.h&gt; </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> <td class="hljs-ln-code"> <div 
class="hljs-ln-line"> #include &lt;linux/sched.h&gt; </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> // define output data structure in C </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> struct data_t { </div></td> </tr> <tr> 
<td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> u32 pid; </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> u64 ts; </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> char comm[TASK_COMM_LEN]; </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> char fname[NAME_MAX]; </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="13"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> }; </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="14"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
BPF_PERF_OUTPUT(events); </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="15"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="16"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> // define the handler for do_sys_open. 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="17"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> // ctx is required, while other params 
depends on traced function. </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="18"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
int hello(struct pt_regs *ctx, int dfd, const char __user *filename, int flags){ </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="19"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> struct data_t data = {}; </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="20"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> data.pid = bpf_get_current_pid_tgid(); 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="21"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> data.ts = bpf_ktime_get_ns(); </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="22"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> if (bpf_get_current_comm(&amp;data.comm, 
sizeof(data.comm)) == 0) { </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="23"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
bpf_probe_read(&amp;data.fname, sizeof(data.fname), (void *)filename); </div></td> </tr> <tr> 
<td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="24"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> } </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="25"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> events.perf_submit(ctx, &amp;data, sizeof(data)); </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="26"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> return 0; </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="27"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> } </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="28"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
""" </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="29"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> # load 
BPF program </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="30"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> b = 
BPF(text=prog) </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="31"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
# attach the kprobe for do_sys_open, and set handler to hello </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="32"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> b.attach_kprobe(event="do_sys_open", fn_name="hello") </div></td> 
</tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>第三步，是定义一个输出函数，并把输出函数跟 BPF 事件绑定：</p> <pre style="position: relative;"><code> 
<table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
# process event </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
start = 0 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="3"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> def print_event(cpu, 
data, size): </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="4"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> global 
start </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="5"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> # event’s 
type is data_t </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="6"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
event = b["events"].event(data) </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="7"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
if start == 0: </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="8"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
start = event.ts </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="9"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
time_s = (float(event.ts - start)) / 1000000000 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> print("%-18.9f %-16s %-6d %-16s" % (time_s, event.comm, event.pid, 
event.fname)) </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="11"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> # loop with callback to print_event </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="13"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> b["events"].open_perf_buffer(print_event) 
</div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>最后一步，就是执行事件循环，开始追踪 do_sys_open 的调用：</p> <pre style="position: relative;"><code> 
<table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
# print header </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
print("%-18s %-16s %-6s %-16s" % ("TIME(s)", "COMM", "PID", "FILE”)) </div></td> </tr> <tr> 
<td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> # start the event polling loop </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> while 1: </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> try: </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="6"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
b.perf_buffer_poll() </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="7"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
except KeyboardInterrupt: </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="8"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
exit() </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span 
class="iconfont"></span>复制代码 </div></pre> <p>我们把上面几个步骤的代码，保存到文件 trace-open.py 中，然后就可以用 Python 
来运行了。如果一切正常，你可以看到如下输出：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> 
<tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ python trace-open.py </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> TIME(s) COMM PID FILE </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 0.000000000 irqbalance 1073 /proc/interrupts 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 0.000175401 irqbalance 1073 /proc/stat 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 0.000258802 irqbalance 1073 /proc/irq/9/smp_affinity 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 0.000290102 irqbalance 1073 /proc/irq/0/smp_affinity 
</div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>从输出中，你可以看到 irqbalance 进程（你的环境中可能还会有其他进程）正在打开很多文件，而 irqbalance 依赖这些文件中读取的内容，来执行中断负载均衡。</p> 
<p>通过这个简单的示例，你也可以发现，eBPF 和 BCC 的使用，其实比 ftrace 和 perf 有更高的门槛。想用 BCC 开发自己的动态跟踪程序，至少要熟悉 C 语言、Python 
语言、被跟踪事件或函数的特征（比如内核函数的参数和返回格式）以及 eBPF 提供的各种数据操作方法。</p> <p>不过，因为强大的灵活性，虽然 eBPF 在使用上有一定的门槛，却也无法阻止它成为目前最热门、最受关注的动态追踪技术。</p> 
<p>当然，BCC 软件包也内置了很多已经开发好的实用工具，默认安装到 /usr/share/bcc/tools/ 目录中，它们的使用场景如下图所示：</p> <p><img src="https://static001.geekbang.org/resource/image/fc/21/fc5f387a982db98c49c7cefb77342c21.png" 
alt=""></p> <p>（图片来自 <a href="http://www.brendangregg.com/ebpf.html#bcc">Linux Extended BPF 
(eBPF) Tracing Tools</a>）</p> <p>这些工具，一般都可以直接拿来用。而在编写其他的动态追踪脚本时，它们也是最好的参考资料。不过，有一点需要你特别注意，很多 
eBPF 的新特性，都需要比较新的<a href="https://github.com/iovisor/bcc/blob/master/docs/kernel-versions.md">内核版本</a>（如下图所示）。如果某些工具无法运行，很可能就是因为使用了当前内核不支持的特性。</p> 
<p><img src="https://static001.geekbang.org/resource/image/61/e8/61abce1affc770a15dae7d489e50a8e8.png" 
alt=""></p> <p>（图片来自 <a href="http://www.brendangregg.com/ebpf.html#bcc">Linux Extended BPF 
(eBPF) Tracing Tools</a>）</p> <h2>SystemTap 和 sysdig</h2> <p>除了前面提到的 ftrace、perf、eBPF 和 BCC 
外，SystemTap 和 sysdig 也是常用的动态追踪工具。</p> <p><strong>SystemTap</strong> 也是一种可以通过脚本进行自由扩展的动态追踪技术。在 
eBPF 出现之前，SystemTap 是 Linux 系统中，功能最接近 DTrace 的动态追踪机制。不过要注意，SystemTap 在很长时间以来都游离于内核之外（而 eBPF 
自诞生以来，一直根植在内核中）。</p> <p>所以，从稳定性上来说，SystemTap 只在 RHEL 系统中好用，在其他系统中则容易出现各种异常问题。当然，反过来说，支持 3.x 
等旧版本的内核，也是 SystemTap 相对于 eBPF 的一个巨大优势。</p> <p><strong>sysdig</strong> 则是随着容器技术的普及而诞生的，主要用于容器的动态追踪。sysdig 
汇集了一些列性能工具的优势，可以说是集百家之所长。我习惯用这个公式来表示 sysdig 的特点： sysdig = strace + tcpdump + htop + iftop + 
lsof + docker inspect。</p> <p>而在最新的版本中（内核版本 &gt;= 4.14），sysdig 还可以通过 eBPF 来进行扩展，所以，也可以用来追踪内核中的各种函数和事件。</p> 
<h2>如何选择追踪工具</h2> <p>到这里，你可能又觉得头大了，这么多动态追踪工具，在实际场景中到底该怎么选择呢？还是那句话，具体性能工具的选择，就要从具体的工作原理来入手。</p> 
<p>这两节课，我们已经把常见工具的原理和特点都介绍过了，你可以先自己思考区分一下，不同场景的工具选择问题。比如：</p> <ul> <li> <p>在不需要很高灵活性的场景中，使用 
perf 对性能事件进行采样，然后再配合火焰图辅助分析，就是最常用的一种方法；</p> </li> <li> <p>而需要对事件或函数调用进行统计分析（比如观察不同大小的 I/O 分布）时，就要用 
SystemTap 或者 eBPF，通过一些自定义的脚本来进行数据处理。</p> </li> </ul> <p>在这里，我也总结了几个常见的动态追踪使用场景，并且分别推荐了适合的工具。你可以保存这个表格，方便自己查找并使用。</p> 
<p><img src="https://static001.geekbang.org/resource/image/5a/25/5a2b2550547d5eaee850bfb806f76625.png" 
alt=""></p> <h2>小结</h2> <p>今天，我主要带你学习了 perf、eBPF 和 BCC 等动态追踪方法，并总结了不同场景中如何选择动态追踪方法。</p> <p>在 
Linux 系统中，常见的动态追踪方法，包括 ftrace、perf、eBPF 以及 SystemTap 等。在大多数性能问题中，使用 perf 配合火焰图是一个不错的方法。如果这满足不了你的要求，那么：</p> 
<ul> <li> <p>在新版的内核中，eBPF 和 BCC 是最灵活的动态追踪方法；</p> </li> <li> <p>而在旧版本内核中，特别是在 RHEL 系统中，由于 eBPF 
支持受限，SystemTap 往往是更好的选择。</p> </li> </ul> <p>此外，在使用动态追踪技术时，为了得到分析目标的详细信息，一般需要内核以及应用程序的调试符号表。动态追踪实际上也是在这些符号（包括函数和事件）上进行的，所以易读易理解的符号，有助于加快动态追踪的过程。</p> 
<h2>思考</h2> <p>最后，我想邀请你一起来聊聊，你所理解的动态追踪技术。你有没有在实际环境中用过动态追踪呢？这么多的动态追踪方法，你一般会怎么选择呢？你可以结合今天的内容，和你自己的操作记录，来总结思路。</p> 
<p>欢迎在留言区和我讨论，也欢迎把这篇文章分享给你的同事、朋友。我们一起在实战中演练，在交流中进步。</p> <p><img src="https://static001.geekbang.org/resource/image/a3/e9/a396aed4116c2c989771c1295736abe9.jpg" 
alt=""></p>', body_summary='', bundle='book', delta=0, body_format='full_html', langcode='zh-hans', 
revision_id=1084 where entity_id=1084 
 {executed in 1 msec}
2020-11-25 10:17:27.739 INFO  jdbc.sqltiming Line:373 - update node_revision__body set body_value='<p>你好，我是倪朋飞。</p> <p>上一节，我带你一起学习了常见的动态追踪方法。所谓动态追踪，就是在系统或者应用程序正常运行的时候，通过内核中提供的探针，来动态追踪它们的行为，从而辅助排查出性能问题的瓶颈。</p> 
<p>使用动态追踪，可以在不修改代码、不重启服务的情况下，动态了解应用程序或者内核的行为，这对排查线上问题、特别是不容易重现的问题尤其有效。</p> <p>在 Linux 系统中，常见的动态追踪方法包括 
ftrace、perf、eBPF 以及 SystemTap 等。上节课，我们具体学习了 ftrace 的使用方法。今天，我们再来一起看看其他几种方法。</p> <h2>perf</h2> 
<p>perf 已经是我们的老朋友了。在前面的案例中，我们多次用到它，来查找应用程序或者内核中的热点函数，从而定位性能瓶颈。而在内核线程 CPU 高的案例中，我们还使用火焰图动态展示 
perf 的事件记录，从而更直观地发现了问题。</p> <p>不过，我们前面使用 perf record/top 时，都是先对事件进行采样，然后再根据采样数，评估各个函数的调用频率。实际上，perf 
的功能远不止于此。比如，</p> <ul> <li> <p>perf 可以用来分析 CPU cache、CPU 迁移、分支预测、指令周期等各种硬件事件；</p> </li> <li> 
<p>perf 也可以只对感兴趣的事件进行动态追踪。</p> </li> </ul><!-- [[[read_end]]] --> <p>接下来，我们还是以内核函数 do_sys_open，以及用户空间函数 
readline 为例，看一看 perf 动态追踪的使用方法。</p> <p>同 ftrace 一样，你也可以通过 perf list ，查询所有支持的事件：</p> <pre style="position: 
relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
$ perf list </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span 
class="iconfont"></span>复制代码 </div></pre> <p>然后，在 perf 的各个子命令中添加 --event 选项，设置追踪感兴趣的事件。如果这些预定义的事件不满足实际需要，你还可以使用 
perf probe 来动态添加。而且，除了追踪内核事件外，perf 还可以用来跟踪用户空间的函数。</p> <p><strong>我们先来看第一个 perf 示例，内核函数 do_sys_open 
的例子</strong>。你可以执行 perf probe 命令，添加 do_sys_open 探针：</p> <pre style="position: relative;"><code> 
<table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
$ perf probe --add do_sys_open </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
Added new event: </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
probe:do_sys_open (on do_sys_open) </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> <div 
class="hljs-ln-line"> You can now use it in all perf tools, such as: </div></td> </tr> <tr> 
<td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> perf record -e probe:do_sys_open -aR sleep 
1 </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>探针添加成功后，就可以在所有的 perf 子命令中使用。比如，上述输出就是一个 perf record 的示例，执行它就可以对 10s 内的 do_sys_open 
进行采样：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ perf record -e probe:do_sys_open -aR 
sleep 10 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> [ perf 
record: Woken up 1 times to write data ] </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> [ perf record: Captured and wrote 0.148 MB perf.data (19 samples) 
] </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>而采样成功后，就可以执行 perf script ，来查看采样结果了：</p> <pre style="position: relative;"><code> 
<table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
$ perf script </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
perf 12886 [000] 89565.879875: probe:do_sys_open: (ffffffffa807b290) </div></td> </tr> <tr> 
<td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> sleep 12889 [000] 89565.880362: probe:do_sys_open: 
(ffffffffa807b290) </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
sleep 12889 [000] 89565.880382: probe:do_sys_open: (ffffffffa807b290) </div></td> </tr> <tr> 
<td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> sleep 12889 [000] 89565.880635: probe:do_sys_open: 
(ffffffffa807b290) </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="6"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
sleep 12889 [000] 89565.880669: probe:do_sys_open: (ffffffffa807b290) </div></td> </tr> </tbody> 
</table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 </div></pre> 
<p>输出中，同样也列出了调用 do_sys_open 的任务名称、进程 PID 以及运行的 CPU 等信息。不过，对于 open 系统调用来说，只知道它被调用了并不够，我们需要知道的是，进程到底在打开哪些文件。所以，实际应用中，我们还希望追踪时能显示这些函数的参数。</p> 
<p>对于内核函数来说，你当然可以去查看内核源码，找出它的所有参数。不过还有更简单的方法，那就是直接从调试符号表中查询。执行下面的命令，你就可以知道 do_sys_open 的所有参数：</p> 
<pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> $ perf probe -V do_sys_open </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> Available variables at do_sys_open </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> @&lt;do_sys_open+0&gt; </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> char* filename </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> int dfd </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> <td class="hljs-ln-code"> <div 
class="hljs-ln-line"> int flags </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="7"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
struct open_flags op </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="8"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
umode_t mode </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <p>从这儿可以看出，我们关心的文件路径，就是第一个字符指针参数（也就是字符串），参数名称为 
filename。如果这个命令执行失败，就说明调试符号表还没有安装。那么，你可以执行下面的命令，安装调试信息后重试：</p> <pre style="position: relative;"><code> 
<table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
# Ubuntu </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> $ apt-get 
install linux-image-`uname -r`-dbgsym </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> <div 
class="hljs-ln-line"> # CentOS </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
$ yum --enablerepo=base-debuginfo install -y kernel-debuginfo-$(uname -r) </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> </div></td> </tr> </tbody> </table></code> 
<div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 </div></pre> <p>找出参数名称和类型后，就可以把参数加到探针中了。不过由于我们已经添加过同名探针，所以在这次添加前，需要先把旧探针给删掉：</p> 
<pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> # 先删除旧的探针 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> <div 
class="hljs-ln-line"> perf probe --del probe:do_sys_open </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
# 添加带参数的探针 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="5"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> $ perf 
probe --add ''do_sys_open filename:string'' </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> Added new event: </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> probe:do_sys_open (on do_sys_open with filename:string) </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> You can now use it in all perf tools, 
such as: </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="9"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> perf 
record -e probe:do_sys_open -aR sleep 1 </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <p>新的探针添加后，重新执行 record 和 script 子命令，采样并查看记录：</p> 
<pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> # 重新采样记录 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> <div 
class="hljs-ln-line"> $ perf record -e probe:do_sys_open -aR ls </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> # 查看结果 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> <td class="hljs-ln-code"> <div 
class="hljs-ln-line"> $ perf script </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> <td class="hljs-ln-code"> <div 
class="hljs-ln-line"> perf 13593 [000] 91846.053622: probe:do_sys_open: (ffffffffa807b290) 
filename_string="/proc/13596/status" </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></td> <td class="hljs-ln-code"> <div 
class="hljs-ln-line"> ls 13596 [000] 91846.053995: probe:do_sys_open: (ffffffffa807b290) filename_string="/etc/ld.so.cache" 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> ls 13596 [000] 91846.054011: probe:do_sys_open: 
(ffffffffa807b290) filename_string="/lib/x86_64-linux-gnu/libselinux.so.1" </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> ls 13596 [000] 91846.054066: probe:do_sys_open: 
(ffffffffa807b290) filename_string="/lib/x86_64-linux-gnu/libc.so.6” </div></td> </tr> <tr> 
<td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> ... </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> # 使用完成后不要忘记删除探针 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> $ perf probe --del probe:do_sys_open </div></td> </tr> </tbody> 
</table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 </div></pre> 
<p>现在，你就可以看到每次调用 open 时打开的文件了。不过，这个结果是不是看着很熟悉呢？</p> <p>其实，在我们使用 strace 跟踪进程的系统调用时，也经常会看到这些动态库的影子。比如，使用 
strace 跟踪 ls 时，你可以得到下面的结果：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> 
<tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ strace ls </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> ... </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or 
directory) </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="4"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> access("/etc/ld.so.preload", 
R_OK) = -1 ENOENT (No such file or directory) </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3 </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> ... </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or 
directory) </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="8"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> openat(AT_FDCWD, 
"/lib/x86_64-linux-gnu/libselinux.so.1", O_RDONLY|O_CLOEXEC) = 3 </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> ... </div></td> </tr> </tbody> </table></code> 
<div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 </div></pre> <p>你估计在想，既然 
strace 也能得到类似结果，本身又容易操作，为什么我们还要用 perf 呢？</p> <p>实际上，很多人只看到了 strace 简单易用的好处，却忽略了它对进程性能带来的影响。从原理上来说，<strong>strace 
基于系统调用 ptrace 实现</strong>，这就带来了两个问题。</p> <ul> <li> <p>由于 ptrace 是系统调用，就需要在内核态和用户态切换。当事件数量比较多时，繁忙的切换必然会影响原有服务的性能；</p> 
</li> <li> <p>ptrace 需要借助 SIGSTOP 信号挂起目标进程。这种信号控制和进程挂起，会影响目标进程的行为。</p> </li> </ul> <p>所以，在性能敏感的应用（比如数据库）中，我并不推荐你用 
strace （或者其他基于 ptrace 的性能工具）去排查和调试。</p> <p>在 strace 的启发下，结合内核中的 utrace 机制， perf 也提供了一个 trace 
子命令，是取代 strace 的首选工具。相对于 ptrace 机制来说，perf trace 基于内核事件，自然要比进程跟踪的性能好很多。</p> <p>perf trace 的使用方法如下所示，跟 
strace 其实很像：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> <tr> 
<td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ perf trace ls </div></td> </tr> <tr> 
<td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> ? ( ): ls/14234 ... [continued]: execve()) 
= 0 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="3"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 0.177 
( 0.013 ms): ls/14234 brk( ) = 0x555d96be7000 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 0.224 ( 0.014 ms): ls/14234 access(filename: 0xad98082 ) = -1 ENOENT 
No such file or directory </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="5"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
0.248 ( 0.009 ms): ls/14234 access(filename: 0xad9add0, mode: R ) = -1 ENOENT No such file 
or directory </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="6"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 0.267 
( 0.012 ms): ls/14234 openat(dfd: CWD, filename: 0xad98428, flags: CLOEXEC ) = 3 </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 0.288 ( 0.009 ms): ls/14234 fstat(fd: 
3&lt;/usr/lib/locale/C.UTF-8/LC_NAME&gt;, statbuf: 0x7ffd2015f230 ) = 0 </div></td> </tr> <tr> 
<td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 0.305 ( 0.011 ms): ls/14234 mmap(len: 
45560, prot: READ, flags: PRIVATE, fd: 3 ) = 0x7efe0af92000 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 0.324 Dockerfile test.sh </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> ( 0.008 ms): ls/14234 close(fd: 3&lt;/usr/lib/locale/C.UTF-8/LC_NAME&gt; 
) = 0 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="11"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> ... 
</div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>不过，perf trace 还可以进行系统级的系统调用跟踪（即跟踪所有进程），而 strace 只能跟踪特定的进程。</p> <p><strong>第二个 
perf 的例子是用户空间的库函数</strong>。以 bash 调用的库函数 readline 为例，使用类似的方法，可以跟踪库函数的调用（基于 uprobes）。</p> <p>readline 
的作用，是从终端中读取用户输入，并把这些数据返回调用方。所以，跟 open 系统调用不同的是，我们更关注 readline 的调用结果。</p> <p>我们执行下面的命令，通过 -x 
指定 bash 二进制文件的路径，就可以动态跟踪库函数。这其实就是跟踪了所有用户在 bash 中执行的命令：</p> <pre style="position: relative;"><code> 
<table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
# 为 /bin/bash 添加 readline 探针 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
$ perf probe -x /bin/bash ''readline%return +0($retval):string’ </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> # 采样记录 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> <td class="hljs-ln-code"> <div 
class="hljs-ln-line"> $ perf record -e probe_bash:readline__return -aR sleep 5 </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> # 查看结果 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></td> <td class="hljs-ln-code"> <div 
class="hljs-ln-line"> $ perf script </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></td> <td class="hljs-ln-code"> <div 
class="hljs-ln-line"> bash 13348 [000] 93939.142576: probe_bash:readline__return: (5626ffac1610 
&lt;- 5626ffa46739) arg1="ls" </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="10"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> # 跟踪完成后删除探针 </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ perf probe --del probe_bash:readline__return 
</div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>当然，如果你不确定探针格式，也可以通过下面的命令，查询所有支持的函数和函数参数：</p> <pre style="position: relative;"><code> 
<table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
# 查询所有的函数 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> $ perf 
probe -x /bin/bash —funcs </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> # 查询函数的参数 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> $ perf probe -x /bin/bash -V readline </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> Available variables at readline </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> @&lt;readline+0&gt; </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> char* prompt </div></td> </tr> </tbody> 
</table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 </div></pre> 
<p>跟内核函数类似，如果你想要查看普通应用的函数名称和参数，那么在应用程序的二进制文件中，同样需要包含调试信息。</p> <h2>eBPF 和 BCC</h2> <p>ftrace 
和 perf 的功能已经比较丰富了，不过，它们有一个共同的缺陷，那就是不够灵活，没法像 DTrace 那样通过脚本自由扩展。</p> <p>而 eBPF 就是 Linux 版的 DTrace，可以通过 
C 语言自由扩展（这些扩展通过 LLVM 转换为 BPF 字节码后，加载到内核中执行）。下面这张图，就表示了 eBPF 追踪的工作原理：</p> <p><img src="https://static001.geekbang.org/resource/image/a3/e9/a3547f2ac1d4d75b850a02a2735560e9.png" 
alt=""></p> <p>（图片来自 <a href="https://thenewstack.io/long-last-linux-gets-dynamic-tracing/">THE 
NEW STACK</a>）</p> <p>从图中你可以看到，eBPF 的执行需要三步：</p> <ul> <li> <p>从用户跟踪程序生成 BPF 字节码；</p> </li> 
<li> <p>加载到内核中运行；</p> </li> <li> <p>向用户空间输出结果。</p> </li> </ul> <p>所以，从使用上来说，eBPF 要比我们前面看到的 
ftrace 和 perf ，都更加繁杂。</p> <p>实际上，在 eBPF 执行过程中，编译、加载还有 maps 等操作，对所有的跟踪程序来说都是通用的。把这些过程通过 Python 
抽象起来，也就诞生了 BCC（BPF Compiler Collection）。</p> <p>BCC 把 eBPF 中的各种事件源（比如 kprobe、uprobe、tracepoint 
等）和数据操作（称为 Maps），也都转换成了 Python 接口（也支持 lua）。这样，使用 BCC 进行动态追踪时，编写简单的脚本就可以了。</p> <p>不过要注意，因为需要跟内核中的数据结构交互，真正核心的事件处理逻辑，还是需要我们用 
C 语言来编写。</p> <p>至于 BCC 的安装方法，在内存模块的<a href="https://time.geekbang.org/column/article/0?cid=140">缓存案例</a>中，我就已经介绍过了。如果你还没有安装过，可以执行下面的命令来安装（其他系统的安装请参考<a 
href="https://github.com/iovisor/bcc/blob/master/INSTALL.md">这里</a>）：</p> <pre style="position: 
relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
# Ubuntu </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> sudo 
apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 4052245BD4284CDD </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> echo "deb https://repo.iovisor.org/apt/$(lsb_release 
-cs) $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/iovisor.list </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> sudo apt-get update </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> sudo apt-get install bcc-tools libbcc-examples 
linux-headers-$(uname -r) </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="6"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> # REHL 7.6 </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> yum install bcc-tools </div></td> </tr> 
</tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>安装后，BCC 会把所有示例（包括 Python 和 lua），放到 /usr/share/bcc/examples 目录中：</p> <pre style="position: 
relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
$ ls /usr/share/bcc/examples </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
hello_world.py lua networking tracing </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <p>接下来，还是以 do_sys_open 为例，我们一起来看看，如何用 eBPF 
和 BCC 实现同样的动态跟踪。</p> <p>通常，我们可以把 BCC 应用，拆分为下面这四个步骤。</p> <p>第一，跟所有的 Python 模块使用方法一样，在使用之前，先导入要用到的模块：</p> 
<pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> from bcc import BPF </div></td> </tr> </tbody> </table></code> <div 
class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 </div></pre> <p>第二，需要定义事件以及处理事件的函数。这个函数需要用 
C 语言来编写，作用是初始化刚才导入的 BPF 对象。这些用 C 语言编写的处理函数，要以字符串的形式送到 BPF 模块中处理：</p> <pre style="position: 
relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
# define BPF program (""" is used for multi-line string). </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> # ''#'' indicates comments for python, while ''//'' indicates comments 
for C. </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="3"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> prog 
= """ </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="4"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> #include 
&lt;uapi/linux/ptrace.h&gt; </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="5"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
#include &lt;uapi/linux/limits.h&gt; </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> <td class="hljs-ln-code"> <div 
class="hljs-ln-line"> #include &lt;linux/sched.h&gt; </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> // define output data structure in C </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> struct data_t { </div></td> </tr> <tr> 
<td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> u32 pid; </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> u64 ts; </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> char comm[TASK_COMM_LEN]; </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> char fname[NAME_MAX]; </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="13"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> }; </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="14"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
BPF_PERF_OUTPUT(events); </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="15"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="16"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> // define the handler for do_sys_open. 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="17"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> // ctx is required, while other params 
depends on traced function. </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="18"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
int hello(struct pt_regs *ctx, int dfd, const char __user *filename, int flags){ </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="19"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> struct data_t data = {}; </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="20"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> data.pid = bpf_get_current_pid_tgid(); 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="21"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> data.ts = bpf_ktime_get_ns(); </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="22"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> if (bpf_get_current_comm(&amp;data.comm, 
sizeof(data.comm)) == 0) { </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="23"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
bpf_probe_read(&amp;data.fname, sizeof(data.fname), (void *)filename); </div></td> </tr> <tr> 
<td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="24"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> } </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="25"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> events.perf_submit(ctx, &amp;data, sizeof(data)); </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="26"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> return 0; </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="27"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> } </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="28"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
""" </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="29"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> # load 
BPF program </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="30"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> b = 
BPF(text=prog) </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="31"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
# attach the kprobe for do_sys_open, and set handler to hello </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="32"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> b.attach_kprobe(event="do_sys_open", fn_name="hello") </div></td> 
</tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>第三步，是定义一个输出函数，并把输出函数跟 BPF 事件绑定：</p> <pre style="position: relative;"><code> 
<table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
# process event </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
start = 0 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="3"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> def print_event(cpu, 
data, size): </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="4"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> global 
start </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="5"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> # event’s 
type is data_t </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="6"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
event = b["events"].event(data) </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="7"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
if start == 0: </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="8"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
start = event.ts </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="9"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
time_s = (float(event.ts - start)) / 1000000000 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> print("%-18.9f %-16s %-6d %-16s" % (time_s, event.comm, event.pid, 
event.fname)) </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="11"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> # loop with callback to print_event </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="13"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> b["events"].open_perf_buffer(print_event) 
</div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>最后一步，就是执行事件循环，开始追踪 do_sys_open 的调用：</p> <pre style="position: relative;"><code> 
<table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
# print header </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
print("%-18s %-16s %-6s %-16s" % ("TIME(s)", "COMM", "PID", "FILE”)) </div></td> </tr> <tr> 
<td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> # start the event polling loop </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> while 1: </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> try: </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="6"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
b.perf_buffer_poll() </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="7"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
except KeyboardInterrupt: </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="8"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
exit() </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span 
class="iconfont"></span>复制代码 </div></pre> <p>我们把上面几个步骤的代码，保存到文件 trace-open.py 中，然后就可以用 Python 
来运行了。如果一切正常，你可以看到如下输出：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> 
<tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ python trace-open.py </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> TIME(s) COMM PID FILE </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 0.000000000 irqbalance 1073 /proc/interrupts 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 0.000175401 irqbalance 1073 /proc/stat 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 0.000258802 irqbalance 1073 /proc/irq/9/smp_affinity 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 0.000290102 irqbalance 1073 /proc/irq/0/smp_affinity 
</div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>从输出中，你可以看到 irqbalance 进程（你的环境中可能还会有其他进程）正在打开很多文件，而 irqbalance 依赖这些文件中读取的内容，来执行中断负载均衡。</p> 
<p>通过这个简单的示例，你也可以发现，eBPF 和 BCC 的使用，其实比 ftrace 和 perf 有更高的门槛。想用 BCC 开发自己的动态跟踪程序，至少要熟悉 C 语言、Python 
语言、被跟踪事件或函数的特征（比如内核函数的参数和返回格式）以及 eBPF 提供的各种数据操作方法。</p> <p>不过，因为强大的灵活性，虽然 eBPF 在使用上有一定的门槛，却也无法阻止它成为目前最热门、最受关注的动态追踪技术。</p> 
<p>当然，BCC 软件包也内置了很多已经开发好的实用工具，默认安装到 /usr/share/bcc/tools/ 目录中，它们的使用场景如下图所示：</p> <p><img src="https://static001.geekbang.org/resource/image/fc/21/fc5f387a982db98c49c7cefb77342c21.png" 
alt=""></p> <p>（图片来自 <a href="http://www.brendangregg.com/ebpf.html#bcc">Linux Extended BPF 
(eBPF) Tracing Tools</a>）</p> <p>这些工具，一般都可以直接拿来用。而在编写其他的动态追踪脚本时，它们也是最好的参考资料。不过，有一点需要你特别注意，很多 
eBPF 的新特性，都需要比较新的<a href="https://github.com/iovisor/bcc/blob/master/docs/kernel-versions.md">内核版本</a>（如下图所示）。如果某些工具无法运行，很可能就是因为使用了当前内核不支持的特性。</p> 
<p><img src="https://static001.geekbang.org/resource/image/61/e8/61abce1affc770a15dae7d489e50a8e8.png" 
alt=""></p> <p>（图片来自 <a href="http://www.brendangregg.com/ebpf.html#bcc">Linux Extended BPF 
(eBPF) Tracing Tools</a>）</p> <h2>SystemTap 和 sysdig</h2> <p>除了前面提到的 ftrace、perf、eBPF 和 BCC 
外，SystemTap 和 sysdig 也是常用的动态追踪工具。</p> <p><strong>SystemTap</strong> 也是一种可以通过脚本进行自由扩展的动态追踪技术。在 
eBPF 出现之前，SystemTap 是 Linux 系统中，功能最接近 DTrace 的动态追踪机制。不过要注意，SystemTap 在很长时间以来都游离于内核之外（而 eBPF 
自诞生以来，一直根植在内核中）。</p> <p>所以，从稳定性上来说，SystemTap 只在 RHEL 系统中好用，在其他系统中则容易出现各种异常问题。当然，反过来说，支持 3.x 
等旧版本的内核，也是 SystemTap 相对于 eBPF 的一个巨大优势。</p> <p><strong>sysdig</strong> 则是随着容器技术的普及而诞生的，主要用于容器的动态追踪。sysdig 
汇集了一些列性能工具的优势，可以说是集百家之所长。我习惯用这个公式来表示 sysdig 的特点： sysdig = strace + tcpdump + htop + iftop + 
lsof + docker inspect。</p> <p>而在最新的版本中（内核版本 &gt;= 4.14），sysdig 还可以通过 eBPF 来进行扩展，所以，也可以用来追踪内核中的各种函数和事件。</p> 
<h2>如何选择追踪工具</h2> <p>到这里，你可能又觉得头大了，这么多动态追踪工具，在实际场景中到底该怎么选择呢？还是那句话，具体性能工具的选择，就要从具体的工作原理来入手。</p> 
<p>这两节课，我们已经把常见工具的原理和特点都介绍过了，你可以先自己思考区分一下，不同场景的工具选择问题。比如：</p> <ul> <li> <p>在不需要很高灵活性的场景中，使用 
perf 对性能事件进行采样，然后再配合火焰图辅助分析，就是最常用的一种方法；</p> </li> <li> <p>而需要对事件或函数调用进行统计分析（比如观察不同大小的 I/O 分布）时，就要用 
SystemTap 或者 eBPF，通过一些自定义的脚本来进行数据处理。</p> </li> </ul> <p>在这里，我也总结了几个常见的动态追踪使用场景，并且分别推荐了适合的工具。你可以保存这个表格，方便自己查找并使用。</p> 
<p><img src="https://static001.geekbang.org/resource/image/5a/25/5a2b2550547d5eaee850bfb806f76625.png" 
alt=""></p> <h2>小结</h2> <p>今天，我主要带你学习了 perf、eBPF 和 BCC 等动态追踪方法，并总结了不同场景中如何选择动态追踪方法。</p> <p>在 
Linux 系统中，常见的动态追踪方法，包括 ftrace、perf、eBPF 以及 SystemTap 等。在大多数性能问题中，使用 perf 配合火焰图是一个不错的方法。如果这满足不了你的要求，那么：</p> 
<ul> <li> <p>在新版的内核中，eBPF 和 BCC 是最灵活的动态追踪方法；</p> </li> <li> <p>而在旧版本内核中，特别是在 RHEL 系统中，由于 eBPF 
支持受限，SystemTap 往往是更好的选择。</p> </li> </ul> <p>此外，在使用动态追踪技术时，为了得到分析目标的详细信息，一般需要内核以及应用程序的调试符号表。动态追踪实际上也是在这些符号（包括函数和事件）上进行的，所以易读易理解的符号，有助于加快动态追踪的过程。</p> 
<h2>思考</h2> <p>最后，我想邀请你一起来聊聊，你所理解的动态追踪技术。你有没有在实际环境中用过动态追踪呢？这么多的动态追踪方法，你一般会怎么选择呢？你可以结合今天的内容，和你自己的操作记录，来总结思路。</p> 
<p>欢迎在留言区和我讨论，也欢迎把这篇文章分享给你的同事、朋友。我们一起在实战中演练，在交流中进步。</p> <p><img src="https://static001.geekbang.org/resource/image/a3/e9/a396aed4116c2c989771c1295736abe9.jpg" 
alt=""></p>', body_summary='', bundle='book', delta=0, body_format='full_html', langcode='zh-hans', 
revision_id=1084 where entity_id=1084 
 {executed in 1 msec}
2020-11-25 10:17:27.745 INFO  jdbc.sqltiming Line:373 - select nodefiledd0_.nid as nid1_10_, nodefiledd0_.changed as changed2_10_, nodefiledd0_.created 
as created3_10_, nodefiledd0_.default_langcode as default_4_10_, nodefiledd0_.langcode as langcode5_10_, 
nodefiledd0_.promote as promote6_10_, nodefiledd0_.revision_translation_affected as revision7_10_, 
nodefiledd0_.status as status8_10_, nodefiledd0_.sticky as sticky9_10_, nodefiledd0_.title 
as title10_10_, nodefiledd0_.type as type11_10_, nodefiledd0_.uid as uid12_10_, nodefiledd0_.vid 
as vid13_10_ from node_field_data nodefiledd0_ where nodefiledd0_.nid=1084 
 {executed in 1 msec}
2020-11-25 10:17:27.745 INFO  jdbc.resultsettable Line:610 - 
|-----|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|-------------------|-----|----|-----|
|nid  |changed    |created    |default_langcode |langcode |promote |revision_translation_affected |status |sticky |title              |type |uid |vid  |
|-----|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|-------------------|-----|----|-----|
|1084 |1606114990 |1606114990 |1                |zh-hans  |0       |1                             |1      |0      |51丨案例篇：动态追踪怎么用？（下） |book |1   |1084 |
|-----|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|-------------------|-----|----|-----|

2020-11-25 10:17:27.746 INFO  jdbc.sqltiming Line:373 - select nodefieldr0_.nid as nid1_11_0_, nodefieldr0_.changed as changed2_11_0_, nodefieldr0_.created 
as created3_11_0_, nodefieldr0_.default_langcode as default_4_11_0_, nodefieldr0_.langcode 
as langcode5_11_0_, nodefieldr0_.promote as promote6_11_0_, nodefieldr0_.revision_translation_affected 
as revision7_11_0_, nodefieldr0_.status as status8_11_0_, nodefieldr0_.sticky as sticky9_11_0_, 
nodefieldr0_.title as title10_11_0_, nodefieldr0_.uid as uid11_11_0_, nodefieldr0_.vid as vid12_11_0_ 
from node_field_revision nodefieldr0_ where nodefieldr0_.nid=1084 
 {executed in 0 msec}
2020-11-25 10:17:27.747 INFO  jdbc.resultsettable Line:610 - 
|---------|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|-------------------|----|-----|
|nid      |changed    |created    |default_langcode |langcode |promote |revision_translation_affected |status |sticky |title              |uid |vid  |
|---------|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|-------------------|----|-----|
|[unread] |1606114990 |1606114990 |1                |zh-hans  |0       |1                             |1      |0      |51丨案例篇：动态追踪怎么用？（下） |1   |1084 |
|---------|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|-------------------|----|-----|

2020-11-25 10:17:27.748 INFO  jdbc.sqltiming Line:373 - update node_field_data set changed=1606270647, created=1606270647, default_langcode=1, langcode='zh-hans', 
promote=0, revision_translation_affected=1, status=1, sticky=0, title='51丨案例篇：动态追踪怎么用？（下）', 
type='book', uid=1, vid=1084 where nid=1084 
 {executed in 0 msec}
2020-11-25 10:17:27.748 INFO  jdbc.sqltiming Line:373 - update node_field_revision set changed=1606270647, created=1606270647, default_langcode=1, 
langcode='zh-hans', promote=0, revision_translation_affected=1, status=1, sticky=0, title='51丨案例篇：动态追踪怎么用？（下）', 
uid=1, vid=1084 where nid=1084 
 {executed in 0 msec}
2020-11-25 10:17:27.753 INFO  jdbc.sqltiming Line:373 - select bookfieldm0_.entity_id as entity_i1_8_, bookfieldm0_.bundle as bundle2_8_, bookfieldm0_.delta 
as delta3_8_, bookfieldm0_.langcode as langcode4_8_, bookfieldm0_.field_media_value as field_me5_8_, 
bookfieldm0_.revision_id as revision6_8_ from node__field_media bookfieldm0_ where bookfieldm0_.entity_id=1084 
 {executed in 0 msec}
2020-11-25 10:17:27.754 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------------|------------|
|entity_id |bundle |delta |langcode |field_media_value |revision_id |
|----------|-------|------|---------|------------------|------------|
|1084      |book   |0     |zh-hans  |                  |1084        |
|----------|-------|------|---------|------------------|------------|

2020-11-25 10:17:27.755 INFO  jdbc.sqltiming Line:373 - select nodefieldm0_.entity_id as entity_i1_17_0_, nodefieldm0_.bundle as bundle2_17_0_, nodefieldm0_.delta 
as delta3_17_0_, nodefieldm0_.langcode as langcode4_17_0_, nodefieldm0_.field_media_value as 
field_me5_17_0_, nodefieldm0_.revision_id as revision6_17_0_ from node_revision__field_media 
nodefieldm0_ where nodefieldm0_.entity_id=1084 
 {executed in 0 msec}
2020-11-25 10:17:27.756 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------------|------------|
|entity_id |bundle |delta |langcode |field_media_value |revision_id |
|----------|-------|------|---------|------------------|------------|
|[unread]  |book   |0     |zh-hans  |                  |1084        |
|----------|-------|------|---------|------------------|------------|

2020-11-25 10:17:27.758 INFO  jdbc.sqltiming Line:373 - select bookfieldc0_.entity_id as entity_i1_5_, bookfieldc0_.bundle as bundle2_5_, bookfieldc0_.field_comment_value 
as field_co3_5_, bookfieldc0_.delta as delta4_5_, bookfieldc0_.field_comment_format as field_co5_5_, 
bookfieldc0_.langcode as langcode6_5_, bookfieldc0_.revision_id as revision7_5_ from node__field_comment 
bookfieldc0_ where bookfieldc0_.entity_id=1084 
 {executed in 1 msec}
2020-11-25 10:17:27.758 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|--------------------|------|---------------------|---------|------------|
|entity_id |bundle |field_comment_value |delta |field_comment_format |langcode |revision_id |
|----------|-------|--------------------|------|---------------------|---------|------------|
|1084      |book   |                    |0     |full_html            |zh-hans  |1084        |
|----------|-------|--------------------|------|---------------------|---------|------------|

2020-11-25 10:17:27.760 INFO  jdbc.sqltiming Line:373 - update node__field_comment set bundle='book', field_comment_value='<li class="reJj6Thl_0"><img 
src="https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>我来也</span> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-22 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">2</span> </div> <!----> 
<!----> </div> </div> <div class="_3M6kV3zb_0"> [D51打卡] <br>长见识了。 <br>还是先把perf 和 火焰图用起来吧。 <br>知道还有更好的工具在内核收集信息就行了。有需要了再来针对性的 
看吧。🤦‍♂️ </div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <!----> 
</div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/16/63/2e/e49116d1.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>Geek_007</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-04-14 </div> </div> <div 
class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> 
</div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0"> 老师你好，我在使用 perf trace 命令时发现，perf 
trace 追踪时，不能打印出打开文件的文件名，尽管我已经使用 perf probe 将filename 加入，但是依然无法打印出文件名。另外我使用 perf trace -e probe:do_sys_open 
,依然还是记录所有的事件，请问老师，是我使用的有问题？还是其他问题？ </div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> 
</div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 应该是 perf trace -e fs:do_sys_open</p> 
</div> </div></li> <li class="reJj6Thl_0"><img src="https://wx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEKQMM4m7NHuicr55aRiblTSEWIYe0QqbpyHweaoAbG7j2v7UUElqqeP3Ihrm3UfDPDRb1Hv8LvPwXqA/132" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>ninuxer</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-22 </div> </div> <div 
class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> 
</div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 打卡day54 <br>整个动态追踪都比较懵逼，常用的也就是trace和perf很简单的用法，等啃完内核的书再回过头来看文章，估计容易消化点～ 
</div> <!----> <!----> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/12/f6/4e/5cfbd26b.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>cuikt</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-05-10 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> 高大上，内容干货多多。 </div> <div class="_2r3UB1GX_0"> <span>展开</span><i 
class="iconfont"></i> </div> <!----> </div></li> <li class="reJj6Thl_0"><img src="" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>如果</span> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2019-04-19 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> DAY51，打卡 </div> <div class="_2r3UB1GX_0"> <span>展开</span><i 
class="iconfont"></i> </div> <!----> </div></li> <li class="reJj6Thl_0"><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epGMibYc0m7cDHMsNRBUur2NPVnlBZFXoNjWomibfjnHeAO3XRt27VaH3WNtdUX11d3uIT1ZHWCxLeg/132" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>york</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-28 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> # perf probe -x /bin/bash -V readline <br>The /bin/bash 
file has no debug information. <br>Rebuild with -g, or install an appropriate debuginfo package. 
<br>&nbsp;&nbsp;Error: Failed to show vars. <br> <br>这个问题怎么解？ </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 
要安装debuginfo的，先网络搜索查查</p> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/13/57/6e/dd0eee5f.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>夜空中最亮...</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-26 </div> </div> <div 
class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> 
</div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0"> 报道 </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <!----> </div></li> <li class="reJj6Thl_0"><img 
src="https://static001.geekbang.org/account/avatar/00/14/11/4b/fa64f061.jpg" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>xfan</span> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-26 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 我想知道ebpf程序编写有什么好点的学习资源吗，有种心有余而力不足的感觉 </div> 
<!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 可以看到这个文档：https://docs.cilium.io/en/stable/bpf/</p> 
</div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/14/10/32/e37aacfe.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>cliff(亮...</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-24 </div> </div> <div 
class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> 
</div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0"> 有没有讲Linux汇编和GDB的一期？ </div> <div 
class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: sorry，没有。这些更多的用在调试程序错误而不是性能优化中</p> </div> </div></li> <li class="reJj6Thl_0"><img 
src="https://static001.geekbang.org/account/avatar/00/11/a7/6d/19bff1f9.jpg" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>ichen</span> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-23 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> # perf probe <br>perf: ''probe'' is not a perf-command. 
See ''perf --help''. </div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> 
</div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 升级版本试试？</p> </div> </div></li>', 
delta=0, field_comment_format='full_html', langcode='zh-hans', revision_id=1084 where entity_id=1084 
 {executed in 0 msec}
2020-11-25 10:17:27.764 INFO  jdbc.sqltiming Line:373 - select nodefieldc0_.entity_id as entity_i1_14_0_, nodefieldc0_.bundle as bundle2_14_0_, nodefieldc0_.field_comment_value 
as field_co3_14_0_, nodefieldc0_.delta as delta4_14_0_, nodefieldc0_.field_comment_format as 
field_co5_14_0_, nodefieldc0_.langcode as langcode6_14_0_, nodefieldc0_.revision_id as revision7_14_0_ 
from node_revision__field_comment nodefieldc0_ where nodefieldc0_.entity_id=1084 
 {executed in 0 msec}
2020-11-25 10:17:27.765 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|--------------------|------|---------------------|---------|------------|
|entity_id |bundle |field_comment_value |delta |field_comment_format |langcode |revision_id |
|----------|-------|--------------------|------|---------------------|---------|------------|
|[unread]  |book   |                    |0     |full_html            |zh-hans  |1084        |
|----------|-------|--------------------|------|---------------------|---------|------------|

2020-11-25 10:17:27.767 INFO  jdbc.sqltiming Line:373 - update node_revision__field_comment set bundle='book', field_comment_value='<li class="reJj6Thl_0"><img 
src="https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>我来也</span> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-22 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">2</span> </div> <!----> 
<!----> </div> </div> <div class="_3M6kV3zb_0"> [D51打卡] <br>长见识了。 <br>还是先把perf 和 火焰图用起来吧。 <br>知道还有更好的工具在内核收集信息就行了。有需要了再来针对性的 
看吧。🤦‍♂️ </div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <!----> 
</div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/16/63/2e/e49116d1.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>Geek_007</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-04-14 </div> </div> <div 
class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> 
</div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0"> 老师你好，我在使用 perf trace 命令时发现，perf 
trace 追踪时，不能打印出打开文件的文件名，尽管我已经使用 perf probe 将filename 加入，但是依然无法打印出文件名。另外我使用 perf trace -e probe:do_sys_open 
,依然还是记录所有的事件，请问老师，是我使用的有问题？还是其他问题？ </div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> 
</div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 应该是 perf trace -e fs:do_sys_open</p> 
</div> </div></li> <li class="reJj6Thl_0"><img src="https://wx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEKQMM4m7NHuicr55aRiblTSEWIYe0QqbpyHweaoAbG7j2v7UUElqqeP3Ihrm3UfDPDRb1Hv8LvPwXqA/132" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>ninuxer</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-22 </div> </div> <div 
class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> 
</div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 打卡day54 <br>整个动态追踪都比较懵逼，常用的也就是trace和perf很简单的用法，等啃完内核的书再回过头来看文章，估计容易消化点～ 
</div> <!----> <!----> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/12/f6/4e/5cfbd26b.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>cuikt</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-05-10 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> 高大上，内容干货多多。 </div> <div class="_2r3UB1GX_0"> <span>展开</span><i 
class="iconfont"></i> </div> <!----> </div></li> <li class="reJj6Thl_0"><img src="" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>如果</span> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2019-04-19 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> DAY51，打卡 </div> <div class="_2r3UB1GX_0"> <span>展开</span><i 
class="iconfont"></i> </div> <!----> </div></li> <li class="reJj6Thl_0"><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epGMibYc0m7cDHMsNRBUur2NPVnlBZFXoNjWomibfjnHeAO3XRt27VaH3WNtdUX11d3uIT1ZHWCxLeg/132" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>york</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-28 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> # perf probe -x /bin/bash -V readline <br>The /bin/bash 
file has no debug information. <br>Rebuild with -g, or install an appropriate debuginfo package. 
<br>&nbsp;&nbsp;Error: Failed to show vars. <br> <br>这个问题怎么解？ </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 
要安装debuginfo的，先网络搜索查查</p> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/13/57/6e/dd0eee5f.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>夜空中最亮...</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-26 </div> </div> <div 
class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> 
</div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0"> 报道 </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <!----> </div></li> <li class="reJj6Thl_0"><img 
src="https://static001.geekbang.org/account/avatar/00/14/11/4b/fa64f061.jpg" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>xfan</span> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-26 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 我想知道ebpf程序编写有什么好点的学习资源吗，有种心有余而力不足的感觉 </div> 
<!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 可以看到这个文档：https://docs.cilium.io/en/stable/bpf/</p> 
</div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/14/10/32/e37aacfe.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>cliff(亮...</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-24 </div> </div> <div 
class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> 
</div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0"> 有没有讲Linux汇编和GDB的一期？ </div> <div 
class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: sorry，没有。这些更多的用在调试程序错误而不是性能优化中</p> </div> </div></li> <li class="reJj6Thl_0"><img 
src="https://static001.geekbang.org/account/avatar/00/11/a7/6d/19bff1f9.jpg" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>ichen</span> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-23 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> # perf probe <br>perf: ''probe'' is not a perf-command. 
See ''perf --help''. </div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> 
</div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 升级版本试试？</p> </div> </div></li>', 
delta=0, field_comment_format='full_html', langcode='zh-hans', revision_id=1084 where entity_id=1084 
 {executed in 1 msec}
2020-11-25 10:17:27.771 INFO  jdbc.sqltiming Line:373 - select bookfieldt0_.entity_id as entity_i1_9_, bookfieldt0_.bundle as bundle2_9_, bookfieldt0_.delta 
as delta3_9_, bookfieldt0_.langcode as langcode4_9_, bookfieldt0_.revision_id as revision5_9_, 
bookfieldt0_.field_thumb_value as field_th6_9_ from node__field_thumb bookfieldt0_ where bookfieldt0_.entity_id=1084 
 {executed in 0 msec}
2020-11-25 10:17:27.772 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------|------------------|
|entity_id |bundle |delta |langcode |revision_id |field_thumb_value |
|----------|-------|------|---------|------------|------------------|
|1084      |book   |0     |zh-hans  |1084        |                  |
|----------|-------|------|---------|------------|------------------|

2020-11-25 10:17:27.773 INFO  jdbc.sqltiming Line:373 - update node__field_thumb set bundle='book', delta=0, langcode='zh-hans', revision_id=1084, 
field_thumb_value='https://static001.geekbang.org/resource/image/bf/4b/bf5b1e0200299dbf4bbb73be59f0b44b.jpg' 
where entity_id=1084 
 {executed in 0 msec}
2020-11-25 10:17:27.777 INFO  jdbc.sqltiming Line:373 - select nodefieldt0_.entity_id as entity_i1_18_0_, nodefieldt0_.bundle as bundle2_18_0_, nodefieldt0_.delta 
as delta3_18_0_, nodefieldt0_.langcode as langcode4_18_0_, nodefieldt0_.revision_id as revision5_18_0_, 
nodefieldt0_.field_thumb_value as field_th6_18_0_ from node_revision__field_thumb nodefieldt0_ 
where nodefieldt0_.entity_id=1084 
 {executed in 0 msec}
2020-11-25 10:17:27.778 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------|------------------|
|entity_id |bundle |delta |langcode |revision_id |field_thumb_value |
|----------|-------|------|---------|------------|------------------|
|[unread]  |book   |0     |zh-hans  |1084        |                  |
|----------|-------|------|---------|------------|------------------|

2020-11-25 10:17:27.779 INFO  jdbc.sqltiming Line:373 - update node_revision__field_thumb set bundle='book', delta=0, langcode='zh-hans', revision_id=1084, 
field_thumb_value='https://static001.geekbang.org/resource/image/bf/4b/bf5b1e0200299dbf4bbb73be59f0b44b.jpg' 
where entity_id=1084 
 {executed in 0 msec}
2020-11-25 10:17:27.783 INFO  jdbc.sqltiming Line:373 - select bookfieldf0_.entity_id as entity_i1_6_0_, bookfieldf0_.bundle as bundle2_6_0_, bookfieldf0_.delta 
as delta3_6_0_, bookfieldf0_.field_fenlei_target_id as field_fe4_6_0_, bookfieldf0_.langcode 
as langcode5_6_0_, bookfieldf0_.revision_id as revision6_6_0_ from node__field_fenlei bookfieldf0_ 
where bookfieldf0_.entity_id=1084 
 {executed in 0 msec}
2020-11-25 10:17:27.783 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|-----------------------|---------|------------|
|entity_id |bundle |delta |field_fenlei_target_id |langcode |revision_id |
|----------|-------|------|-----------------------|---------|------------|
|[unread]  |book   |0     |1                      |zh-hans  |1084        |
|----------|-------|------|-----------------------|---------|------------|

2020-11-25 10:17:27.785 INFO  jdbc.sqltiming Line:373 - select nodefieldf0_.entity_id as entity_i1_15_0_, nodefieldf0_.bundle as bundle2_15_0_, nodefieldf0_.delta 
as delta3_15_0_, nodefieldf0_.field_fenlei_target_id as field_fe4_15_0_, nodefieldf0_.langcode 
as langcode5_15_0_, nodefieldf0_.revision_id as revision6_15_0_ from node_revision__field_fenlei 
nodefieldf0_ where nodefieldf0_.entity_id=1084 
 {executed in 0 msec}
2020-11-25 10:17:27.785 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|-----------------------|---------|------------|
|entity_id |bundle |delta |field_fenlei_target_id |langcode |revision_id |
|----------|-------|------|-----------------------|---------|------------|
|[unread]  |book   |0     |1                      |zh-hans  |1084        |
|----------|-------|------|-----------------------|---------|------------|

2020-11-25 10:17:27.787 INFO  jdbc.sqltiming Line:373 - select bookchecke0_.item_id as item_id1_2_, bookchecke0_.fsid as fsid2_2_, bookchecke0_.got 
as got3_2_, bookchecke0_.name as name4_2_, bookchecke0_.parse_fail as parse_fa5_2_, bookchecke0_.parsed 
as parsed6_2_, bookchecke0_.path as path7_2_, bookchecke0_.title as title8_2_, bookchecke0_.vid 
as vid9_2_ from book_check bookchecke0_ where bookchecke0_.fsid='294510371684826' and bookchecke0_.name='net_content' 
 {executed in 0 msec}
2020-11-25 10:17:27.788 INFO  jdbc.resultsettable Line:610 - 
|--------|---------|---------|---------|-----------|---------|---------|---------|---------|
|item_id |fsid     |got      |name     |parse_fail |parsed   |path     |title    |vid      |
|--------|---------|---------|---------|-----------|---------|---------|---------|---------|
|1085    |[unread] |[unread] |[unread] |[unread]   |[unread] |[unread] |[unread] |[unread] |
|--------|---------|---------|---------|-----------|---------|---------|---------|---------|

2020-11-25 10:18:11.069 INFO  jdbc.sqltiming Line:373 - update book_check set fsid='294510371684826', got=1, name='net_content', parse_fail='', parsed=1, 
path='12-Linux性能优化实战/06-综合实战篇 (13讲)/52丨案例篇：服务吞吐量下降很厉害，怎么分析？.html', title='52丨案例篇：服务吞吐量下降很厉害，怎么分析？', 
vid=1085 where item_id=1085 
 {executed in 0 msec}
2020-11-25 10:18:11.076 INFO  jdbc.sqltiming Line:373 - select nodebodyen0_.entity_id as entity_i1_4_, nodebodyen0_.body_value as body_val2_4_, nodebodyen0_.body_summary 
as body_sum3_4_, nodebodyen0_.bundle as bundle4_4_, nodebodyen0_.delta as delta5_4_, nodebodyen0_.body_format 
as body_for6_4_, nodebodyen0_.langcode as langcode7_4_, nodebodyen0_.revision_id as revision8_4_ 
from node__body nodebodyen0_ where nodebodyen0_.entity_id=1085 
 {executed in 0 msec}
2020-11-25 10:18:11.076 INFO  jdbc.resultsettable Line:610 - 
|----------|-----------|-------------|-------|------|------------|---------|------------|
|entity_id |body_value |body_summary |bundle |delta |body_format |langcode |revision_id |
|----------|-----------|-------------|-------|------|------------|---------|------------|
|1085      |           |             |book   |0     |full_html   |zh-hans  |1085        |
|----------|-----------|-------------|-------|------|------------|---------|------------|

2020-11-25 10:18:11.077 INFO  jdbc.sqltiming Line:373 - select nodebodyre0_.entity_id as entity_i1_13_0_, nodebodyre0_.body_value as body_val2_13_0_, 
nodebodyre0_.body_summary as body_sum3_13_0_, nodebodyre0_.bundle as bundle4_13_0_, nodebodyre0_.delta 
as delta5_13_0_, nodebodyre0_.body_format as body_for6_13_0_, nodebodyre0_.langcode as langcode7_13_0_, 
nodebodyre0_.revision_id as revision8_13_0_ from node_revision__body nodebodyre0_ where nodebodyre0_.entity_id=1085 
 {executed in 0 msec}
2020-11-25 10:18:11.078 INFO  jdbc.resultsettable Line:610 - 
|----------|-----------|-------------|-------|------|------------|---------|------------|
|entity_id |body_value |body_summary |bundle |delta |body_format |langcode |revision_id |
|----------|-----------|-------------|-------|------|------------|---------|------------|
|[unread]  |           |             |book   |0     |full_html   |zh-hans  |1085        |
|----------|-----------|-------------|-------|------|------------|---------|------------|

2020-11-25 10:18:11.082 INFO  jdbc.sqltiming Line:373 - update node__body set body_value='<p>你好，我是倪朋飞。</p> <p>上一节，我们一起学习了怎么使用动态追踪来观察应用程序和内核的行为。先简单来回顾一下。</p> 
<p>所谓动态追踪，就是在系统或者应用程序还在正常运行的时候，通过内核中提供的探针，来动态追踪它们的行为，从而辅助排查出性能问题的瓶颈。</p> <p>使用动态追踪，便可以在不修改代码也不重启服务的情况下，动态了解应用程序或者内核的行为。这对排查线上的问题、特别是不容易重现的问题尤其有效。</p> 
<p>在 Linux 系统中，常见的动态追踪方法包括 ftrace、perf、eBPF/BCC 以及 SystemTap 等。</p> <ul> <li> <p>使用 perf 配合火焰图寻找热点函数，是一个比较通用的性能定位方法，在很多场景中都可以使用。</p> 
</li> <li> <p>如果这仍满足不了你的要求，那么在新版的内核中，eBPF 和 BCC 是最灵活的动态追踪方法。</p> </li> <li> <p>而在旧版本内核，特别是在 
RHEL 系统中，由于 eBPF 支持受限，SystemTap 和 ftrace 往往是更好的选择。</p> </li> </ul> <p>在 <a href="https://time.geekbang.org/column/article/82833">网络请求延迟变大</a> 
的案例中，我带你一起分析了一个网络请求延迟增大的问题。当时我们分析知道，那是由于服务器端开启 TCP 的 Nagle 算法，而客户端却开启了延迟确认所导致的。</p> <p>其实，除了延迟问题外，网络请求的吞吐量下降，是另一个常见的性能问题。那么，针对这种吞吐量下降问题，我们又该如何进行分析呢？</p><!-- 
[[[read_end]]] --> <p>接下来，我就以最常用的反向代理服务器 Nginx 为例，带你一起看看，如何分析服务吞吐量下降的问题。</p> <h2>案例准备</h2> 
<p>今天的案例需要用到两台虚拟机，还是基于 Ubuntu 18.04，同样适用于其他的 Linux 系统。我使用的案例环境如下所示：</p> <ul> <li> <p>机器配置：2 
CPU，8GB 内存。</p> </li> <li> <p>预先安装 docker、curl、wrk、perf、FlameGraph 等工具，比如</p> </li> </ul> <pre 
style="position: relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> # 安装必备 docker、curl 和 perf </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> $ apt-get install -y docker.io curl build-essential linux-tools-common 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> # 安装火焰图工具 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> $ git clone https://github.com/brendangregg/FlameGraph </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> # 安装 wrk </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> $ git clone https://github.com/wg/wrk </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ cd wrk &amp;&amp; make &amp;&amp; sudo 
cp wrk /usr/local/bin/ </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <p>这些工具，我们在前面的案例中已经多次使用，这儿就不再重复。你可以打开两个终端，分别登录到这两台虚拟机中，并安装上述工具。</p> 
<blockquote> <p>注意，以下所有命令都默认以 root 用户运行，如果你用普通用户身份登陆系统，请运行 sudo su root 命令切换到 root 用户。</p> 
</blockquote> <p>到这里，准备工作就完成了。接下来，我们正式进入操作环节。</p> <h2>案例分析</h2> <p>我们今天要分析的案例是一个 Nginx + PHP 
应用，它们的关系如下图所示：</p> <p><img src="https://static001.geekbang.org/resource/image/e9/bb/e90d67270cf703aba6c487584d17cfbb.png" 
alt=""></p> <p>其中，wrk 和 curl 是 Nginx 的客户端，而 PHP 应用则是一个简单的 Hello World：</p> <pre style="position: 
relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
&lt;?php </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> echo 
"Hello World!" </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
?&gt; </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>为了方便你运行，我已经把案例应用打包成了两个 Docker 镜像，并推送到 Docker Hub 中。你可以直接按照下面的步骤来运行它。</p> <p>同时，为了分析方便，这两个容器都将运行在 
host network 模式中。这样，我们就不用切换到容器的网络命名空间，而可以直接观察它们的套接字状态。</p> <p>我们先在终端一中，执行下面的命令，启动 Nginx 应用，并监听在 
80 端口。如果一切正常，你应该可以看到如下的输出：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> 
<tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ docker run --name nginx --network host 
--privileged -itd feisky/nginx-tp </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> <div 
class="hljs-ln-line"> 6477c607c13b37943234755a14987ffb3a31c33a7f04f75bb1c190e710bce19e </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ docker run --name phpfpm --network host 
--privileged -itd feisky/php-fpm-tp </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> <div 
class="hljs-ln-line"> 09e0255159f0c8a647e22cd68bd097bec7efc48b21e5d91618ff29b882fa7c1f </div></td> 
</tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>然后，执行 docker ps 命令，查询容器的状态，你会发现，容器已经处于运行状态（Up）了：</p> <pre style="position: 
relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
$ docker ps </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> CONTAINER 
ID IMAGE COMMAND CREATED STATUS PORTS NAMES </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 09e0255159f0 feisky/php-fpm-tp "php-fpm -F --pid /o…" 28 seconds 
ago Up 27 seconds phpfpm </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
6477c607c13b feisky/nginx-tp "/init.sh" 29 seconds ago Up 28 seconds nginx </div></td> </tr> 
</tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>不过，从 docker ps 的输出，我们只能知道容器处于运行状态。至于 Nginx 能不能正常处理外部的请求，还需要我们进一步确认。</p> <p>接着，切换到终端二中，执行下面的 
curl 命令，进一步验证 Nginx 能否正常访问。如果你看到 “Hello World!” 的输出，说明 Nginx+PHP 的应用已经正常启动了：</p> <pre style="position: 
relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
$ curl http://192.168.0.30 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
Hello World! </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <blockquote> <p>提示：如果你看到不一样的结果，可以再次执行 docker 
ps -a 确认容器的状态，并执行 docker logs &lt; 容器名 &gt; 来查看容器日志，从而找出原因。</p> </blockquote> <p>接下来，我们就来测试一下，案例中 
Nginx 的吞吐量。</p> <p>我们继续在终端二中，执行 wrk 命令，来测试 Nginx 的性能：</p> <pre style="position: relative;"><code> 
<table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
# 默认测试时间为 10s，请求超时 2s </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
$ wrk --latency -c 1000 http://192.168.0.30 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> Running 10s test @ http://192.168.0.30 </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 2 threads and 1000 connections </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> Thread Stats Avg Stdev Max +/- Stdev </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> Latency 14.82ms 42.47ms 874.96ms 98.43% 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> Req/Sec 550.55 1.36k 5.70k 93.10% </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> Latency Distribution </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 50% 11.03ms </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 75% 15.90ms </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 90% 23.65ms </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 99% 215.03ms </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="13"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 1910 requests in 10.10s, 573.56KB read 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="14"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> Non-2xx or 3xx responses: 1910 </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="15"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> Requests/sec: 189.10 </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="16"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> Transfer/sec: 56.78KB </div></td> </tr> 
</tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>从 wrk 的结果中，你可以看到吞吐量（也就是每秒请求数）只有 189，并且所有 1910 个请求收到的都是异常响应（非 2xx 或 3xx）。这些数据显然表明，吞吐量太低了，并且请求处理都失败了。这是怎么回事呢？</p> 
<p>根据 wrk 输出的统计结果，我们可以看到，总共传输的数据量只有 573 KB，那就肯定不会是带宽受限导致的。所以，我们应该从请求数的角度来分析。</p> <p>分析请求数，特别是 
HTTP 的请求数，有什么好思路吗？当然就要从 TCP 连接数入手。</p> <h3>连接数优化</h3> <p>要查看 TCP 连接数的汇总情况，首选工具自然是 ss 命令。为了观察 
wrk 测试时发生的问题，我们在终端二中再次启动 wrk，并且把总的测试时间延长到 30 分钟：</p> <pre style="position: relative;"><code> 
<table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
# 测试时间 30 分钟 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> $ wrk 
--latency -c 1000 -d 1800 http://192.168.0.30 </div></td> </tr> </tbody> </table></code> <div 
class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 </div></pre> <p>然后，回到终端一中，观察 
TCP 连接数：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ ss -s </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> Total: 177 (kernel 1565) </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> TCP: 1193 (estab 5, closed 1178, orphaned 0, synrecv 0, timewait 
1178/0), ports 0 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> Transport Total IP IPv6 </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> * 1565 - - </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> RAW 1 0 1 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> UDP 2 2 0 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></td> <td class="hljs-ln-code"> <div 
class="hljs-ln-line"> TCP 15 12 3 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> INET 18 14 4 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> FRAG 0 0 0 </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <p>从这里看出，wrk 并发 1000 请求时，建立连接数只有 5，而 closed 
和 timewait 状态的连接则有 1100 多 。其实从这儿你就可以发现两个问题：</p> <ul> <li> <p>一个是建立连接数太少了；</p> </li> <li> <p>另一个是 
timewait 状态连接太多了。</p> </li> </ul> <p>分析问题，自然要先从相对简单的下手。我们先来看第二个关于 timewait 的问题。在之前的 NAT 案例中，我已经提到过，内核中的连接跟踪模块，有可能会导致 
timewait 问题。我们今天的案例还是基于 Docker 运行，而 Docker 使用的 iptables ，就会使用连接跟踪模块来管理 NAT。那么，怎么确认是不是连接跟踪导致的问题呢？</p> 
<p>其实，最简单的方法，就是通过 dmesg 查看系统日志，如果有连接跟踪出了问题，应该会看到 nf_conntrack 相关的日志。</p> <p>我们可以继续在终端一中，运行下面的命令，查看系统日志：</p> 
<pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> $ dmesg | tail </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> [88356.354329] nf_conntrack: nf_conntrack: table full, dropping 
packet </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="3"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> [88356.354374] 
nf_conntrack: nf_conntrack: table full, dropping packet </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <p>从日志中，你可以看到 nf_conntrack: table full, dropping 
packet 的错误日志。这说明，正是连接跟踪导致的问题。</p> <p>这种情况下，我们应该想起前面学过的两个内核选项——连接跟踪数的最大限制 nf_conntrack_max ，以及当前的连接跟踪数 
nf_conntrack_count。执行下面的命令，你就可以查询这两个选项：</p> <pre style="position: relative;"><code> <table 
class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> $ sysctl 
net.netfilter.nf_conntrack_max </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
net.netfilter.nf_conntrack_max = 200 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> <div 
class="hljs-ln-line"> $ sysctl net.netfilter.nf_conntrack_count </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> net.netfilter.nf_conntrack_count = 200 
</div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>这次的输出中，你可以看到最大的连接跟踪限制只有 200，并且全部被占用了。200 的限制显然太小，不过相应的优化也很简单，调大就可以了。</p> <p>我们执行下面的命令，将 
nf_conntrack_max 增大：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> # 将连接跟踪限制增大到 1048576 </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ sysctl -w net.netfilter.nf_conntrack_max=1048576 
</div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>连接跟踪限制增大后，对 Nginx 吞吐量的优化效果如何呢？我们不妨再来测试一下。你可以切换到终端二中，按下 Ctrl+C ；然后执行下面的 wrk 
命令，重新测试 Nginx 的性能：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> # 默认测试时间为 10s，请求超时 2s </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ wrk --latency -c 1000 http://192.168.0.30 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> ... </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 54221 requests in 10.07s, 15.16MB read </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> Socket errors: connect 0, read 7, write 
0, timeout 110 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="6"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
Non-2xx or 3xx responses: 45577 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="7"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
Requests/sec: 5382.21 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="8"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
Transfer/sec: 1.50MB </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <p>从 wrk 的输出中，你可以看到，连接跟踪的优化效果非常好，吞吐量已经从刚才的 
189 增大到了 5382。看起来性能提升了将近 30 倍，</p> <p>不过，这是不是就能说明，我们已经把 Nginx 的性能优化好了呢？</p> <p>别急，我们再来看看 wrk 
汇报的其他数据。果然，10s 内的总请求数虽然增大到了 5 万，但是有 4 万多响应异常，说白了，真正成功的只有 8000 多个（54221-45577=8644）。</p> <p>很明显，大部分请求的响应都是异常的。那么，该怎么分析响应异常的问题呢？</p> 
<h3>工作进程优化</h3> <p>由于这些响应并非 Socket error，说明 Nginx 已经收到了请求，只不过，响应的状态码并不是我们期望的 2xx （表示成功）或 3xx（表示重定向）。所以，这种情况下，搞清楚 
Nginx 真正的响应就很重要了。</p> <p>不过这也不难，我们切换回终端一，执行下面的 docker 命令，查询 Nginx 容器日志就知道了：</p> <pre style="position: 
relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
$ docker logs nginx --tail 3 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
192.168.0.2 - - [15/Mar/2019:2243:27 +0000] "GET / HTTP/1.1" 499 0 "-" "-" "-" </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 192.168.0.2 - - [15/Mar/2019:22:43:27 
+0000] "GET / HTTP/1.1" 499 0 "-" "-" "-" </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 192.168.0.2 - - [15/Mar/2019:22:43:27 +0000] "GET / HTTP/1.1" 499 
0 "-" "-" "-" </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <p>从 Nginx 的日志中，我们可以看到，响应状态码为 499。</p> <p>499 
并非标准的 HTTP 状态码，而是由 Nginx 扩展而来，表示服务器端还没来得及响应时，客户端就已经关闭连接了。换句话说，问题在于服务器端处理太慢，客户端因为超时（wrk 超时时间为 
2s），主动断开了连接。</p> <p>既然问题出在了服务器端处理慢，而案例本身是 Nginx+PHP 的应用，那是不是可以猜测，是因为 PHP 处理过慢呢？</p> <p>我么可以在终端中，执行下面的 
docker 命令，查询 PHP 容器日志：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> 
<tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ docker logs phpfpm --tail 5 </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> [15-Mar-2019 22:28:56] WARNING: [pool 
www] server reached max_children setting (5), consider raising it </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> [15-Mar-2019 22:43:17] WARNING: [pool 
www] server reached max_children setting (5), consider raising it </div></td> </tr> </tbody> 
</table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 </div></pre> 
<p>从这个日志中，我们可以看到两条警告信息，server reached max_children setting (5)，并建议增大 max_children。</p> <p>max_children 
表示 php-fpm 子进程的最大数量，当然是数值越大，可以同时处理的请求数就越多。不过由于这是进程问题，数量增大，也会导致更多的内存和 CPU 占用。所以，我们还不能设置得过大。</p> 
<p>一般来说，每个 php-fpm 子进程可能会占用 20 MB 左右的内存。所以，你可以根据内存和 CPU 个数，估算一个合理的值。这儿我把它设置成了 20，并将优化后的配置重新打包成了 
Docker 镜像。你可以执行下面的命令来执行它：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> 
<tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> # 停止旧的容器 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> $ docker rm -f nginx phpfpm </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
# 使用新镜像启动 Nginx 和 PHP </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="5"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
$ docker run --name nginx --network host --privileged -itd feisky/nginx-tp:1 </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ docker run --name phpfpm --network host 
--privileged -itd feisky/php-fpm-tp:1 </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <p>然后我们切换到终端二，再次执行下面的 wrk 命令，重新测试 Nginx 的性能：</p> 
<pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> # 默认测试时间为 10s，请求超时 2s </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> $ wrk --latency -c 1000 http://192.168.0.30 </div></td> </tr> <tr> 
<td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> ... </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 47210 requests in 10.08s, 12.51MB read </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> Socket errors: connect 0, read 4, write 
0, timeout 91 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="6"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
Non-2xx or 3xx responses: 31692 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="7"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
Requests/sec: 4683.82 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="8"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
Transfer/sec: 1.24MB </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <p>从 wrk 的输出中，可以看到，虽然吞吐量只有 4683，比刚才的 5382 
少了一些；但是测试期间成功的请求数却多了不少，从原来的 8000，增长到了 15000（47210-31692=15518）。</p> <p>不过，虽然性能有所提升，可 4000 多的吞吐量显然还是比较差的，并且大部分请求的响应依然还是异常。接下来，该怎么去进一步提升 
Nginx 的吞吐量呢？</p> <h3>套接字优化</h3> <p>回想一下网络性能的分析套路，以及 Linux 协议栈的原理，我们可以从从套接字、TCP 协议等逐层分析。而分析的第一步，自然还是要观察有没有发生丢包现象。</p> 
<p>我们切换到终端二中，重新运行测试，这次还是要用 -d 参数延长测试时间，以便模拟性能瓶颈的现场：</p> <pre style="position: relative;"><code> 
<table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
# 测试时间 30 分钟 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> $ wrk 
--latency -c 1000 -d 1800 http://192.168.0.30 </div></td> </tr> </tbody> </table></code> <div 
class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 </div></pre> <p>然后回到终端一中，观察有没有发生套接字的丢包现象：</p> 
<pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> # 只关注套接字统计 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> <div 
class="hljs-ln-line"> $ netstat -s | grep socket </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 73 resets received for embryonic SYN_RECV sockets </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 308582 TCP sockets finished time wait 
in fast timer </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="5"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
8 delayed acks further delayed because of locked socket </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 290566 times the listen queue of a socket overflowed </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 290566 SYNs to LISTEN sockets dropped 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> # 稍等一会，再次运行 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> $ netstat -s | grep socket </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 73 resets received for embryonic SYN_RECV sockets </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 314722 TCP sockets finished time wait 
in fast timer </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="13"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
8 delayed acks further delayed because of locked socket </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="14"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 344440 times the listen queue of a socket overflowed </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="15"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 344440 SYNs to LISTEN sockets dropped 
</div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>根据两次统计结果中 socket overflowed 和 sockets dropped 的变化，你可以看到，有大量的套接字丢包，并且丢包都是套接字队列溢出导致的。所以，接下来，我们应该分析连接队列的大小是不是有异常。</p> 
<p>你可以执行下面的命令，查看套接字的队列大小：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> 
<tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ ss -ltnp </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> State Recv-Q Send-Q Local Address:Port 
Peer Address:Port </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
LISTEN 10 10 0.0.0.0:80 0.0.0.0:* users:(("nginx",pid=10491,fd=6),("nginx",pid=10490,fd=6),("nginx",pid=10487,fd=6)) 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> LISTEN 7 10 *:9000 *:* users:(("php-fpm",pid=11084,fd=9),...,("php-fpm",pid=10529,fd=7)) 
</div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>这次可以看到，Nginx 和 php-fpm 的监听队列 （Send-Q）只有 10，而 nginx 的当前监听队列长度 （Recv-Q）已经达到了最大值，php-fpm 
也已经接近了最大值。很明显，套接字监听队列的长度太小了，需要增大。</p> <p>关于套接字监听队列长度的设置，既可以在应用程序中，通过套接字接口调整，也支持通过内核选项来配置。我们继续在终端一中，执行下面的命令，分别查询 
Nginx 和内核选项对监听队列长度的配置：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> 
<tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> # 查询 nginx 监听队列长度配置 </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ docker exec nginx cat /etc/nginx/nginx.conf 
| grep backlog </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
listen 80 backlog=10; </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> # 查询 php-fpm 监听队列长度 </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ docker exec phpfpm cat /opt/bitnami/php/etc/php-fpm.d/www.conf 
| grep backlog </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="7"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
; Set listen(2) backlog. </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="8"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
;listen.backlog = 511 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="9"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> # somaxconn 是系统级套接字监听队列上限 </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ sysctl net.core.somaxconn </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> net.core.somaxconn = 10 </div></td> </tr> 
</tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>从输出中可以看到，Nginx 和 somaxconn 的配置都是 10，而 php-fpm 的配置也只有 511，显然都太小了。那么，优化方法就是增大这三个配置，比如，可以把 
Nginx 和 php-fpm 的队列长度增大到 8192，而把 somaxconn 增大到 65536。</p> <p>同样地，我也把这些优化后的 Nginx ，重新打包成了两个 
Docker 镜像，你可以执行下面的命令来运行它：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> 
<tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> # 停止旧的容器 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> $ docker rm -f nginx phpfpm </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
# 使用新镜像启动 Nginx 和 PHP </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="5"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
$ docker run --name nginx --network host --privileged -itd feisky/nginx-tp:2 </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ docker run --name phpfpm --network host 
--privileged -itd feisky/php-fpm-tp:2 </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <p>然后，切换到终端二中，重新测试 Nginx 的性能：</p> <pre style="position: 
relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
$ wrk --latency -c 1000 http://192.168.0.30 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> ... </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
62247 requests in 10.06s, 18.25MB read </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> Non-2xx or 3xx responses: 62247 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> Requests/sec: 6185.65 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> Transfer/sec: 1.81MB </div></td> </tr> </tbody> </table></code> 
<div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 </div></pre> <p>现在的吞吐量已经增大到了 
6185，并且在测试的时候，如果你在终端一中重新执行 <em>netstat -s | grep socket</em>，还会发现，现在已经没有套接字丢包问题了。</p> <p>不过，这次 
Nginx 的响应，再一次全部失败了，都是 Non-2xx or 3xx。这是怎么回事呢？我们再去终端一中，查看 Nginx 日志：</p> <pre style="position: 
relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
$ docker logs nginx --tail 10 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
2019/03/15 16:52:39 [crit] 15#15: *999779 connect() to 127.0.0.1:9000 failed (99: Cannot assign 
requested address) while connecting to upstream, client: 192.168.0.2, server: localhost, request: 
"GET / HTTP/1.1", upstream: "fastcgi://127.0.0.1:9000", host: "192.168.0.30" </div></td> </tr> 
</tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>你可以看到，Nginx 报出了无法连接 fastcgi 的错误，错误消息是 Connect 时， Cannot assign requested address。这个错误消息对应的错误代码为 
EADDRNOTAVAIL，表示 IP 地址或者端口号不可用。</p> <p>在这里，显然只能是端口号的问题。接下来，我们就来分析端口号的情况。</p> <h3>端口号优化</h3> 
<p>根据网络套接字的原理，当客户端连接服务器端时，需要分配一个临时端口号，而 Nginx 正是 PHP-FPM 的客户端。端口号的范围并不是无限的，最多也只有 6 万多。</p> 
<p>我们执行下面的命令，就可以查询系统配置的临时端口号范围：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> 
<tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ sysctl net.ipv4.ip_local_port_range 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> net.ipv4.ip_local_port_range=20000 20050 
</div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>你可以看到，临时端口的范围只有 50 个，显然太小了 。优化方法很容易想到，增大这个范围就可以了。比如，你可以执行下面的命令，把端口号范围扩展为 “10000 
65535”：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ sysctl -w net.ipv4.ip_local_port_range="10000 
65535" </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> net.ipv4.ip_local_port_range 
= 10000 65535 </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <p>优化完成后，我们再次切换到终端二中，测试性能：</p> <pre style="position: 
relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
$ wrk --latency -c 1000 http://192.168.0.30/ </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> ... </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
32308 requests in 10.07s, 6.71MB read </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> <div 
class="hljs-ln-line"> Socket errors: connect 0, read 2027, write 0, timeout 433 </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> Non-2xx or 3xx responses: 30 </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> Requests/sec: 3208.58 </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> Transfer/sec: 682.15KB </div></td> </tr> 
</tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>这次，异常的响应少多了 ，不过，吞吐量也下降到了 3208。并且，这次还出现了很多 Socket read errors。显然，还得进一步优化。</p> 
<h3>火焰图</h3> <p>前面我们已经优化了很多配置。这些配置在优化网络的同时，却也会带来其他资源使用的上升。这样来看，是不是说明其他资源遇到瓶颈了呢？</p> <p>我们不妨在终端二中，执行下面的命令，重新启动长时间测试：</p> 
<pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> # 测试时间 30 分钟 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> $ wrk --latency -c 1000 -d 1800 http://192.168.0.30 </div></td> 
</tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>然后，切换回终端一中，执行 top ，观察 CPU 和内存的使用：</p> <pre style="position: relative;"><code> 
<table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
$ top </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> ... </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> %Cpu0 : 30.7 us, 48.7 sy, 0.0 ni, 2.3 
id, 0.0 wa, 0.0 hi, 18.3 si, 0.0 st </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> <div 
class="hljs-ln-line"> %Cpu1 : 28.2 us, 46.5 sy, 0.0 ni, 2.0 id, 0.0 wa, 0.0 hi, 23.3 si, 0.0 
st </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="5"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> KiB Mem 
: 8167020 total, 5867788 free, 490400 used, 1808832 buff/cache </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> KiB Swap: 0 total, 0 free, 0 used. 7361172 avail Mem </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 20379 systemd+ 20 0 38068 8692 2392 R 
36.1 0.1 0:28.86 nginx </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="10"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
20381 systemd+ 20 0 38024 8700 2392 S 33.8 0.1 0:29.29 nginx </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 1558 root 20 0 1118172 85868 39044 S 32.8 1.1 22:55.79 dockerd </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 20313 root 20 0 11024 5968 3956 S 27.2 
0.1 0:22.78 docker-containe </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="13"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
13730 root 20 0 0 0 0 I 4.0 0.0 0:10.07 kworker/u4:0-ev </div></td> </tr> </tbody> </table></code> 
<div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 </div></pre> <p>从 top 
的结果中可以看到，可用内存还是很充足的，但系统 CPU 使用率（sy）比较高，两个 CPU 的系统 CPU 使用率都接近 50%，且空闲 CPU 使用率只有 2%。再看进程部分，CPU 
主要被两个 Nginx 进程和两个 docker 相关的进程占用，使用率都是 30% 左右。</p> <p>CPU 使用率上升了，该怎么进行分析呢？我想，你已经还记得我们多次用到的 
perf，再配合前两节讲过的火焰图，很容易就能找到系统中的热点函数。</p> <p>我们保持终端二中的 wrk 继续运行；在终端一中，执行 perf 和 flamegraph 脚本，生成火焰图：</p> 
<pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> # 执行 perf 记录事件 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> $ perf record -g </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
# 切换到 FlameGraph 安装路径执行下面的命令生成火焰图 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> <td class="hljs-ln-code"> <div 
class="hljs-ln-line"> $ perf script -i ~/perf.data | ./stackcollapse-perf.pl --all | ./flamegraph.pl 
&gt; nginx.svg </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <p>然后，使用浏览器打开生成的 nginx.svg ，你就可以看到下面的火焰图：</p> 
<p><img src="https://static001.geekbang.org/resource/image/89/c6/8933557b5eb8c8f41a629e751fd7f0c6.png" 
alt=""></p> <p>根据我们讲过的火焰图原理，这个图应该从下往上、沿着调用栈中最宽的函数，来分析执行次数最多的函数。</p> <p>这儿中间的 do_syscall_64、tcp_v4_connect、inet_hash_connect 
这个堆栈，很明显就是最需要关注的地方。inet_hash_connect() 是 Linux 内核中负责分配临时端口号的函数。所以，这个瓶颈应该还在临时端口的分配上。</p> <p>在上一步的“端口号”优化中，临时端口号的范围，已经优化成了 
“10000 65535”。这显然是一个非常大的范围，那么，端口号的分配为什么又成了瓶颈呢？</p> <p>一时想不到也没关系，我们可以暂且放下，先看看其他因素的影响。再顺着 inet_hash_connect 
往堆栈上面查看，下一个热点是 __init_check_established 函数。而这个函数的目的，是检查端口号是否可用。结合这一点，你应该可以想到，如果有大量连接占用着端口，那么检查端口号可用的函数，不就会消耗更多的 
CPU 吗？</p> <p>实际是否如此呢？我们可以继续在终端一中运行 ss 命令， 查看连接状态统计：</p> <pre style="position: relative;"><code> 
<table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
$ ss -s </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> TCP: 
32775 (estab 1, closed 32768, orphaned 0, synrecv 0, timewait 32768/0), ports 0 </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> ... </div></td> </tr> </tbody> </table></code> 
<div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 </div></pre> <p>这回可以看到，有大量连接（这儿是 
32768）处于 timewait 状态，而 timewait 状态的连接，本身会继续占用端口号。如果这些端口号可以重用，那么自然就可以缩短 __init_check_established 
的过程。而 Linux 内核中，恰好有一个 tcp_tw_reuse 选项，用来控制端口号的重用。</p> <p>我们在终端一中，运行下面的命令，查询它的配置：</p> <pre style="position: 
relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
$ sysctl net.ipv4.tcp_tw_reuse </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
net.ipv4.tcp_tw_reuse = 0 </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <p>你可以看到，tcp_tw_reuse 是 0，也就是禁止状态。其实看到这里，我们就能理解，为什么临时端口号的分配会是系统运行的热点了。当然，优化方法也很容易，把它设置成 
1 就可以开启了。</p> <p>我把优化后的应用，也打包成了两个 Docker 镜像，你可以执行下面的命令来运行：</p> <pre style="position: relative;"><code> 
<table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
# 停止旧的容器 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> $ docker 
rm -f nginx phpfpm </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> # 使用新镜像启动 Nginx 和 PHP </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ docker run --name nginx --network host 
--privileged -itd feisky/nginx-tp:3 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> <td class="hljs-ln-code"> <div 
class="hljs-ln-line"> $ docker run --name phpfpm --network host --privileged -itd feisky/php-fpm-tp:3 
</div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>容器启动后，切换到终端二中，再次测试优化后的效果：</p> <pre style="position: relative;"><code> <table 
class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> $ wrk 
--latency -c 1000 http://192.168.0.30/ </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> ... </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
52119 requests in 10.06s, 10.81MB read </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> Socket errors: connect 0, read 850, write 0, timeout 0 </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> Requests/sec: 5180.48 </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> Transfer/sec: 1.07MB </div></td> </tr> 
</tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>现在的吞吐量已经达到了 5000 多，并且只有少量的 Socket errors，也不再有 Non-2xx or 3xx 的响应了。说明一切终于正常了。</p> 
<p>案例的最后，不要忘记执行下面的命令，删除案例应用：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> 
<tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> # 停止 nginx 和 phpfpm 容器 </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ docker rm -f nginx phpfpm </div></td> 
</tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <h2>小结</h2> <p>今天，我带你一起学习了服务吞吐量下降后的分析方法。其实，从这个案例你也可以看出，性能问题的分析，总是离不开系统和应用程序的原理。</p> 
<p>实际上，分析性能瓶颈，最核心的也正是掌握运用这些原理。</p> <ul> <li> <p>首先，利用各种性能工具，收集想要的性能指标，从而清楚系统和应用程序的运行状态；</p> 
</li> <li> <p>其次，拿目前状态跟系统原理进行比较，不一致的地方，就是我们要重点分析的对象。</p> </li> </ul> <p>从这个角度出发，再进一步借助 perf、火焰图、bcc 
等动态追踪工具，找出热点函数，就可以定位瓶颈的来源，确定相应的优化方法。</p> <h2>思考</h2> <p>最后，我想邀请你一起来聊聊，你碰到过的吞吐量下降问题。你是怎么分析它们的根源？又是怎么解决的？你可以结合我的讲述，总结自己的思路。</p> 
<p>欢迎在留言区和我讨论，也欢迎把这篇文章分享给你的同事、朋友。我们一起在实战中演练，在交流中进步。</p> <p><img src="https://static001.geekbang.org/resource/image/a3/e9/a396aed4116c2c989771c1295736abe9.jpg" 
alt=""></p>', body_summary='', bundle='book', delta=0, body_format='full_html', langcode='zh-hans', 
revision_id=1085 where entity_id=1085 
 {executed in 1 msec}
2020-11-25 10:18:11.086 INFO  jdbc.sqltiming Line:373 - update node_revision__body set body_value='<p>你好，我是倪朋飞。</p> <p>上一节，我们一起学习了怎么使用动态追踪来观察应用程序和内核的行为。先简单来回顾一下。</p> 
<p>所谓动态追踪，就是在系统或者应用程序还在正常运行的时候，通过内核中提供的探针，来动态追踪它们的行为，从而辅助排查出性能问题的瓶颈。</p> <p>使用动态追踪，便可以在不修改代码也不重启服务的情况下，动态了解应用程序或者内核的行为。这对排查线上的问题、特别是不容易重现的问题尤其有效。</p> 
<p>在 Linux 系统中，常见的动态追踪方法包括 ftrace、perf、eBPF/BCC 以及 SystemTap 等。</p> <ul> <li> <p>使用 perf 配合火焰图寻找热点函数，是一个比较通用的性能定位方法，在很多场景中都可以使用。</p> 
</li> <li> <p>如果这仍满足不了你的要求，那么在新版的内核中，eBPF 和 BCC 是最灵活的动态追踪方法。</p> </li> <li> <p>而在旧版本内核，特别是在 
RHEL 系统中，由于 eBPF 支持受限，SystemTap 和 ftrace 往往是更好的选择。</p> </li> </ul> <p>在 <a href="https://time.geekbang.org/column/article/82833">网络请求延迟变大</a> 
的案例中，我带你一起分析了一个网络请求延迟增大的问题。当时我们分析知道，那是由于服务器端开启 TCP 的 Nagle 算法，而客户端却开启了延迟确认所导致的。</p> <p>其实，除了延迟问题外，网络请求的吞吐量下降，是另一个常见的性能问题。那么，针对这种吞吐量下降问题，我们又该如何进行分析呢？</p><!-- 
[[[read_end]]] --> <p>接下来，我就以最常用的反向代理服务器 Nginx 为例，带你一起看看，如何分析服务吞吐量下降的问题。</p> <h2>案例准备</h2> 
<p>今天的案例需要用到两台虚拟机，还是基于 Ubuntu 18.04，同样适用于其他的 Linux 系统。我使用的案例环境如下所示：</p> <ul> <li> <p>机器配置：2 
CPU，8GB 内存。</p> </li> <li> <p>预先安装 docker、curl、wrk、perf、FlameGraph 等工具，比如</p> </li> </ul> <pre 
style="position: relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> # 安装必备 docker、curl 和 perf </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> $ apt-get install -y docker.io curl build-essential linux-tools-common 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> # 安装火焰图工具 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> $ git clone https://github.com/brendangregg/FlameGraph </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> # 安装 wrk </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> $ git clone https://github.com/wg/wrk </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ cd wrk &amp;&amp; make &amp;&amp; sudo 
cp wrk /usr/local/bin/ </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <p>这些工具，我们在前面的案例中已经多次使用，这儿就不再重复。你可以打开两个终端，分别登录到这两台虚拟机中，并安装上述工具。</p> 
<blockquote> <p>注意，以下所有命令都默认以 root 用户运行，如果你用普通用户身份登陆系统，请运行 sudo su root 命令切换到 root 用户。</p> 
</blockquote> <p>到这里，准备工作就完成了。接下来，我们正式进入操作环节。</p> <h2>案例分析</h2> <p>我们今天要分析的案例是一个 Nginx + PHP 
应用，它们的关系如下图所示：</p> <p><img src="https://static001.geekbang.org/resource/image/e9/bb/e90d67270cf703aba6c487584d17cfbb.png" 
alt=""></p> <p>其中，wrk 和 curl 是 Nginx 的客户端，而 PHP 应用则是一个简单的 Hello World：</p> <pre style="position: 
relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
&lt;?php </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> echo 
"Hello World!" </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
?&gt; </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>为了方便你运行，我已经把案例应用打包成了两个 Docker 镜像，并推送到 Docker Hub 中。你可以直接按照下面的步骤来运行它。</p> <p>同时，为了分析方便，这两个容器都将运行在 
host network 模式中。这样，我们就不用切换到容器的网络命名空间，而可以直接观察它们的套接字状态。</p> <p>我们先在终端一中，执行下面的命令，启动 Nginx 应用，并监听在 
80 端口。如果一切正常，你应该可以看到如下的输出：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> 
<tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ docker run --name nginx --network host 
--privileged -itd feisky/nginx-tp </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> <div 
class="hljs-ln-line"> 6477c607c13b37943234755a14987ffb3a31c33a7f04f75bb1c190e710bce19e </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ docker run --name phpfpm --network host 
--privileged -itd feisky/php-fpm-tp </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> <div 
class="hljs-ln-line"> 09e0255159f0c8a647e22cd68bd097bec7efc48b21e5d91618ff29b882fa7c1f </div></td> 
</tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>然后，执行 docker ps 命令，查询容器的状态，你会发现，容器已经处于运行状态（Up）了：</p> <pre style="position: 
relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
$ docker ps </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> CONTAINER 
ID IMAGE COMMAND CREATED STATUS PORTS NAMES </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 09e0255159f0 feisky/php-fpm-tp "php-fpm -F --pid /o…" 28 seconds 
ago Up 27 seconds phpfpm </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
6477c607c13b feisky/nginx-tp "/init.sh" 29 seconds ago Up 28 seconds nginx </div></td> </tr> 
</tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>不过，从 docker ps 的输出，我们只能知道容器处于运行状态。至于 Nginx 能不能正常处理外部的请求，还需要我们进一步确认。</p> <p>接着，切换到终端二中，执行下面的 
curl 命令，进一步验证 Nginx 能否正常访问。如果你看到 “Hello World!” 的输出，说明 Nginx+PHP 的应用已经正常启动了：</p> <pre style="position: 
relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
$ curl http://192.168.0.30 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
Hello World! </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <blockquote> <p>提示：如果你看到不一样的结果，可以再次执行 docker 
ps -a 确认容器的状态，并执行 docker logs &lt; 容器名 &gt; 来查看容器日志，从而找出原因。</p> </blockquote> <p>接下来，我们就来测试一下，案例中 
Nginx 的吞吐量。</p> <p>我们继续在终端二中，执行 wrk 命令，来测试 Nginx 的性能：</p> <pre style="position: relative;"><code> 
<table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
# 默认测试时间为 10s，请求超时 2s </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
$ wrk --latency -c 1000 http://192.168.0.30 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> Running 10s test @ http://192.168.0.30 </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 2 threads and 1000 connections </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> Thread Stats Avg Stdev Max +/- Stdev </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> Latency 14.82ms 42.47ms 874.96ms 98.43% 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> Req/Sec 550.55 1.36k 5.70k 93.10% </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> Latency Distribution </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 50% 11.03ms </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 75% 15.90ms </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 90% 23.65ms </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 99% 215.03ms </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="13"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 1910 requests in 10.10s, 573.56KB read 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="14"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> Non-2xx or 3xx responses: 1910 </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="15"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> Requests/sec: 189.10 </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="16"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> Transfer/sec: 56.78KB </div></td> </tr> 
</tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>从 wrk 的结果中，你可以看到吞吐量（也就是每秒请求数）只有 189，并且所有 1910 个请求收到的都是异常响应（非 2xx 或 3xx）。这些数据显然表明，吞吐量太低了，并且请求处理都失败了。这是怎么回事呢？</p> 
<p>根据 wrk 输出的统计结果，我们可以看到，总共传输的数据量只有 573 KB，那就肯定不会是带宽受限导致的。所以，我们应该从请求数的角度来分析。</p> <p>分析请求数，特别是 
HTTP 的请求数，有什么好思路吗？当然就要从 TCP 连接数入手。</p> <h3>连接数优化</h3> <p>要查看 TCP 连接数的汇总情况，首选工具自然是 ss 命令。为了观察 
wrk 测试时发生的问题，我们在终端二中再次启动 wrk，并且把总的测试时间延长到 30 分钟：</p> <pre style="position: relative;"><code> 
<table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
# 测试时间 30 分钟 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> $ wrk 
--latency -c 1000 -d 1800 http://192.168.0.30 </div></td> </tr> </tbody> </table></code> <div 
class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 </div></pre> <p>然后，回到终端一中，观察 
TCP 连接数：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ ss -s </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> Total: 177 (kernel 1565) </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> TCP: 1193 (estab 5, closed 1178, orphaned 0, synrecv 0, timewait 
1178/0), ports 0 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> Transport Total IP IPv6 </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> * 1565 - - </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> RAW 1 0 1 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> UDP 2 2 0 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></td> <td class="hljs-ln-code"> <div 
class="hljs-ln-line"> TCP 15 12 3 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> INET 18 14 4 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> FRAG 0 0 0 </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <p>从这里看出，wrk 并发 1000 请求时，建立连接数只有 5，而 closed 
和 timewait 状态的连接则有 1100 多 。其实从这儿你就可以发现两个问题：</p> <ul> <li> <p>一个是建立连接数太少了；</p> </li> <li> <p>另一个是 
timewait 状态连接太多了。</p> </li> </ul> <p>分析问题，自然要先从相对简单的下手。我们先来看第二个关于 timewait 的问题。在之前的 NAT 案例中，我已经提到过，内核中的连接跟踪模块，有可能会导致 
timewait 问题。我们今天的案例还是基于 Docker 运行，而 Docker 使用的 iptables ，就会使用连接跟踪模块来管理 NAT。那么，怎么确认是不是连接跟踪导致的问题呢？</p> 
<p>其实，最简单的方法，就是通过 dmesg 查看系统日志，如果有连接跟踪出了问题，应该会看到 nf_conntrack 相关的日志。</p> <p>我们可以继续在终端一中，运行下面的命令，查看系统日志：</p> 
<pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> $ dmesg | tail </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> [88356.354329] nf_conntrack: nf_conntrack: table full, dropping 
packet </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="3"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> [88356.354374] 
nf_conntrack: nf_conntrack: table full, dropping packet </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <p>从日志中，你可以看到 nf_conntrack: table full, dropping 
packet 的错误日志。这说明，正是连接跟踪导致的问题。</p> <p>这种情况下，我们应该想起前面学过的两个内核选项——连接跟踪数的最大限制 nf_conntrack_max ，以及当前的连接跟踪数 
nf_conntrack_count。执行下面的命令，你就可以查询这两个选项：</p> <pre style="position: relative;"><code> <table 
class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> $ sysctl 
net.netfilter.nf_conntrack_max </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
net.netfilter.nf_conntrack_max = 200 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> <div 
class="hljs-ln-line"> $ sysctl net.netfilter.nf_conntrack_count </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> net.netfilter.nf_conntrack_count = 200 
</div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>这次的输出中，你可以看到最大的连接跟踪限制只有 200，并且全部被占用了。200 的限制显然太小，不过相应的优化也很简单，调大就可以了。</p> <p>我们执行下面的命令，将 
nf_conntrack_max 增大：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> # 将连接跟踪限制增大到 1048576 </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ sysctl -w net.netfilter.nf_conntrack_max=1048576 
</div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>连接跟踪限制增大后，对 Nginx 吞吐量的优化效果如何呢？我们不妨再来测试一下。你可以切换到终端二中，按下 Ctrl+C ；然后执行下面的 wrk 
命令，重新测试 Nginx 的性能：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> # 默认测试时间为 10s，请求超时 2s </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ wrk --latency -c 1000 http://192.168.0.30 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> ... </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 54221 requests in 10.07s, 15.16MB read </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> Socket errors: connect 0, read 7, write 
0, timeout 110 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="6"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
Non-2xx or 3xx responses: 45577 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="7"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
Requests/sec: 5382.21 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="8"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
Transfer/sec: 1.50MB </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <p>从 wrk 的输出中，你可以看到，连接跟踪的优化效果非常好，吞吐量已经从刚才的 
189 增大到了 5382。看起来性能提升了将近 30 倍，</p> <p>不过，这是不是就能说明，我们已经把 Nginx 的性能优化好了呢？</p> <p>别急，我们再来看看 wrk 
汇报的其他数据。果然，10s 内的总请求数虽然增大到了 5 万，但是有 4 万多响应异常，说白了，真正成功的只有 8000 多个（54221-45577=8644）。</p> <p>很明显，大部分请求的响应都是异常的。那么，该怎么分析响应异常的问题呢？</p> 
<h3>工作进程优化</h3> <p>由于这些响应并非 Socket error，说明 Nginx 已经收到了请求，只不过，响应的状态码并不是我们期望的 2xx （表示成功）或 3xx（表示重定向）。所以，这种情况下，搞清楚 
Nginx 真正的响应就很重要了。</p> <p>不过这也不难，我们切换回终端一，执行下面的 docker 命令，查询 Nginx 容器日志就知道了：</p> <pre style="position: 
relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
$ docker logs nginx --tail 3 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
192.168.0.2 - - [15/Mar/2019:2243:27 +0000] "GET / HTTP/1.1" 499 0 "-" "-" "-" </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 192.168.0.2 - - [15/Mar/2019:22:43:27 
+0000] "GET / HTTP/1.1" 499 0 "-" "-" "-" </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 192.168.0.2 - - [15/Mar/2019:22:43:27 +0000] "GET / HTTP/1.1" 499 
0 "-" "-" "-" </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <p>从 Nginx 的日志中，我们可以看到，响应状态码为 499。</p> <p>499 
并非标准的 HTTP 状态码，而是由 Nginx 扩展而来，表示服务器端还没来得及响应时，客户端就已经关闭连接了。换句话说，问题在于服务器端处理太慢，客户端因为超时（wrk 超时时间为 
2s），主动断开了连接。</p> <p>既然问题出在了服务器端处理慢，而案例本身是 Nginx+PHP 的应用，那是不是可以猜测，是因为 PHP 处理过慢呢？</p> <p>我么可以在终端中，执行下面的 
docker 命令，查询 PHP 容器日志：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> 
<tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ docker logs phpfpm --tail 5 </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> [15-Mar-2019 22:28:56] WARNING: [pool 
www] server reached max_children setting (5), consider raising it </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> [15-Mar-2019 22:43:17] WARNING: [pool 
www] server reached max_children setting (5), consider raising it </div></td> </tr> </tbody> 
</table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 </div></pre> 
<p>从这个日志中，我们可以看到两条警告信息，server reached max_children setting (5)，并建议增大 max_children。</p> <p>max_children 
表示 php-fpm 子进程的最大数量，当然是数值越大，可以同时处理的请求数就越多。不过由于这是进程问题，数量增大，也会导致更多的内存和 CPU 占用。所以，我们还不能设置得过大。</p> 
<p>一般来说，每个 php-fpm 子进程可能会占用 20 MB 左右的内存。所以，你可以根据内存和 CPU 个数，估算一个合理的值。这儿我把它设置成了 20，并将优化后的配置重新打包成了 
Docker 镜像。你可以执行下面的命令来执行它：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> 
<tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> # 停止旧的容器 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> $ docker rm -f nginx phpfpm </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
# 使用新镜像启动 Nginx 和 PHP </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="5"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
$ docker run --name nginx --network host --privileged -itd feisky/nginx-tp:1 </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ docker run --name phpfpm --network host 
--privileged -itd feisky/php-fpm-tp:1 </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <p>然后我们切换到终端二，再次执行下面的 wrk 命令，重新测试 Nginx 的性能：</p> 
<pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> # 默认测试时间为 10s，请求超时 2s </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> $ wrk --latency -c 1000 http://192.168.0.30 </div></td> </tr> <tr> 
<td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> ... </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 47210 requests in 10.08s, 12.51MB read </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> Socket errors: connect 0, read 4, write 
0, timeout 91 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="6"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
Non-2xx or 3xx responses: 31692 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="7"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
Requests/sec: 4683.82 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="8"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
Transfer/sec: 1.24MB </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <p>从 wrk 的输出中，可以看到，虽然吞吐量只有 4683，比刚才的 5382 
少了一些；但是测试期间成功的请求数却多了不少，从原来的 8000，增长到了 15000（47210-31692=15518）。</p> <p>不过，虽然性能有所提升，可 4000 多的吞吐量显然还是比较差的，并且大部分请求的响应依然还是异常。接下来，该怎么去进一步提升 
Nginx 的吞吐量呢？</p> <h3>套接字优化</h3> <p>回想一下网络性能的分析套路，以及 Linux 协议栈的原理，我们可以从从套接字、TCP 协议等逐层分析。而分析的第一步，自然还是要观察有没有发生丢包现象。</p> 
<p>我们切换到终端二中，重新运行测试，这次还是要用 -d 参数延长测试时间，以便模拟性能瓶颈的现场：</p> <pre style="position: relative;"><code> 
<table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
# 测试时间 30 分钟 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> $ wrk 
--latency -c 1000 -d 1800 http://192.168.0.30 </div></td> </tr> </tbody> </table></code> <div 
class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 </div></pre> <p>然后回到终端一中，观察有没有发生套接字的丢包现象：</p> 
<pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> # 只关注套接字统计 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> <div 
class="hljs-ln-line"> $ netstat -s | grep socket </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 73 resets received for embryonic SYN_RECV sockets </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 308582 TCP sockets finished time wait 
in fast timer </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="5"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
8 delayed acks further delayed because of locked socket </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 290566 times the listen queue of a socket overflowed </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 290566 SYNs to LISTEN sockets dropped 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> # 稍等一会，再次运行 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> $ netstat -s | grep socket </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 73 resets received for embryonic SYN_RECV sockets </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 314722 TCP sockets finished time wait 
in fast timer </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="13"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
8 delayed acks further delayed because of locked socket </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="14"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 344440 times the listen queue of a socket overflowed </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="15"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 344440 SYNs to LISTEN sockets dropped 
</div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>根据两次统计结果中 socket overflowed 和 sockets dropped 的变化，你可以看到，有大量的套接字丢包，并且丢包都是套接字队列溢出导致的。所以，接下来，我们应该分析连接队列的大小是不是有异常。</p> 
<p>你可以执行下面的命令，查看套接字的队列大小：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> 
<tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ ss -ltnp </div></td> </tr> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> State Recv-Q Send-Q Local Address:Port 
Peer Address:Port </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
LISTEN 10 10 0.0.0.0:80 0.0.0.0:* users:(("nginx",pid=10491,fd=6),("nginx",pid=10490,fd=6),("nginx",pid=10487,fd=6)) 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> LISTEN 7 10 *:9000 *:* users:(("php-fpm",pid=11084,fd=9),...,("php-fpm",pid=10529,fd=7)) 
</div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>这次可以看到，Nginx 和 php-fpm 的监听队列 （Send-Q）只有 10，而 nginx 的当前监听队列长度 （Recv-Q）已经达到了最大值，php-fpm 
也已经接近了最大值。很明显，套接字监听队列的长度太小了，需要增大。</p> <p>关于套接字监听队列长度的设置，既可以在应用程序中，通过套接字接口调整，也支持通过内核选项来配置。我们继续在终端一中，执行下面的命令，分别查询 
Nginx 和内核选项对监听队列长度的配置：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> 
<tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> # 查询 nginx 监听队列长度配置 </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ docker exec nginx cat /etc/nginx/nginx.conf 
| grep backlog </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
listen 80 backlog=10; </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> # 查询 php-fpm 监听队列长度 </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ docker exec phpfpm cat /opt/bitnami/php/etc/php-fpm.d/www.conf 
| grep backlog </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="7"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
; Set listen(2) backlog. </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="8"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
;listen.backlog = 511 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="9"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> # somaxconn 是系统级套接字监听队列上限 </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ sysctl net.core.somaxconn </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> net.core.somaxconn = 10 </div></td> </tr> 
</tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>从输出中可以看到，Nginx 和 somaxconn 的配置都是 10，而 php-fpm 的配置也只有 511，显然都太小了。那么，优化方法就是增大这三个配置，比如，可以把 
Nginx 和 php-fpm 的队列长度增大到 8192，而把 somaxconn 增大到 65536。</p> <p>同样地，我也把这些优化后的 Nginx ，重新打包成了两个 
Docker 镜像，你可以执行下面的命令来运行它：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> 
<tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> # 停止旧的容器 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> $ docker rm -f nginx phpfpm </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
# 使用新镜像启动 Nginx 和 PHP </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="5"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
$ docker run --name nginx --network host --privileged -itd feisky/nginx-tp:2 </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ docker run --name phpfpm --network host 
--privileged -itd feisky/php-fpm-tp:2 </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <p>然后，切换到终端二中，重新测试 Nginx 的性能：</p> <pre style="position: 
relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
$ wrk --latency -c 1000 http://192.168.0.30 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> ... </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
62247 requests in 10.06s, 18.25MB read </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> Non-2xx or 3xx responses: 62247 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> Requests/sec: 6185.65 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> Transfer/sec: 1.81MB </div></td> </tr> </tbody> </table></code> 
<div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 </div></pre> <p>现在的吞吐量已经增大到了 
6185，并且在测试的时候，如果你在终端一中重新执行 <em>netstat -s | grep socket</em>，还会发现，现在已经没有套接字丢包问题了。</p> <p>不过，这次 
Nginx 的响应，再一次全部失败了，都是 Non-2xx or 3xx。这是怎么回事呢？我们再去终端一中，查看 Nginx 日志：</p> <pre style="position: 
relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
$ docker logs nginx --tail 10 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
2019/03/15 16:52:39 [crit] 15#15: *999779 connect() to 127.0.0.1:9000 failed (99: Cannot assign 
requested address) while connecting to upstream, client: 192.168.0.2, server: localhost, request: 
"GET / HTTP/1.1", upstream: "fastcgi://127.0.0.1:9000", host: "192.168.0.30" </div></td> </tr> 
</tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>你可以看到，Nginx 报出了无法连接 fastcgi 的错误，错误消息是 Connect 时， Cannot assign requested address。这个错误消息对应的错误代码为 
EADDRNOTAVAIL，表示 IP 地址或者端口号不可用。</p> <p>在这里，显然只能是端口号的问题。接下来，我们就来分析端口号的情况。</p> <h3>端口号优化</h3> 
<p>根据网络套接字的原理，当客户端连接服务器端时，需要分配一个临时端口号，而 Nginx 正是 PHP-FPM 的客户端。端口号的范围并不是无限的，最多也只有 6 万多。</p> 
<p>我们执行下面的命令，就可以查询系统配置的临时端口号范围：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> 
<tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ sysctl net.ipv4.ip_local_port_range 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> net.ipv4.ip_local_port_range=20000 20050 
</div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>你可以看到，临时端口的范围只有 50 个，显然太小了 。优化方法很容易想到，增大这个范围就可以了。比如，你可以执行下面的命令，把端口号范围扩展为 “10000 
65535”：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td 
class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ sysctl -w net.ipv4.ip_local_port_range="10000 
65535" </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> net.ipv4.ip_local_port_range 
= 10000 65535 </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <p>优化完成后，我们再次切换到终端二中，测试性能：</p> <pre style="position: 
relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
$ wrk --latency -c 1000 http://192.168.0.30/ </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> ... </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
32308 requests in 10.07s, 6.71MB read </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> <div 
class="hljs-ln-line"> Socket errors: connect 0, read 2027, write 0, timeout 433 </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> Non-2xx or 3xx responses: 30 </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> Requests/sec: 3208.58 </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> Transfer/sec: 682.15KB </div></td> </tr> 
</tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>这次，异常的响应少多了 ，不过，吞吐量也下降到了 3208。并且，这次还出现了很多 Socket read errors。显然，还得进一步优化。</p> 
<h3>火焰图</h3> <p>前面我们已经优化了很多配置。这些配置在优化网络的同时，却也会带来其他资源使用的上升。这样来看，是不是说明其他资源遇到瓶颈了呢？</p> <p>我们不妨在终端二中，执行下面的命令，重新启动长时间测试：</p> 
<pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> # 测试时间 30 分钟 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> $ wrk --latency -c 1000 -d 1800 http://192.168.0.30 </div></td> 
</tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>然后，切换回终端一中，执行 top ，观察 CPU 和内存的使用：</p> <pre style="position: relative;"><code> 
<table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
$ top </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> ... </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> %Cpu0 : 30.7 us, 48.7 sy, 0.0 ni, 2.3 
id, 0.0 wa, 0.0 hi, 18.3 si, 0.0 st </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> <div 
class="hljs-ln-line"> %Cpu1 : 28.2 us, 46.5 sy, 0.0 ni, 2.0 id, 0.0 wa, 0.0 hi, 23.3 si, 0.0 
st </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="5"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> KiB Mem 
: 8167020 total, 5867788 free, 490400 used, 1808832 buff/cache </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> KiB Swap: 0 total, 0 free, 0 used. 7361172 avail Mem </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 20379 systemd+ 20 0 38068 8692 2392 R 
36.1 0.1 0:28.86 nginx </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="10"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
20381 systemd+ 20 0 38024 8700 2392 S 33.8 0.1 0:29.29 nginx </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> 1558 root 20 0 1118172 85868 39044 S 32.8 1.1 22:55.79 dockerd </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> 20313 root 20 0 11024 5968 3956 S 27.2 
0.1 0:22.78 docker-containe </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="13"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
13730 root 20 0 0 0 0 I 4.0 0.0 0:10.07 kworker/u4:0-ev </div></td> </tr> </tbody> </table></code> 
<div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 </div></pre> <p>从 top 
的结果中可以看到，可用内存还是很充足的，但系统 CPU 使用率（sy）比较高，两个 CPU 的系统 CPU 使用率都接近 50%，且空闲 CPU 使用率只有 2%。再看进程部分，CPU 
主要被两个 Nginx 进程和两个 docker 相关的进程占用，使用率都是 30% 左右。</p> <p>CPU 使用率上升了，该怎么进行分析呢？我想，你已经还记得我们多次用到的 
perf，再配合前两节讲过的火焰图，很容易就能找到系统中的热点函数。</p> <p>我们保持终端二中的 wrk 继续运行；在终端一中，执行 perf 和 flamegraph 脚本，生成火焰图：</p> 
<pre style="position: relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> # 执行 perf 记录事件 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> $ perf record -g </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
# 切换到 FlameGraph 安装路径执行下面的命令生成火焰图 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> <td class="hljs-ln-code"> <div 
class="hljs-ln-line"> $ perf script -i ~/perf.data | ./stackcollapse-perf.pl --all | ./flamegraph.pl 
&gt; nginx.svg </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <p>然后，使用浏览器打开生成的 nginx.svg ，你就可以看到下面的火焰图：</p> 
<p><img src="https://static001.geekbang.org/resource/image/89/c6/8933557b5eb8c8f41a629e751fd7f0c6.png" 
alt=""></p> <p>根据我们讲过的火焰图原理，这个图应该从下往上、沿着调用栈中最宽的函数，来分析执行次数最多的函数。</p> <p>这儿中间的 do_syscall_64、tcp_v4_connect、inet_hash_connect 
这个堆栈，很明显就是最需要关注的地方。inet_hash_connect() 是 Linux 内核中负责分配临时端口号的函数。所以，这个瓶颈应该还在临时端口的分配上。</p> <p>在上一步的“端口号”优化中，临时端口号的范围，已经优化成了 
“10000 65535”。这显然是一个非常大的范围，那么，端口号的分配为什么又成了瓶颈呢？</p> <p>一时想不到也没关系，我们可以暂且放下，先看看其他因素的影响。再顺着 inet_hash_connect 
往堆栈上面查看，下一个热点是 __init_check_established 函数。而这个函数的目的，是检查端口号是否可用。结合这一点，你应该可以想到，如果有大量连接占用着端口，那么检查端口号可用的函数，不就会消耗更多的 
CPU 吗？</p> <p>实际是否如此呢？我们可以继续在终端一中运行 ss 命令， 查看连接状态统计：</p> <pre style="position: relative;"><code> 
<table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
$ ss -s </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> TCP: 
32775 (estab 1, closed 32768, orphaned 0, synrecv 0, timewait 32768/0), ports 0 </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> ... </div></td> </tr> </tbody> </table></code> 
<div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 </div></pre> <p>这回可以看到，有大量连接（这儿是 
32768）处于 timewait 状态，而 timewait 状态的连接，本身会继续占用端口号。如果这些端口号可以重用，那么自然就可以缩短 __init_check_established 
的过程。而 Linux 内核中，恰好有一个 tcp_tw_reuse 选项，用来控制端口号的重用。</p> <p>我们在终端一中，运行下面的命令，查询它的配置：</p> <pre style="position: 
relative;"><code> <table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
$ sysctl net.ipv4.tcp_tw_reuse </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
net.ipv4.tcp_tw_reuse = 0 </div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> 
<span class="iconfont"></span>复制代码 </div></pre> <p>你可以看到，tcp_tw_reuse 是 0，也就是禁止状态。其实看到这里，我们就能理解，为什么临时端口号的分配会是系统运行的热点了。当然，优化方法也很容易，把它设置成 
1 就可以开启了。</p> <p>我把优化后的应用，也打包成了两个 Docker 镜像，你可以执行下面的命令来运行：</p> <pre style="position: relative;"><code> 
<table class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
# 停止旧的容器 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="2"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> $ docker 
rm -f nginx phpfpm </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
</div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> # 使用新镜像启动 Nginx 和 PHP </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ docker run --name nginx --network host 
--privileged -itd feisky/nginx-tp:3 </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div 
class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> <td class="hljs-ln-code"> <div 
class="hljs-ln-line"> $ docker run --name phpfpm --network host --privileged -itd feisky/php-fpm-tp:3 
</div></td> </tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>容器启动后，切换到终端二中，再次测试优化后的效果：</p> <pre style="position: relative;"><code> <table 
class="hljs-ln"> <tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" 
data-line-number="1"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> $ wrk 
--latency -c 1000 http://192.168.0.30/ </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> ... </div></td> </tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line 
hljs-ln-n" data-line-number="3"></div></td> <td class="hljs-ln-code"> <div class="hljs-ln-line"> 
52119 requests in 10.06s, 10.81MB read </div></td> </tr> <tr> <td class="hljs-ln-numbers"> 
<div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td> <td class="hljs-ln-code"> 
<div class="hljs-ln-line"> Socket errors: connect 0, read 850, write 0, timeout 0 </div></td> 
</tr> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> Requests/sec: 5180.48 </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> Transfer/sec: 1.07MB </div></td> </tr> 
</tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <p>现在的吞吐量已经达到了 5000 多，并且只有少量的 Socket errors，也不再有 Non-2xx or 3xx 的响应了。说明一切终于正常了。</p> 
<p>案例的最后，不要忘记执行下面的命令，删除案例应用：</p> <pre style="position: relative;"><code> <table class="hljs-ln"> 
<tbody> <tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> # 停止 nginx 和 phpfpm 容器 </div></td> </tr> 
<tr> <td class="hljs-ln-numbers"> <div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td> 
<td class="hljs-ln-code"> <div class="hljs-ln-line"> $ docker rm -f nginx phpfpm </div></td> 
</tr> </tbody> </table></code> <div class="richcontent-pre-copy"> <span class="iconfont"></span>复制代码 
</div></pre> <h2>小结</h2> <p>今天，我带你一起学习了服务吞吐量下降后的分析方法。其实，从这个案例你也可以看出，性能问题的分析，总是离不开系统和应用程序的原理。</p> 
<p>实际上，分析性能瓶颈，最核心的也正是掌握运用这些原理。</p> <ul> <li> <p>首先，利用各种性能工具，收集想要的性能指标，从而清楚系统和应用程序的运行状态；</p> 
</li> <li> <p>其次，拿目前状态跟系统原理进行比较，不一致的地方，就是我们要重点分析的对象。</p> </li> </ul> <p>从这个角度出发，再进一步借助 perf、火焰图、bcc 
等动态追踪工具，找出热点函数，就可以定位瓶颈的来源，确定相应的优化方法。</p> <h2>思考</h2> <p>最后，我想邀请你一起来聊聊，你碰到过的吞吐量下降问题。你是怎么分析它们的根源？又是怎么解决的？你可以结合我的讲述，总结自己的思路。</p> 
<p>欢迎在留言区和我讨论，也欢迎把这篇文章分享给你的同事、朋友。我们一起在实战中演练，在交流中进步。</p> <p><img src="https://static001.geekbang.org/resource/image/a3/e9/a396aed4116c2c989771c1295736abe9.jpg" 
alt=""></p>', body_summary='', bundle='book', delta=0, body_format='full_html', langcode='zh-hans', 
revision_id=1085 where entity_id=1085 
 {executed in 1 msec}
2020-11-25 10:18:11.091 INFO  jdbc.sqltiming Line:373 - select nodefiledd0_.nid as nid1_10_, nodefiledd0_.changed as changed2_10_, nodefiledd0_.created 
as created3_10_, nodefiledd0_.default_langcode as default_4_10_, nodefiledd0_.langcode as langcode5_10_, 
nodefiledd0_.promote as promote6_10_, nodefiledd0_.revision_translation_affected as revision7_10_, 
nodefiledd0_.status as status8_10_, nodefiledd0_.sticky as sticky9_10_, nodefiledd0_.title 
as title10_10_, nodefiledd0_.type as type11_10_, nodefiledd0_.uid as uid12_10_, nodefiledd0_.vid 
as vid13_10_ from node_field_data nodefiledd0_ where nodefiledd0_.nid=1085 
 {executed in 0 msec}
2020-11-25 10:18:11.091 INFO  jdbc.resultsettable Line:610 - 
|-----|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|------------------------|-----|----|-----|
|nid  |changed    |created    |default_langcode |langcode |promote |revision_translation_affected |status |sticky |title                   |type |uid |vid  |
|-----|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|------------------------|-----|----|-----|
|1085 |1606114995 |1606114995 |1                |zh-hans  |0       |1                             |1      |0      |52丨案例篇：服务吞吐量下降很厉害，怎么分析？ |book |1   |1085 |
|-----|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|------------------------|-----|----|-----|

2020-11-25 10:18:11.092 INFO  jdbc.sqltiming Line:373 - select nodefieldr0_.nid as nid1_11_0_, nodefieldr0_.changed as changed2_11_0_, nodefieldr0_.created 
as created3_11_0_, nodefieldr0_.default_langcode as default_4_11_0_, nodefieldr0_.langcode 
as langcode5_11_0_, nodefieldr0_.promote as promote6_11_0_, nodefieldr0_.revision_translation_affected 
as revision7_11_0_, nodefieldr0_.status as status8_11_0_, nodefieldr0_.sticky as sticky9_11_0_, 
nodefieldr0_.title as title10_11_0_, nodefieldr0_.uid as uid11_11_0_, nodefieldr0_.vid as vid12_11_0_ 
from node_field_revision nodefieldr0_ where nodefieldr0_.nid=1085 
 {executed in 0 msec}
2020-11-25 10:18:11.093 INFO  jdbc.resultsettable Line:610 - 
|---------|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|------------------------|----|-----|
|nid      |changed    |created    |default_langcode |langcode |promote |revision_translation_affected |status |sticky |title                   |uid |vid  |
|---------|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|------------------------|----|-----|
|[unread] |1606114995 |1606114995 |1                |zh-hans  |0       |1                             |1      |0      |52丨案例篇：服务吞吐量下降很厉害，怎么分析？ |1   |1085 |
|---------|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|------------------------|----|-----|

2020-11-25 10:18:11.094 INFO  jdbc.sqltiming Line:373 - update node_field_data set changed=1606270691, created=1606270691, default_langcode=1, langcode='zh-hans', 
promote=0, revision_translation_affected=1, status=1, sticky=0, title='52丨案例篇：服务吞吐量下降很厉害，怎么分析？', 
type='book', uid=1, vid=1085 where nid=1085 
 {executed in 0 msec}
2020-11-25 10:18:11.094 INFO  jdbc.sqltiming Line:373 - update node_field_revision set changed=1606270691, created=1606270691, default_langcode=1, 
langcode='zh-hans', promote=0, revision_translation_affected=1, status=1, sticky=0, title='52丨案例篇：服务吞吐量下降很厉害，怎么分析？', 
uid=1, vid=1085 where nid=1085 
 {executed in 0 msec}
2020-11-25 10:18:11.099 INFO  jdbc.sqltiming Line:373 - select bookfieldm0_.entity_id as entity_i1_8_, bookfieldm0_.bundle as bundle2_8_, bookfieldm0_.delta 
as delta3_8_, bookfieldm0_.langcode as langcode4_8_, bookfieldm0_.field_media_value as field_me5_8_, 
bookfieldm0_.revision_id as revision6_8_ from node__field_media bookfieldm0_ where bookfieldm0_.entity_id=1085 
 {executed in 0 msec}
2020-11-25 10:18:11.099 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------------|------------|
|entity_id |bundle |delta |langcode |field_media_value |revision_id |
|----------|-------|------|---------|------------------|------------|
|1085      |book   |0     |zh-hans  |                  |1085        |
|----------|-------|------|---------|------------------|------------|

2020-11-25 10:18:11.101 INFO  jdbc.sqltiming Line:373 - select nodefieldm0_.entity_id as entity_i1_17_0_, nodefieldm0_.bundle as bundle2_17_0_, nodefieldm0_.delta 
as delta3_17_0_, nodefieldm0_.langcode as langcode4_17_0_, nodefieldm0_.field_media_value as 
field_me5_17_0_, nodefieldm0_.revision_id as revision6_17_0_ from node_revision__field_media 
nodefieldm0_ where nodefieldm0_.entity_id=1085 
 {executed in 0 msec}
2020-11-25 10:18:11.101 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------------|------------|
|entity_id |bundle |delta |langcode |field_media_value |revision_id |
|----------|-------|------|---------|------------------|------------|
|[unread]  |book   |0     |zh-hans  |                  |1085        |
|----------|-------|------|---------|------------------|------------|

2020-11-25 10:18:11.103 INFO  jdbc.sqltiming Line:373 - select bookfieldc0_.entity_id as entity_i1_5_, bookfieldc0_.bundle as bundle2_5_, bookfieldc0_.field_comment_value 
as field_co3_5_, bookfieldc0_.delta as delta4_5_, bookfieldc0_.field_comment_format as field_co5_5_, 
bookfieldc0_.langcode as langcode6_5_, bookfieldc0_.revision_id as revision7_5_ from node__field_comment 
bookfieldc0_ where bookfieldc0_.entity_id=1085 
 {executed in 0 msec}
2020-11-25 10:18:11.103 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|--------------------|------|---------------------|---------|------------|
|entity_id |bundle |field_comment_value |delta |field_comment_format |langcode |revision_id |
|----------|-------|--------------------|------|---------------------|---------|------------|
|1085      |book   |                    |0     |full_html            |zh-hans  |1085        |
|----------|-------|--------------------|------|---------------------|---------|------------|

2020-11-25 10:18:11.106 INFO  jdbc.sqltiming Line:373 - update node__field_comment set bundle='book', field_comment_value='<li class="reJj6Thl_0"><img 
src="https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>我来也</span> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-26 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">4</span> </div> <!----> 
<!----> </div> </div> <div class="_3M6kV3zb_0"> [D52打卡] <br>哈哈,看专栏的同时,也在生产环境中执行下查看套接字的命令. <br>居然还发现了一个高并发时的隐患. 
<br>`ss -ltnp` <br>&nbsp;&nbsp;有些监听端口半链接队列的值偏小,只有32.而有些都是128. <br>&nbsp;&nbsp;赶紧查看程序源码,发现是调用框架的接口时未传递backlog的值,导致使用框架默认的值32. 
<br>&nbsp;&nbsp;哈哈,这个程序是专门处理客户端连接的,虽然目前Recv-Q都为0,但也确实是一个隐患吧. <br>`ss -s` <br>&nbsp;&nbsp;看到的连接数和各状态数还正常. 
<br>`netstat -s | grep -wE "socket|listen"` <br>&nbsp;&nbsp;结果还比较稳定. <br>像 sysctl 相关的配置,由于没有权限,就无缘查看了. 
<br> <br>不得不说,综合案例篇的内容真不错.老师也是够狠,设置了这么多的坑.填了一个一个又一个. <br>1.内核连接数限制 nf_conntrack. <br>2.php程序的工作进程数量 
<br>3.半链接队列偏小,导致高并发时的丢包. <br>4.系统分配的临时端口号范围. <br>5.系统的端口复用参数配置. <br> <br>调优过程中,有时甚至是一波未平一波又起,很是惊险刺激. 
<br> <br> </div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> 
<!----> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/14/11/4b/fa64f061.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>xfan</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-28 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> </div> <!----> 
<!----> </div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 内核选项 tcp_tw_reuse，不是直接修改内核参数就好了么，为什么还有修改后的tag:3 
,这里不太清楚 </div> <!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 嗯 也可以的。打包成镜像的是最后优化的结果</p> 
</div> </div></li> <li class="reJj6Thl_0"><img src="https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKCmqW21Zguv8kPiayib4U42B3jLGk2Y4Leia0fQjnU0Lfgic8BwbdMIePiayDadFKzV9kSt3F8jRicZxxA/132" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>泡泡</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-26 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> </div> <!----> 
<!----> </div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> wrk命令-c参数用来模拟连接数为1000， <br>为什么输出中的连接数有1910，不理解 
</div> <!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: -c是并发数，输出中是每秒请求数，不是一回事</p> 
</div> </div></li> <li class="reJj6Thl_0"><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKsz8j0bAayjSne9iakvjzUmvUdxWEbsM9iasQ74spGFayIgbSE232sH2LOWmaKtx1WqAFDiaYgVPwIQ/132" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>2xshu</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-25 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> </div> <!----> 
<!----> </div> </div> <div class="_3M6kV3zb_0"> 老师，有个疑问。 <br>套接字优化部分，你用ss -s输出的两个队列，根据“关于 Linux 
网络，你必须知道这些（下）”你讲的内容，当链接处于listening状态是，Send-Q和Recv-Q都是半链接队列，但是你这里却都是调的全连接队列啊？不是应该调整tcp_max_syn_backlog吗？ 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 嗯，谢谢指出，是文中的步骤不严谨了。实际上应该再加上两步<br><br>1. 查看调优 tcp_max_syn_backlog<br>2. 
观察全连接的状况之后再调优全连接队列</p> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/10/93/43/0e84492d.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>Maxwell</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-25 </div> </div> <div 
class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> 
</div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0"> 在公司局域网下做性能测试，如何判断网络会不会成为压测的瓶颈呢？也就是说如果开了500线程进行压测，会不会因为网络瓶颈，导致请求无法发送到服务器端？ 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 可以在测试的时候同时观察一下网络吞吐和丢包（比如使用sar）</p> </div> </div></li> <li class="reJj6Thl_0"><img 
src="https://static001.geekbang.org/account/avatar/00/0f/62/81/ad80f427.jpg" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>Lane</span> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-25 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> </div> <!----> 
<!----> </div> </div> <div class="_3M6kV3zb_0"> 一天看2篇，终于追上进度了 </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <!----> </div></li> <li class="reJj6Thl_0"><img 
src="https://wx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEKQMM4m7NHuicr55aRiblTSEWIYe0QqbpyHweaoAbG7j2v7UUElqqeP3Ihrm3UfDPDRb1Hv8LvPwXqA/132" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>ninuxer</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-25 </div> </div> <div 
class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> 
</div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 打卡day55 <br>缺乏由现象联想到可能原因的系统性思维～ 
</div> <!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 还是需要加强原理的理解</p> </div> 
</div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/12/c0/ce/fc41ad5e.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>陳先森</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-05-06 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> 打下卡。 </div> <div class="_2r3UB1GX_0"> <span>展开</span><i 
class="iconfont"></i> </div> <!----> </div></li> <li class="reJj6Thl_0"><img src="" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>如果</span> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2019-04-22 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> DAY52，打卡 <br> </div> <div class="_2r3UB1GX_0"> <span>展开</span><i 
class="iconfont"></i> </div> <!----> </div></li> <li class="reJj6Thl_0"><img src="" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>腾达</span> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2019-04-15 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> net.ipv4.tcp_tw_reuse = 1 这里是影响到socket的客户端（nginx作为一个客户端连接php的服务端）的行为吗？ 
不是影响到服务端的time_wait数量？ 我弄了个tomcat，用ab压测，tw_use=1, 用ss -s看time_wait 还很高啊，1万多。 </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 
嗯 用在客户端上</p> </div> </div></li> <li class="reJj6Thl_0"><img src="" class="_2273kGdT_0"> <div 
class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>腾达</span> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2019-04-12 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> 是的，都对比过了，还包括php的配置，都对比过了 </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <!----> </div></li> <li class="reJj6Thl_0"><img 
src="" class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div 
class="_18Dng5rT_0"> <span>腾达</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-04-08 </div> 
</div> <div class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span 
class=""></span> </div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 
老师，针对我提的问题，您的回复是：“不过你可以docker exec到容器内部查看”，我已经逐一对比过容器内的、我已知的参数了。未发现不同。您能否把最后一次的配置参数上传一下到github？ 
</div> <!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 包括内核选项和Nginx配置吗？</p> 
</div> </div></li> <li class="reJj6Thl_0"><img src="" class="_2273kGdT_0"> <div class="_2CG0SquK_0"> 
<div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>腾达</span> <!----> </div> <div 
class="_1H1Z49Dr_0"> 2019-04-05 </div> </div> <div class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> 
<i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> </div> </div> <div 
class="_3M6kV3zb_0"> 有2个问题： <br>1、在做perf，制作火焰图的部分，我自己本地看到的函数热点是类似：inet_sendmsg, tcp_write_xmit, 
e1000_xmit_frame 之类的，后续再对内核参数net.ipv4.tcp_tw_reuse做设置为1的处理后，函数热点依然是这几个。似乎我的机器上的热点是在发送数据，而不是在端口重用？ 
<br>2、老师最后1个步骤的镜像，即： <br><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span 
class="MathJax" id="MathJax-Element-1-Frame" tabindex="0" style="position: relative;" data-mathml="<math 
xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>d</mi><mi>o</mi><mi>c</mi><mi>k</mi><mi>e</mi><mi>r</mi><mi>r</mi><mi>u</mi><mi>n</mi><mo>−</mo><mo>−</mo><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>i</mi><mi>n</mi><mi>x</mi><mo>−</mo><mo>−</mo><mi>n</mi><mi>e</mi><mi>t</mi><mi>w</mi><mi>o</mi><mi>r</mi><mi>k</mi><mi>h</mi><mi>o</mi><mi>s</mi><mi>t</mi><mo>−</mo><mo>−</mo><mi>p</mi><mi>r</mi><mi>i</mi><mi>v</mi><mi>i</mi><mi>l</mi><mi>e</mi><mi>g</mi><mi>e</mi><mi>d</mi><mo>−</mo><mi>i</mi><mi>t</mi><mi>d</mi><mi>f</mi><mi>e</mi><mi>i</mi><mi>s</mi><mi>k</mi><mi>y</mi><mrow 
class=&quot;MJX-TeXAtom-ORD&quot;><mo>/</mo></mrow><mi>n</mi><mi>g</mi><mi>i</mi><mi>n</mi><mi>x</mi><mo>−</mo><mi>t</mi><mi>p</mi><mo>:</mo><mn>3</mn></math>" 
role="presentation"> <nobr aria-hidden="true"> <span class="math" id="MathJax-Span-1" style="width: 
46.352em; display: inline-block;"><span style="display: inline-block; position: relative; width: 
37.052em; height: 0px; font-size: 125%;"><span style="position: absolute; clip: rect(1.453em, 
1037em, 2.752em, -999.998em); top: -2.348em; left: 0em;"><span class="mrow" id="MathJax-Span-2"><span 
class="mi" id="MathJax-Span-3" style="font-family: MathJax_Math-italic;">d<span style="display: 
inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mi" 
id="MathJax-Span-4" style="font-family: MathJax_Math-italic;">o</span><span class="mi" id="MathJax-Span-5" 
style="font-family: MathJax_Math-italic;">c</span><span class="mi" id="MathJax-Span-6" style="font-family: 
MathJax_Math-italic;">k</span><span class="mi" id="MathJax-Span-7" style="font-family: MathJax_Math-italic;">e</span><span 
class="mi" id="MathJax-Span-8" style="font-family: MathJax_Math-italic;">r</span><span class="mi" 
id="MathJax-Span-9" style="font-family: MathJax_Math-italic;">r</span><span class="mi" id="MathJax-Span-10" 
style="font-family: MathJax_Math-italic;">u</span><span class="mi" id="MathJax-Span-11" style="font-family: 
MathJax_Math-italic;">n</span><span class="mo" id="MathJax-Span-12" style="font-family: MathJax_Main; 
padding-left: 0.202em;">−</span><span class="mo" id="MathJax-Span-13" style="font-family: MathJax_Main; 
padding-left: 0.202em;">−</span><span class="mi" id="MathJax-Span-14" style="font-family: MathJax_Math-italic;">n</span><span 
class="mi" id="MathJax-Span-15" style="font-family: MathJax_Math-italic;">a</span><span class="mi" 
id="MathJax-Span-16" style="font-family: MathJax_Math-italic;">m</span><span class="mi" id="MathJax-Span-17" 
style="font-family: MathJax_Math-italic;">e</span><span class="mi" id="MathJax-Span-18" style="font-family: 
MathJax_Math-italic;">n</span><span class="mi" id="MathJax-Span-19" style="font-family: MathJax_Math-italic;">g<span 
style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span 
class="mi" id="MathJax-Span-20" style="font-family: MathJax_Math-italic;">i</span><span class="mi" 
id="MathJax-Span-21" style="font-family: MathJax_Math-italic;">n</span><span class="mi" id="MathJax-Span-22" 
style="font-family: MathJax_Math-italic;">x</span><span class="mo" id="MathJax-Span-23" style="font-family: 
MathJax_Main; padding-left: 0.202em;">−</span><span class="mo" id="MathJax-Span-24" style="font-family: 
MathJax_Main; padding-left: 0.202em;">−</span><span class="mi" id="MathJax-Span-25" style="font-family: 
MathJax_Math-italic;">n</span><span class="mi" id="MathJax-Span-26" style="font-family: MathJax_Math-italic;">e</span><span 
class="mi" id="MathJax-Span-27" style="font-family: MathJax_Math-italic;">t</span><span class="mi" 
id="MathJax-Span-28" style="font-family: MathJax_Math-italic;">w</span><span class="mi" id="MathJax-Span-29" 
style="font-family: MathJax_Math-italic;">o</span><span class="mi" id="MathJax-Span-30" style="font-family: 
MathJax_Math-italic;">r</span><span class="mi" id="MathJax-Span-31" style="font-family: MathJax_Math-italic;">k</span><span 
class="mi" id="MathJax-Span-32" style="font-family: MathJax_Math-italic;">h</span><span class="mi" 
id="MathJax-Span-33" style="font-family: MathJax_Math-italic;">o</span><span class="mi" id="MathJax-Span-34" 
style="font-family: MathJax_Math-italic;">s</span><span class="mi" id="MathJax-Span-35" style="font-family: 
MathJax_Math-italic;">t</span><span class="mo" id="MathJax-Span-36" style="font-family: MathJax_Main; 
padding-left: 0.202em;">−</span><span class="mo" id="MathJax-Span-37" style="font-family: MathJax_Main; 
padding-left: 0.202em;">−</span><span class="mi" id="MathJax-Span-38" style="font-family: MathJax_Math-italic;">p</span><span 
class="mi" id="MathJax-Span-39" style="font-family: MathJax_Math-italic;">r</span><span class="mi" 
id="MathJax-Span-40" style="font-family: MathJax_Math-italic;">i</span><span class="mi" id="MathJax-Span-41" 
style="font-family: MathJax_Math-italic;">v</span><span class="mi" id="MathJax-Span-42" style="font-family: 
MathJax_Math-italic;">i</span><span class="mi" id="MathJax-Span-43" style="font-family: MathJax_Math-italic;">l</span><span 
class="mi" id="MathJax-Span-44" style="font-family: MathJax_Math-italic;">e</span><span class="mi" 
id="MathJax-Span-45" style="font-family: MathJax_Math-italic;">g<span style="display: inline-block; 
overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mi" id="MathJax-Span-46" 
style="font-family: MathJax_Math-italic;">e</span><span class="mi" id="MathJax-Span-47" style="font-family: 
MathJax_Math-italic;">d<span style="display: inline-block; overflow: hidden; height: 1px; width: 
0.003em;"></span></span><span class="mo" id="MathJax-Span-48" style="font-family: MathJax_Main; 
padding-left: 0.202em;">−</span><span class="mi" id="MathJax-Span-49" style="font-family: MathJax_Math-italic; 
padding-left: 0.202em;">i</span><span class="mi" id="MathJax-Span-50" style="font-family: MathJax_Math-italic;">t</span><span 
class="mi" id="MathJax-Span-51" style="font-family: MathJax_Math-italic;">d<span style="display: 
inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mi" 
id="MathJax-Span-52" style="font-family: MathJax_Math-italic;">f<span style="display: inline-block; 
overflow: hidden; height: 1px; width: 0.053em;"></span></span><span class="mi" id="MathJax-Span-53" 
style="font-family: MathJax_Math-italic;">e</span><span class="mi" id="MathJax-Span-54" style="font-family: 
MathJax_Math-italic;">i</span><span class="mi" id="MathJax-Span-55" style="font-family: MathJax_Math-italic;">s</span><span 
class="mi" id="MathJax-Span-56" style="font-family: MathJax_Math-italic;">k</span><span class="mi" 
id="MathJax-Span-57" style="font-family: MathJax_Math-italic;">y<span style="display: inline-block; 
overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="texatom" id="MathJax-Span-58"><span 
class="mrow" id="MathJax-Span-59"><span class="mo" id="MathJax-Span-60" style="font-family: 
MathJax_Main;">/</span></span></span><span class="mi" id="MathJax-Span-61" style="font-family: 
MathJax_Math-italic;">n</span><span class="mi" id="MathJax-Span-62" style="font-family: MathJax_Math-italic;">g<span 
style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span 
class="mi" id="MathJax-Span-63" style="font-family: MathJax_Math-italic;">i</span><span class="mi" 
id="MathJax-Span-64" style="font-family: MathJax_Math-italic;">n</span><span class="mi" id="MathJax-Span-65" 
style="font-family: MathJax_Math-italic;">x</span><span class="mo" id="MathJax-Span-66" style="font-family: 
MathJax_Main; padding-left: 0.202em;">−</span><span class="mi" id="MathJax-Span-67" style="font-family: 
MathJax_Math-italic; padding-left: 0.202em;">t</span><span class="mi" id="MathJax-Span-68" 
style="font-family: MathJax_Math-italic;">p</span><span class="mo" id="MathJax-Span-69" style="font-family: 
MathJax_Main; padding-left: 0.302em;">:</span><span class="mn" id="MathJax-Span-70" style="font-family: 
MathJax_Main; padding-left: 0.302em;">3</span></span><span style="display: inline-block; width: 
0px; height: 2.353em;"></span></span></span><span style="display: inline-block; overflow: hidden; 
vertical-align: -0.372em; border-left: 0px solid; width: 0px; height: 1.378em;"></span></span> 
</nobr><span class="MJX_Assistive_MathML" role="presentation"> <math xmlns="http://www.w3.org/1998/Math/MathML"> 
<mi> d </mi><mi> o </mi><mi> c </mi><mi> k </mi><mi> e </mi><mi> r </mi><mi> r </mi><mi> u 
</mi><mi> n </mi><mo> − </mo><mo> − </mo><mi> n </mi><mi> a </mi><mi> m </mi><mi> e </mi><mi> 
n </mi><mi> g </mi><mi> i </mi><mi> n </mi><mi> x </mi><mo> − </mo><mo> − </mo><mi> n </mi><mi> 
e </mi><mi> t </mi><mi> w </mi><mi> o </mi><mi> r </mi><mi> k </mi><mi> h </mi><mi> o </mi><mi> 
s </mi><mi> t </mi><mo> − </mo><mo> − </mo><mi> p </mi><mi> r </mi><mi> i </mi><mi> v </mi><mi> 
i </mi><mi> l </mi><mi> e </mi><mi> g </mi><mi> e </mi><mi> d </mi><mo> − </mo><mi> i </mi><mi> 
t </mi><mi> d </mi><mi> f </mi><mi> e </mi><mi> i </mi><mi> s </mi><mi> k </mi><mi> y </mi><mrow 
class="MJX-TeXAtom-ORD"> <mo> / </mo> </mrow><mi> n </mi><mi> g </mi><mi> i </mi><mi> n </mi><mi> 
x </mi><mo> − </mo><mi> t </mi><mi> p </mi><mo> : </mo><mn> 3 </mn> </math></span></span> <script 
type="math/tex" id="MathJax-Element-1"></script> docker run --name phpfpm --network host --privileged 
-itd feisky/php-fpm-tp:3 <br>这2个的配置能上传一下到github吗？我自己依照优化步骤修改的参数，放到镜像里去跑，压测后Requests/sec只能达到： 
1919，而是用老师的tag=3的镜像，压测后得到Requests/sec是3107。我把我已知的参数都对比了一遍，如下： <br>sysctl net.ipv4.ip_local_port_range=''10000 
65535'' <br>sysctl net.ipv4.tcp_tw_reuse=1 <br>sysctl net.ipv4.tcp_fin_timeout=3 <br>sysctl 
net.ipv4.tcp_max_syn_backlog=8192 <br>sysctl net.netfilter.nf_conntrack_max=1048576 <br>sysctl 
net.core.somaxconn=65536 <br>还有nginx、php的backlog=8192，php的max_children=40(我给了40，不是老师的20)。 <br>发现都是一样的。不知道哪里有问题。 
<br>老师，你能把优化最后的配置文件上传一份到github吗？ </div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> 
</div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 优化后的配置没有上传到github里面，不过你可以docker 
exec到容器内部查看</p> </div> </div></li> <li class="reJj6Thl_0"><img src="" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>腾达</span> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2019-04-01 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> 有3个问题： <br>1.第一次运行 docker run --name nginx --network 
host --privileged -itd feisky/nginx-tp这个命令，我参考的是对应的github.com/linux-perf-examples/nginx-throughput/ 
下的一些文件知道了参数配置，问题：nginx里的init.sh运行的时候，sysctl修改的网络参数是作用在docker内的nginx？还是作用在宿主ubuntu上？ <br>2.文章里查看、修改网络参数，并未提示说要进docker容器内部去修改，这个是在宿主ubuntu上做的修改吗？比如说到 
sysctl -w net.netfilter.nf_conntrack_max=1048576 这个，是直接在宿主ubuntu上修改的吗？ <br>3.从docker运行后续集个tag=2，3的镜像开始，例如：docker 
run --name nginx --network host --privileged -itd feisky/nginx-tp:3 这个命令拉的镜像的参数修改了哪些地方？从哪里可以看到这些参数？ 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 1，2: 实际上修改的是Host的<br>3: 文章中有讲到，每个镜像使用之前的分析就是修改的内容</p> </div> </div></li> 
<li class="reJj6Thl_0"><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/8OPzdpDraQMvCNWAicicDt54sDaIYJZicBLfMyibXVs4V0ZibEdkZlbzxxL7aGpRoeyvibag5LaAaaGKSdwYQMY2hUrQ/132" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>code2</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-28 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> 用桌面linux分析服务器性能，有些勉强。 </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 
桌面Linux和服务器都适用的</p> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/13/57/6e/dd0eee5f.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>夜空中最亮...</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-26 </div> </div> <div 
class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> 
</div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0"> 报个到 </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <!----> </div></li> <li class="reJj6Thl_0"><img 
src="https://static001.geekbang.org/account/avatar/00/10/93/43/0e84492d.jpg" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>Maxwell</span> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-26 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> Sar测试的只是网络的发送和接收数据吧，好像并不能发现网络的瓶颈导致压测请求无法发送至服务器端？ 
</div> <!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: sar可以查看很多网络统计数据，可以看看-n选项的文档 
</p> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/10/93/43/0e84492d.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>Maxwell</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-26 </div> </div> <div 
class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> 
</div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 这个火焰图咋分析？我这边和你的好像不太一样，系统我也是ubantu18.04 
<br> </div> <!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 火焰图的介绍在49篇，你可以照着分析下看看</p> 
</div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/10/93/43/0e84492d.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>Maxwell</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-26 </div> </div> <div 
class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> 
</div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0"> 运行最后一次docker镜像，wrk测试结果中还是有很多error(read 
),请问这个error指的是什么错误呢？ <br>Running 10s test @ http://192.168.32.145 <br>&nbsp;&nbsp;2 threads 
and 1000 connections <br>&nbsp;&nbsp;Thread Stats Avg Stdev Max +/- Stdev <br>&nbsp;&nbsp;&nbsp;&nbsp;Latency 
97.36ms 22.29ms 394.39ms 90.57% <br>&nbsp;&nbsp;&nbsp;&nbsp;Req/Sec 5.01k 1.00k 7.01k 75.00% 
<br>&nbsp;&nbsp;Latency Distribution <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;50% 91.10ms <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;75% 
100.83ms <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;90% 117.53ms <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;99% 
195.90ms <br>&nbsp;&nbsp;99832 requests in 10.08s, 20.72MB read <br>&nbsp;&nbsp;Socket errors: 
connect 0, read 11483, write 0, timeout 0 <br>Requests/sec: 9902.41 <br>Transfer/sec: 2.05MB 
<br> </div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div 
class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 看看socket errors这一行，有错误的类型。上面这个结果都是read错误</p> 
</div> </div></li> <li class="reJj6Thl_0"><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKsz8j0bAayjSne9iakvjzUmvUdxWEbsM9iasQ74spGFayIgbSE232sH2LOWmaKtx1WqAFDiaYgVPwIQ/132" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>2xshu</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-26 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> 老师，怎么观察全链接的状况哇？ss -s？ </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 
ss -s 或者 ss -lnt</p> </div> </div></li>', delta=0, field_comment_format='full_html', langcode='zh-hans', 
revision_id=1085 where entity_id=1085 
 {executed in 1 msec}
2020-11-25 10:18:11.110 INFO  jdbc.sqltiming Line:373 - select nodefieldc0_.entity_id as entity_i1_14_0_, nodefieldc0_.bundle as bundle2_14_0_, nodefieldc0_.field_comment_value 
as field_co3_14_0_, nodefieldc0_.delta as delta4_14_0_, nodefieldc0_.field_comment_format as 
field_co5_14_0_, nodefieldc0_.langcode as langcode6_14_0_, nodefieldc0_.revision_id as revision7_14_0_ 
from node_revision__field_comment nodefieldc0_ where nodefieldc0_.entity_id=1085 
 {executed in 0 msec}
2020-11-25 10:18:11.111 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|--------------------|------|---------------------|---------|------------|
|entity_id |bundle |field_comment_value |delta |field_comment_format |langcode |revision_id |
|----------|-------|--------------------|------|---------------------|---------|------------|
|[unread]  |book   |                    |0     |full_html            |zh-hans  |1085        |
|----------|-------|--------------------|------|---------------------|---------|------------|

2020-11-25 10:18:11.113 INFO  jdbc.sqltiming Line:373 - update node_revision__field_comment set bundle='book', field_comment_value='<li class="reJj6Thl_0"><img 
src="https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>我来也</span> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-26 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">4</span> </div> <!----> 
<!----> </div> </div> <div class="_3M6kV3zb_0"> [D52打卡] <br>哈哈,看专栏的同时,也在生产环境中执行下查看套接字的命令. <br>居然还发现了一个高并发时的隐患. 
<br>`ss -ltnp` <br>&nbsp;&nbsp;有些监听端口半链接队列的值偏小,只有32.而有些都是128. <br>&nbsp;&nbsp;赶紧查看程序源码,发现是调用框架的接口时未传递backlog的值,导致使用框架默认的值32. 
<br>&nbsp;&nbsp;哈哈,这个程序是专门处理客户端连接的,虽然目前Recv-Q都为0,但也确实是一个隐患吧. <br>`ss -s` <br>&nbsp;&nbsp;看到的连接数和各状态数还正常. 
<br>`netstat -s | grep -wE "socket|listen"` <br>&nbsp;&nbsp;结果还比较稳定. <br>像 sysctl 相关的配置,由于没有权限,就无缘查看了. 
<br> <br>不得不说,综合案例篇的内容真不错.老师也是够狠,设置了这么多的坑.填了一个一个又一个. <br>1.内核连接数限制 nf_conntrack. <br>2.php程序的工作进程数量 
<br>3.半链接队列偏小,导致高并发时的丢包. <br>4.系统分配的临时端口号范围. <br>5.系统的端口复用参数配置. <br> <br>调优过程中,有时甚至是一波未平一波又起,很是惊险刺激. 
<br> <br> </div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> 
<!----> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/14/11/4b/fa64f061.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>xfan</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-28 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> </div> <!----> 
<!----> </div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 内核选项 tcp_tw_reuse，不是直接修改内核参数就好了么，为什么还有修改后的tag:3 
,这里不太清楚 </div> <!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 嗯 也可以的。打包成镜像的是最后优化的结果</p> 
</div> </div></li> <li class="reJj6Thl_0"><img src="https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKCmqW21Zguv8kPiayib4U42B3jLGk2Y4Leia0fQjnU0Lfgic8BwbdMIePiayDadFKzV9kSt3F8jRicZxxA/132" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>泡泡</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-26 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> </div> <!----> 
<!----> </div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> wrk命令-c参数用来模拟连接数为1000， <br>为什么输出中的连接数有1910，不理解 
</div> <!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: -c是并发数，输出中是每秒请求数，不是一回事</p> 
</div> </div></li> <li class="reJj6Thl_0"><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKsz8j0bAayjSne9iakvjzUmvUdxWEbsM9iasQ74spGFayIgbSE232sH2LOWmaKtx1WqAFDiaYgVPwIQ/132" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>2xshu</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-25 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> </div> <!----> 
<!----> </div> </div> <div class="_3M6kV3zb_0"> 老师，有个疑问。 <br>套接字优化部分，你用ss -s输出的两个队列，根据“关于 Linux 
网络，你必须知道这些（下）”你讲的内容，当链接处于listening状态是，Send-Q和Recv-Q都是半链接队列，但是你这里却都是调的全连接队列啊？不是应该调整tcp_max_syn_backlog吗？ 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 嗯，谢谢指出，是文中的步骤不严谨了。实际上应该再加上两步<br><br>1. 查看调优 tcp_max_syn_backlog<br>2. 
观察全连接的状况之后再调优全连接队列</p> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/10/93/43/0e84492d.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>Maxwell</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-25 </div> </div> <div 
class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> 
</div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0"> 在公司局域网下做性能测试，如何判断网络会不会成为压测的瓶颈呢？也就是说如果开了500线程进行压测，会不会因为网络瓶颈，导致请求无法发送到服务器端？ 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 可以在测试的时候同时观察一下网络吞吐和丢包（比如使用sar）</p> </div> </div></li> <li class="reJj6Thl_0"><img 
src="https://static001.geekbang.org/account/avatar/00/0f/62/81/ad80f427.jpg" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>Lane</span> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-25 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> </div> <!----> 
<!----> </div> </div> <div class="_3M6kV3zb_0"> 一天看2篇，终于追上进度了 </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <!----> </div></li> <li class="reJj6Thl_0"><img 
src="https://wx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEKQMM4m7NHuicr55aRiblTSEWIYe0QqbpyHweaoAbG7j2v7UUElqqeP3Ihrm3UfDPDRb1Hv8LvPwXqA/132" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>ninuxer</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-25 </div> </div> <div 
class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> 
</div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 打卡day55 <br>缺乏由现象联想到可能原因的系统性思维～ 
</div> <!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 还是需要加强原理的理解</p> </div> 
</div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/12/c0/ce/fc41ad5e.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>陳先森</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-05-06 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> 打下卡。 </div> <div class="_2r3UB1GX_0"> <span>展开</span><i 
class="iconfont"></i> </div> <!----> </div></li> <li class="reJj6Thl_0"><img src="" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>如果</span> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2019-04-22 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> DAY52，打卡 <br> </div> <div class="_2r3UB1GX_0"> <span>展开</span><i 
class="iconfont"></i> </div> <!----> </div></li> <li class="reJj6Thl_0"><img src="" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>腾达</span> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2019-04-15 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> net.ipv4.tcp_tw_reuse = 1 这里是影响到socket的客户端（nginx作为一个客户端连接php的服务端）的行为吗？ 
不是影响到服务端的time_wait数量？ 我弄了个tomcat，用ab压测，tw_use=1, 用ss -s看time_wait 还很高啊，1万多。 </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 
嗯 用在客户端上</p> </div> </div></li> <li class="reJj6Thl_0"><img src="" class="_2273kGdT_0"> <div 
class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>腾达</span> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2019-04-12 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> 是的，都对比过了，还包括php的配置，都对比过了 </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <!----> </div></li> <li class="reJj6Thl_0"><img 
src="" class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div 
class="_18Dng5rT_0"> <span>腾达</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-04-08 </div> 
</div> <div class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span 
class=""></span> </div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 
老师，针对我提的问题，您的回复是：“不过你可以docker exec到容器内部查看”，我已经逐一对比过容器内的、我已知的参数了。未发现不同。您能否把最后一次的配置参数上传一下到github？ 
</div> <!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 包括内核选项和Nginx配置吗？</p> 
</div> </div></li> <li class="reJj6Thl_0"><img src="" class="_2273kGdT_0"> <div class="_2CG0SquK_0"> 
<div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>腾达</span> <!----> </div> <div 
class="_1H1Z49Dr_0"> 2019-04-05 </div> </div> <div class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> 
<i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> </div> </div> <div 
class="_3M6kV3zb_0"> 有2个问题： <br>1、在做perf，制作火焰图的部分，我自己本地看到的函数热点是类似：inet_sendmsg, tcp_write_xmit, 
e1000_xmit_frame 之类的，后续再对内核参数net.ipv4.tcp_tw_reuse做设置为1的处理后，函数热点依然是这几个。似乎我的机器上的热点是在发送数据，而不是在端口重用？ 
<br>2、老师最后1个步骤的镜像，即： <br><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span 
class="MathJax" id="MathJax-Element-1-Frame" tabindex="0" style="position: relative;" data-mathml="<math 
xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>d</mi><mi>o</mi><mi>c</mi><mi>k</mi><mi>e</mi><mi>r</mi><mi>r</mi><mi>u</mi><mi>n</mi><mo>−</mo><mo>−</mo><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>i</mi><mi>n</mi><mi>x</mi><mo>−</mo><mo>−</mo><mi>n</mi><mi>e</mi><mi>t</mi><mi>w</mi><mi>o</mi><mi>r</mi><mi>k</mi><mi>h</mi><mi>o</mi><mi>s</mi><mi>t</mi><mo>−</mo><mo>−</mo><mi>p</mi><mi>r</mi><mi>i</mi><mi>v</mi><mi>i</mi><mi>l</mi><mi>e</mi><mi>g</mi><mi>e</mi><mi>d</mi><mo>−</mo><mi>i</mi><mi>t</mi><mi>d</mi><mi>f</mi><mi>e</mi><mi>i</mi><mi>s</mi><mi>k</mi><mi>y</mi><mrow 
class=&quot;MJX-TeXAtom-ORD&quot;><mo>/</mo></mrow><mi>n</mi><mi>g</mi><mi>i</mi><mi>n</mi><mi>x</mi><mo>−</mo><mi>t</mi><mi>p</mi><mo>:</mo><mn>3</mn></math>" 
role="presentation"> <nobr aria-hidden="true"> <span class="math" id="MathJax-Span-1" style="width: 
46.352em; display: inline-block;"><span style="display: inline-block; position: relative; width: 
37.052em; height: 0px; font-size: 125%;"><span style="position: absolute; clip: rect(1.453em, 
1037em, 2.752em, -999.998em); top: -2.348em; left: 0em;"><span class="mrow" id="MathJax-Span-2"><span 
class="mi" id="MathJax-Span-3" style="font-family: MathJax_Math-italic;">d<span style="display: 
inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mi" 
id="MathJax-Span-4" style="font-family: MathJax_Math-italic;">o</span><span class="mi" id="MathJax-Span-5" 
style="font-family: MathJax_Math-italic;">c</span><span class="mi" id="MathJax-Span-6" style="font-family: 
MathJax_Math-italic;">k</span><span class="mi" id="MathJax-Span-7" style="font-family: MathJax_Math-italic;">e</span><span 
class="mi" id="MathJax-Span-8" style="font-family: MathJax_Math-italic;">r</span><span class="mi" 
id="MathJax-Span-9" style="font-family: MathJax_Math-italic;">r</span><span class="mi" id="MathJax-Span-10" 
style="font-family: MathJax_Math-italic;">u</span><span class="mi" id="MathJax-Span-11" style="font-family: 
MathJax_Math-italic;">n</span><span class="mo" id="MathJax-Span-12" style="font-family: MathJax_Main; 
padding-left: 0.202em;">−</span><span class="mo" id="MathJax-Span-13" style="font-family: MathJax_Main; 
padding-left: 0.202em;">−</span><span class="mi" id="MathJax-Span-14" style="font-family: MathJax_Math-italic;">n</span><span 
class="mi" id="MathJax-Span-15" style="font-family: MathJax_Math-italic;">a</span><span class="mi" 
id="MathJax-Span-16" style="font-family: MathJax_Math-italic;">m</span><span class="mi" id="MathJax-Span-17" 
style="font-family: MathJax_Math-italic;">e</span><span class="mi" id="MathJax-Span-18" style="font-family: 
MathJax_Math-italic;">n</span><span class="mi" id="MathJax-Span-19" style="font-family: MathJax_Math-italic;">g<span 
style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span 
class="mi" id="MathJax-Span-20" style="font-family: MathJax_Math-italic;">i</span><span class="mi" 
id="MathJax-Span-21" style="font-family: MathJax_Math-italic;">n</span><span class="mi" id="MathJax-Span-22" 
style="font-family: MathJax_Math-italic;">x</span><span class="mo" id="MathJax-Span-23" style="font-family: 
MathJax_Main; padding-left: 0.202em;">−</span><span class="mo" id="MathJax-Span-24" style="font-family: 
MathJax_Main; padding-left: 0.202em;">−</span><span class="mi" id="MathJax-Span-25" style="font-family: 
MathJax_Math-italic;">n</span><span class="mi" id="MathJax-Span-26" style="font-family: MathJax_Math-italic;">e</span><span 
class="mi" id="MathJax-Span-27" style="font-family: MathJax_Math-italic;">t</span><span class="mi" 
id="MathJax-Span-28" style="font-family: MathJax_Math-italic;">w</span><span class="mi" id="MathJax-Span-29" 
style="font-family: MathJax_Math-italic;">o</span><span class="mi" id="MathJax-Span-30" style="font-family: 
MathJax_Math-italic;">r</span><span class="mi" id="MathJax-Span-31" style="font-family: MathJax_Math-italic;">k</span><span 
class="mi" id="MathJax-Span-32" style="font-family: MathJax_Math-italic;">h</span><span class="mi" 
id="MathJax-Span-33" style="font-family: MathJax_Math-italic;">o</span><span class="mi" id="MathJax-Span-34" 
style="font-family: MathJax_Math-italic;">s</span><span class="mi" id="MathJax-Span-35" style="font-family: 
MathJax_Math-italic;">t</span><span class="mo" id="MathJax-Span-36" style="font-family: MathJax_Main; 
padding-left: 0.202em;">−</span><span class="mo" id="MathJax-Span-37" style="font-family: MathJax_Main; 
padding-left: 0.202em;">−</span><span class="mi" id="MathJax-Span-38" style="font-family: MathJax_Math-italic;">p</span><span 
class="mi" id="MathJax-Span-39" style="font-family: MathJax_Math-italic;">r</span><span class="mi" 
id="MathJax-Span-40" style="font-family: MathJax_Math-italic;">i</span><span class="mi" id="MathJax-Span-41" 
style="font-family: MathJax_Math-italic;">v</span><span class="mi" id="MathJax-Span-42" style="font-family: 
MathJax_Math-italic;">i</span><span class="mi" id="MathJax-Span-43" style="font-family: MathJax_Math-italic;">l</span><span 
class="mi" id="MathJax-Span-44" style="font-family: MathJax_Math-italic;">e</span><span class="mi" 
id="MathJax-Span-45" style="font-family: MathJax_Math-italic;">g<span style="display: inline-block; 
overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mi" id="MathJax-Span-46" 
style="font-family: MathJax_Math-italic;">e</span><span class="mi" id="MathJax-Span-47" style="font-family: 
MathJax_Math-italic;">d<span style="display: inline-block; overflow: hidden; height: 1px; width: 
0.003em;"></span></span><span class="mo" id="MathJax-Span-48" style="font-family: MathJax_Main; 
padding-left: 0.202em;">−</span><span class="mi" id="MathJax-Span-49" style="font-family: MathJax_Math-italic; 
padding-left: 0.202em;">i</span><span class="mi" id="MathJax-Span-50" style="font-family: MathJax_Math-italic;">t</span><span 
class="mi" id="MathJax-Span-51" style="font-family: MathJax_Math-italic;">d<span style="display: 
inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mi" 
id="MathJax-Span-52" style="font-family: MathJax_Math-italic;">f<span style="display: inline-block; 
overflow: hidden; height: 1px; width: 0.053em;"></span></span><span class="mi" id="MathJax-Span-53" 
style="font-family: MathJax_Math-italic;">e</span><span class="mi" id="MathJax-Span-54" style="font-family: 
MathJax_Math-italic;">i</span><span class="mi" id="MathJax-Span-55" style="font-family: MathJax_Math-italic;">s</span><span 
class="mi" id="MathJax-Span-56" style="font-family: MathJax_Math-italic;">k</span><span class="mi" 
id="MathJax-Span-57" style="font-family: MathJax_Math-italic;">y<span style="display: inline-block; 
overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="texatom" id="MathJax-Span-58"><span 
class="mrow" id="MathJax-Span-59"><span class="mo" id="MathJax-Span-60" style="font-family: 
MathJax_Main;">/</span></span></span><span class="mi" id="MathJax-Span-61" style="font-family: 
MathJax_Math-italic;">n</span><span class="mi" id="MathJax-Span-62" style="font-family: MathJax_Math-italic;">g<span 
style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span 
class="mi" id="MathJax-Span-63" style="font-family: MathJax_Math-italic;">i</span><span class="mi" 
id="MathJax-Span-64" style="font-family: MathJax_Math-italic;">n</span><span class="mi" id="MathJax-Span-65" 
style="font-family: MathJax_Math-italic;">x</span><span class="mo" id="MathJax-Span-66" style="font-family: 
MathJax_Main; padding-left: 0.202em;">−</span><span class="mi" id="MathJax-Span-67" style="font-family: 
MathJax_Math-italic; padding-left: 0.202em;">t</span><span class="mi" id="MathJax-Span-68" 
style="font-family: MathJax_Math-italic;">p</span><span class="mo" id="MathJax-Span-69" style="font-family: 
MathJax_Main; padding-left: 0.302em;">:</span><span class="mn" id="MathJax-Span-70" style="font-family: 
MathJax_Main; padding-left: 0.302em;">3</span></span><span style="display: inline-block; width: 
0px; height: 2.353em;"></span></span></span><span style="display: inline-block; overflow: hidden; 
vertical-align: -0.372em; border-left: 0px solid; width: 0px; height: 1.378em;"></span></span> 
</nobr><span class="MJX_Assistive_MathML" role="presentation"> <math xmlns="http://www.w3.org/1998/Math/MathML"> 
<mi> d </mi><mi> o </mi><mi> c </mi><mi> k </mi><mi> e </mi><mi> r </mi><mi> r </mi><mi> u 
</mi><mi> n </mi><mo> − </mo><mo> − </mo><mi> n </mi><mi> a </mi><mi> m </mi><mi> e </mi><mi> 
n </mi><mi> g </mi><mi> i </mi><mi> n </mi><mi> x </mi><mo> − </mo><mo> − </mo><mi> n </mi><mi> 
e </mi><mi> t </mi><mi> w </mi><mi> o </mi><mi> r </mi><mi> k </mi><mi> h </mi><mi> o </mi><mi> 
s </mi><mi> t </mi><mo> − </mo><mo> − </mo><mi> p </mi><mi> r </mi><mi> i </mi><mi> v </mi><mi> 
i </mi><mi> l </mi><mi> e </mi><mi> g </mi><mi> e </mi><mi> d </mi><mo> − </mo><mi> i </mi><mi> 
t </mi><mi> d </mi><mi> f </mi><mi> e </mi><mi> i </mi><mi> s </mi><mi> k </mi><mi> y </mi><mrow 
class="MJX-TeXAtom-ORD"> <mo> / </mo> </mrow><mi> n </mi><mi> g </mi><mi> i </mi><mi> n </mi><mi> 
x </mi><mo> − </mo><mi> t </mi><mi> p </mi><mo> : </mo><mn> 3 </mn> </math></span></span> <script 
type="math/tex" id="MathJax-Element-1"></script> docker run --name phpfpm --network host --privileged 
-itd feisky/php-fpm-tp:3 <br>这2个的配置能上传一下到github吗？我自己依照优化步骤修改的参数，放到镜像里去跑，压测后Requests/sec只能达到： 
1919，而是用老师的tag=3的镜像，压测后得到Requests/sec是3107。我把我已知的参数都对比了一遍，如下： <br>sysctl net.ipv4.ip_local_port_range=''10000 
65535'' <br>sysctl net.ipv4.tcp_tw_reuse=1 <br>sysctl net.ipv4.tcp_fin_timeout=3 <br>sysctl 
net.ipv4.tcp_max_syn_backlog=8192 <br>sysctl net.netfilter.nf_conntrack_max=1048576 <br>sysctl 
net.core.somaxconn=65536 <br>还有nginx、php的backlog=8192，php的max_children=40(我给了40，不是老师的20)。 <br>发现都是一样的。不知道哪里有问题。 
<br>老师，你能把优化最后的配置文件上传一份到github吗？ </div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> 
</div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 优化后的配置没有上传到github里面，不过你可以docker 
exec到容器内部查看</p> </div> </div></li> <li class="reJj6Thl_0"><img src="" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>腾达</span> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2019-04-01 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> 有3个问题： <br>1.第一次运行 docker run --name nginx --network 
host --privileged -itd feisky/nginx-tp这个命令，我参考的是对应的github.com/linux-perf-examples/nginx-throughput/ 
下的一些文件知道了参数配置，问题：nginx里的init.sh运行的时候，sysctl修改的网络参数是作用在docker内的nginx？还是作用在宿主ubuntu上？ <br>2.文章里查看、修改网络参数，并未提示说要进docker容器内部去修改，这个是在宿主ubuntu上做的修改吗？比如说到 
sysctl -w net.netfilter.nf_conntrack_max=1048576 这个，是直接在宿主ubuntu上修改的吗？ <br>3.从docker运行后续集个tag=2，3的镜像开始，例如：docker 
run --name nginx --network host --privileged -itd feisky/nginx-tp:3 这个命令拉的镜像的参数修改了哪些地方？从哪里可以看到这些参数？ 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 1，2: 实际上修改的是Host的<br>3: 文章中有讲到，每个镜像使用之前的分析就是修改的内容</p> </div> </div></li> 
<li class="reJj6Thl_0"><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/8OPzdpDraQMvCNWAicicDt54sDaIYJZicBLfMyibXVs4V0ZibEdkZlbzxxL7aGpRoeyvibag5LaAaaGKSdwYQMY2hUrQ/132" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>code2</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-28 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> 用桌面linux分析服务器性能，有些勉强。 </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 
桌面Linux和服务器都适用的</p> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/13/57/6e/dd0eee5f.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>夜空中最亮...</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-26 </div> </div> <div 
class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> 
</div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0"> 报个到 </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <!----> </div></li> <li class="reJj6Thl_0"><img 
src="https://static001.geekbang.org/account/avatar/00/10/93/43/0e84492d.jpg" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>Maxwell</span> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-26 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> Sar测试的只是网络的发送和接收数据吧，好像并不能发现网络的瓶颈导致压测请求无法发送至服务器端？ 
</div> <!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: sar可以查看很多网络统计数据，可以看看-n选项的文档 
</p> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/10/93/43/0e84492d.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>Maxwell</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-26 </div> </div> <div 
class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> 
</div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 这个火焰图咋分析？我这边和你的好像不太一样，系统我也是ubantu18.04 
<br> </div> <!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 火焰图的介绍在49篇，你可以照着分析下看看</p> 
</div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/10/93/43/0e84492d.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>Maxwell</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-26 </div> </div> <div 
class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> 
</div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0"> 运行最后一次docker镜像，wrk测试结果中还是有很多error(read 
),请问这个error指的是什么错误呢？ <br>Running 10s test @ http://192.168.32.145 <br>&nbsp;&nbsp;2 threads 
and 1000 connections <br>&nbsp;&nbsp;Thread Stats Avg Stdev Max +/- Stdev <br>&nbsp;&nbsp;&nbsp;&nbsp;Latency 
97.36ms 22.29ms 394.39ms 90.57% <br>&nbsp;&nbsp;&nbsp;&nbsp;Req/Sec 5.01k 1.00k 7.01k 75.00% 
<br>&nbsp;&nbsp;Latency Distribution <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;50% 91.10ms <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;75% 
100.83ms <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;90% 117.53ms <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;99% 
195.90ms <br>&nbsp;&nbsp;99832 requests in 10.08s, 20.72MB read <br>&nbsp;&nbsp;Socket errors: 
connect 0, read 11483, write 0, timeout 0 <br>Requests/sec: 9902.41 <br>Transfer/sec: 2.05MB 
<br> </div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div 
class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 看看socket errors这一行，有错误的类型。上面这个结果都是read错误</p> 
</div> </div></li> <li class="reJj6Thl_0"><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKsz8j0bAayjSne9iakvjzUmvUdxWEbsM9iasQ74spGFayIgbSE232sH2LOWmaKtx1WqAFDiaYgVPwIQ/132" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>2xshu</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-26 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> 老师，怎么观察全链接的状况哇？ss -s？ </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 
ss -s 或者 ss -lnt</p> </div> </div></li>', delta=0, field_comment_format='full_html', langcode='zh-hans', 
revision_id=1085 where entity_id=1085 
 {executed in 1 msec}
2020-11-25 10:18:11.117 INFO  jdbc.sqltiming Line:373 - select bookfieldt0_.entity_id as entity_i1_9_, bookfieldt0_.bundle as bundle2_9_, bookfieldt0_.delta 
as delta3_9_, bookfieldt0_.langcode as langcode4_9_, bookfieldt0_.revision_id as revision5_9_, 
bookfieldt0_.field_thumb_value as field_th6_9_ from node__field_thumb bookfieldt0_ where bookfieldt0_.entity_id=1085 
 {executed in 0 msec}
2020-11-25 10:18:11.118 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------|------------------|
|entity_id |bundle |delta |langcode |revision_id |field_thumb_value |
|----------|-------|------|---------|------------|------------------|
|1085      |book   |0     |zh-hans  |1085        |                  |
|----------|-------|------|---------|------------|------------------|

2020-11-25 10:18:11.119 INFO  jdbc.sqltiming Line:373 - update node__field_thumb set bundle='book', delta=0, langcode='zh-hans', revision_id=1085, 
field_thumb_value='https://static001.geekbang.org/resource/image/6a/28/6a8cdfbab570dc5313f3e45199504228.jpg' 
where entity_id=1085 
 {executed in 0 msec}
2020-11-25 10:18:11.123 INFO  jdbc.sqltiming Line:373 - select nodefieldt0_.entity_id as entity_i1_18_0_, nodefieldt0_.bundle as bundle2_18_0_, nodefieldt0_.delta 
as delta3_18_0_, nodefieldt0_.langcode as langcode4_18_0_, nodefieldt0_.revision_id as revision5_18_0_, 
nodefieldt0_.field_thumb_value as field_th6_18_0_ from node_revision__field_thumb nodefieldt0_ 
where nodefieldt0_.entity_id=1085 
 {executed in 0 msec}
2020-11-25 10:18:11.124 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------|------------------|
|entity_id |bundle |delta |langcode |revision_id |field_thumb_value |
|----------|-------|------|---------|------------|------------------|
|[unread]  |book   |0     |zh-hans  |1085        |                  |
|----------|-------|------|---------|------------|------------------|

2020-11-25 10:18:11.125 INFO  jdbc.sqltiming Line:373 - update node_revision__field_thumb set bundle='book', delta=0, langcode='zh-hans', revision_id=1085, 
field_thumb_value='https://static001.geekbang.org/resource/image/6a/28/6a8cdfbab570dc5313f3e45199504228.jpg' 
where entity_id=1085 
 {executed in 0 msec}
2020-11-25 10:18:11.128 INFO  jdbc.sqltiming Line:373 - select bookfieldf0_.entity_id as entity_i1_6_0_, bookfieldf0_.bundle as bundle2_6_0_, bookfieldf0_.delta 
as delta3_6_0_, bookfieldf0_.field_fenlei_target_id as field_fe4_6_0_, bookfieldf0_.langcode 
as langcode5_6_0_, bookfieldf0_.revision_id as revision6_6_0_ from node__field_fenlei bookfieldf0_ 
where bookfieldf0_.entity_id=1085 
 {executed in 0 msec}
2020-11-25 10:18:11.129 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|-----------------------|---------|------------|
|entity_id |bundle |delta |field_fenlei_target_id |langcode |revision_id |
|----------|-------|------|-----------------------|---------|------------|
|[unread]  |book   |0     |1                      |zh-hans  |1085        |
|----------|-------|------|-----------------------|---------|------------|

2020-11-25 10:18:11.131 INFO  jdbc.sqltiming Line:373 - select nodefieldf0_.entity_id as entity_i1_15_0_, nodefieldf0_.bundle as bundle2_15_0_, nodefieldf0_.delta 
as delta3_15_0_, nodefieldf0_.field_fenlei_target_id as field_fe4_15_0_, nodefieldf0_.langcode 
as langcode5_15_0_, nodefieldf0_.revision_id as revision6_15_0_ from node_revision__field_fenlei 
nodefieldf0_ where nodefieldf0_.entity_id=1085 
 {executed in 1 msec}
2020-11-25 10:18:11.131 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|-----------------------|---------|------------|
|entity_id |bundle |delta |field_fenlei_target_id |langcode |revision_id |
|----------|-------|------|-----------------------|---------|------------|
|[unread]  |book   |0     |1                      |zh-hans  |1085        |
|----------|-------|------|-----------------------|---------|------------|

2020-11-25 10:18:11.133 INFO  jdbc.sqltiming Line:373 - select bookchecke0_.item_id as item_id1_2_, bookchecke0_.fsid as fsid2_2_, bookchecke0_.got 
as got3_2_, bookchecke0_.name as name4_2_, bookchecke0_.parse_fail as parse_fa5_2_, bookchecke0_.parsed 
as parsed6_2_, bookchecke0_.path as path7_2_, bookchecke0_.title as title8_2_, bookchecke0_.vid 
as vid9_2_ from book_check bookchecke0_ where bookchecke0_.fsid='367702398401832' and bookchecke0_.name='net_content' 
 {executed in 1 msec}
2020-11-25 10:18:11.133 INFO  jdbc.resultsettable Line:610 - 
|--------|---------|---------|---------|-----------|---------|---------|---------|---------|
|item_id |fsid     |got      |name     |parse_fail |parsed   |path     |title    |vid      |
|--------|---------|---------|---------|-----------|---------|---------|---------|---------|
|1086    |[unread] |[unread] |[unread] |[unread]   |[unread] |[unread] |[unread] |[unread] |
|--------|---------|---------|---------|-----------|---------|---------|---------|---------|

2020-11-25 10:19:19.322 INFO  jdbc.sqltiming Line:373 - update book_check set fsid='367702398401832', got=1, name='net_content', parse_fail='', parsed=1, 
path='12-Linux性能优化实战/06-综合实战篇 (13讲)/53丨套路篇：系统监控的综合思路.html', title='53丨套路篇：系统监控的综合思路', vid=1086 
where item_id=1086 
 {executed in 1 msec}
2020-11-25 10:19:19.329 INFO  jdbc.sqltiming Line:373 - select nodebodyen0_.entity_id as entity_i1_4_, nodebodyen0_.body_value as body_val2_4_, nodebodyen0_.body_summary 
as body_sum3_4_, nodebodyen0_.bundle as bundle4_4_, nodebodyen0_.delta as delta5_4_, nodebodyen0_.body_format 
as body_for6_4_, nodebodyen0_.langcode as langcode7_4_, nodebodyen0_.revision_id as revision8_4_ 
from node__body nodebodyen0_ where nodebodyen0_.entity_id=1086 
 {executed in 0 msec}
2020-11-25 10:19:19.330 INFO  jdbc.resultsettable Line:610 - 
|----------|-----------|-------------|-------|------|------------|---------|------------|
|entity_id |body_value |body_summary |bundle |delta |body_format |langcode |revision_id |
|----------|-----------|-------------|-------|------|------------|---------|------------|
|1086      |           |             |book   |0     |full_html   |zh-hans  |1086        |
|----------|-----------|-------------|-------|------|------------|---------|------------|

2020-11-25 10:19:19.330 INFO  jdbc.sqltiming Line:373 - select nodebodyre0_.entity_id as entity_i1_13_0_, nodebodyre0_.body_value as body_val2_13_0_, 
nodebodyre0_.body_summary as body_sum3_13_0_, nodebodyre0_.bundle as bundle4_13_0_, nodebodyre0_.delta 
as delta5_13_0_, nodebodyre0_.body_format as body_for6_13_0_, nodebodyre0_.langcode as langcode7_13_0_, 
nodebodyre0_.revision_id as revision8_13_0_ from node_revision__body nodebodyre0_ where nodebodyre0_.entity_id=1086 
 {executed in 0 msec}
2020-11-25 10:19:19.331 INFO  jdbc.resultsettable Line:610 - 
|----------|-----------|-------------|-------|------|------------|---------|------------|
|entity_id |body_value |body_summary |bundle |delta |body_format |langcode |revision_id |
|----------|-----------|-------------|-------|------|------------|---------|------------|
|[unread]  |           |             |book   |0     |full_html   |zh-hans  |1086        |
|----------|-----------|-------------|-------|------|------------|---------|------------|

2020-11-25 10:19:19.332 INFO  jdbc.sqltiming Line:373 - update node__body set body_value='<p>你好，我是倪朋飞。</p> <p>在前面的内容中，我为你介绍了很多性能分析的原理、思路以及相关的工具。不过，在实际的性能分析中，一个很常见的现象是，明明发生了性能瓶颈，但当你登录到服务器中想要排查的时候，却发现瓶颈已经消失了。或者说，性能问题总是时不时地发生，但却很难找出发生规律，也很难重现。</p> 
<p>当面对这样的场景时，你可能会发现，我们前面介绍的各种工具、方法都“失效“了。为什么呢？因为它们都需要在性能问题发生的时刻才有效，而在这些事后分析的场景中，我们就很难发挥它们的威力了。</p> 
<p>那该怎么办呢？置之不理吗？其实以往，很多应用都是等到用户抱怨响应慢了，或者系统崩溃了后，才发现系统或者应用程序的性能出现了问题。虽然最终也能发现问题，但显然，这种方法是不可取的，因为严重影响了用户的体验。</p> 
<p>而要解决这个问题，就要搭建监控系统，把系统和应用程序的运行状况监控起来，并定义一系列的策略，在发生问题时第一时间告警通知。一个好的监控系统，不仅可以实时暴露系统的各种问题，更可以根据这些监控到的状态，自动分析和定位大致的瓶颈来源，从而更精确地把问题汇报给相关团队处理。</p> 
<p>要做好监控，最核心的就是全面的、可量化的指标，这包括系统和应用两个方面。</p><!-- [[[read_end]]] --> <p>从系统来说，监控系统要涵盖系统的整体资源使用情况，比如我们前面讲过的 
CPU、内存、磁盘和文件系统、网络等各种系统资源。</p> <p>而从应用程序来说，监控系统要涵盖应用程序内部的运行状态，这既包括进程的 CPU、磁盘 I/O 等整体运行状况，更需要包括诸如接口调用耗时、执行过程中的错误、内部对象的内存使用等应用程序内部的运行状况。</p> 
<p>今天，我就带你一起来看看，如何对 Linux 系统进行监控。而在下一节，我将继续为你讲解应用程序监控的思路。</p> <h2>USE 法</h2> <p>在开始监控系统之前，你肯定最想知道，怎么才能用简洁的方法，来描述系统资源的使用情况。你当然可以使用专栏中学到的各种性能工具，来分别收集各种资源的使用情况。不过不要忘记，每种资源的性能指标可都有很多，使用过多指标本身耗时耗力不说，也不容易为你建立起系统整体的运行状况。</p> 
<p>在这里，我为你介绍一种专门用于性能监控的 USE（Utilization Saturation and Errors）法。USE 法把系统资源的性能指标，简化成了三个类别，即使用率、饱和度以及错误数。</p> 
<ul> <li> <p>使用率，表示资源用于服务的时间或容量百分比。100% 的使用率，表示容量已经用尽或者全部时间都用于服务。</p> </li> <li> <p>饱和度，表示资源的繁忙程度，通常与等待队列的长度相关。100% 
的饱和度，表示资源无法接受更多的请求。</p> </li> <li> <p>错误数表示发生错误的事件个数。错误数越多，表明系统的问题越严重。</p> </li> </ul> <p>这三个类别的指标，涵盖了系统资源的常见性能瓶颈，所以常被用来快速定位系统资源的性能瓶颈。这样，无论是对 
CPU、内存、磁盘和文件系统、网络等硬件资源，还是对文件描述符数、连接数、连接跟踪数等软件资源，USE 方法都可以帮你快速定位出，是哪一种系统资源出现了性能瓶颈。</p> <p>那么，对于每一种系统资源，又有哪些常见的性能指标呢？回忆一下我们讲过的各种系统资源原理，并不难想到相关的性能指标。这里，我把常见的性能指标画了一张表格，方便你在需要时查看。</p> 
<p><img src="https://static001.geekbang.org/resource/image/cc/ee/ccd7a9350c270c0168bad6cc8d0b8aee.png" 
alt=""></p> <p>不过，需要注意的是，USE 方法只关注能体现系统资源性能瓶颈的核心指标，但这并不是说其他指标不重要。诸如系统日志、进程资源使用量、缓存使用量等其他各类指标，也都需要我们监控起来。只不过，它们通常用作辅助性能分析，而 
USE 方法的指标，则直接表明了系统的资源瓶颈。</p> <h2>监控系统</h2> <p>掌握 USE 方法以及需要监控的性能指标后，接下来要做的，就是建立监控系统，把这些指标保存下来；然后，根据这些监控到的状态，自动分析和定位大致的瓶颈来源；最后，再通过告警系统，把问题及时汇报给相关团队处理。</p> 
<p>可以看出，一个完整的监控系统通常由数据采集、数据存储、数据查询和处理、告警以及可视化展示等多个模块组成。所以，要从头搭建一个监控系统，其实也是一个很大的系统工程。</p> <p>不过，幸运的是，现在已经有很多开源的监控工具可以直接使用，比如最常见的 
Zabbix、Nagios、Prometheus 等等。</p> <p>下面，我就以 Prometheus 为例，为你介绍这几个组件的基本原理。如下图所示，就是 Prometheus 
的基本架构：</p> <p><img src="https://static001.geekbang.org/resource/image/7f/56/7f9c36db17785097ef9d186fd782ce56.png" 
alt=""></p> <p>（图片来自 <a href="https://prometheus.io/docs/introduction/overview/">prometheus.io</a>）</p> 
<p>先看数据采集模块。最左边的 Prometheus targets 就是数据采集的对象，而 Retrieval 则负责采集这些数据。从图中你也可以看到，Prometheus 同时支持 
Push 和 Pull 两种数据采集模式。</p> <ul> <li> <p>Pull 模式，由服务器端的采集模块来触发采集。只要采集目标提供了 HTTP 接口，就可以自由接入（这也是最常用的采集模式）。</p> 
</li> <li> <p>Push 模式，则是由各个采集目标主动向 Push Gateway（用于防止数据丢失）推送指标，再由服务器端从 Gateway 中拉取过去（这是移动应用中最常用的采集模式）。</p> 
</li> </ul> <p>由于需要监控的对象通常都是动态变化的，Prometheus 还提供了服务发现的机制，可以自动根据预配置的规则，动态发现需要监控的对象。这在 Kubernetes 
等容器平台中非常有效。</p> <p>第二个是数据存储模块。为了保持监控数据的持久化，图中的 TSDB（Time series database）模块，负责将采集到的数据持久化到 SSD 
等磁盘设备中。TSDB 是专门为时间序列数据设计的一种数据库，特点是以时间为索引、数据量大并且以追加的方式写入。</p> <p>第三个是数据查询和处理模块。刚才提到的 TSDB，在存储数据的同时，其实还提供了数据查询和基本的数据处理功能，而这也就是 
PromQL 语言。PromQL 提供了简洁的查询、过滤功能，并且支持基本的数据处理方法，是告警系统和可视化展示的基础。</p> <p>第四个是告警模块。右上角的 AlertManager 
提供了告警的功能，包括基于 PromQL 语言的触发条件、告警规则的配置管理以及告警的发送等。不过，虽然告警是必要的，但过于频繁的告警显然也不可取。所以，AlertManager 还支持通过分组、抑制或者静默等多种方式来聚合同类告警，并减少告警数量。</p> 
<p>最后一个是可视化展示模块。Prometheus 的 web UI 提供了简单的可视化界面，用于执行 PromQL 查询语句，但结果的展示比较单调。不过，一旦配合 Grafana，就可以构建非常强大的图形界面了。</p> 
<p>介绍完了这些组件，想必你对每个模块都有了比较清晰的认识。接下来，我们再来继续深入了解这些组件结合起来的整体功能。</p> <p>比如，以刚才提到的 USE 方法为例，我使用 Prometheus，可以收集 
Linux 服务器的 CPU、内存、磁盘、网络等各类资源的使用率、饱和度和错误数指标。然后，通过 Grafana 以及 PromQL 查询语句，就可以把它们以图形界面的方式直观展示出来。</p> 
<p><img src="https://static001.geekbang.org/resource/image/e5/91/e55600aa21fd6e8d96373f950b2a9991.png" 
alt=""><img src="https://static001.geekbang.org/resource/image/28/86/28410012526e7f91c93ce3db31e68286.png" 
alt=""></p> <h2>小结</h2> <p>今天，我带你一起梳理了系统监控的基本思路。</p> <p>系统监控的核心是资源的使用情况，包括 CPU、内存、磁盘和文件系统、网络等硬件资源，以及文件描述符数、连接数、连接跟踪数等软件资源。而这些资源，都可以通过 
USE 法来建立核心性能指标。</p> <p>USE 法把系统资源的性能指标，简化成了三个类别，即使用率、饱和度以及错误数。 这三者任一类别过高时，都代表相对应的系统资源有可能存在性能瓶颈。</p> 
<p>基于 USE 法建立性能指标后，还需要通过一套完整的监控系统，把这些指标从采集、存储、查询、处理，再到告警和可视化展示等串联起来。你可以基于 Zabbix、Prometheus 
等各种开源的监控产品，构建这套监控系统。这样，不仅可以将系统资源的瓶颈快速暴露出来，还可以借助监控的历史，事后追查定位问题。</p> <p>当然，除了系统监控之外，应用程序的监控也是必不可少的，我将在下一节课继续为你拆解。</p> 
<h2>思考</h2> <p>最后，我想邀请你一起来聊聊，你是怎么监控系统性能的。你通常会监控哪些系统的性能指标，又是如何搭建监控系统、如何根据这些指标来定位系统资源瓶颈的？你可以结合我的讲述，总结自己的思路。</p> 
<p>欢迎在留言区和我讨论，也欢迎把这篇文章分享给你的同事、朋友。我们一起在实战中演练，在交流中进步。</p> <p><img src="https://static001.geekbang.org/resource/image/a3/e9/a396aed4116c2c989771c1295736abe9.jpg" 
alt=""></p>', body_summary='', bundle='book', delta=0, body_format='full_html', langcode='zh-hans', 
revision_id=1086 where entity_id=1086 
 {executed in 0 msec}
2020-11-25 10:19:19.333 INFO  jdbc.sqltiming Line:373 - update node_revision__body set body_value='<p>你好，我是倪朋飞。</p> <p>在前面的内容中，我为你介绍了很多性能分析的原理、思路以及相关的工具。不过，在实际的性能分析中，一个很常见的现象是，明明发生了性能瓶颈，但当你登录到服务器中想要排查的时候，却发现瓶颈已经消失了。或者说，性能问题总是时不时地发生，但却很难找出发生规律，也很难重现。</p> 
<p>当面对这样的场景时，你可能会发现，我们前面介绍的各种工具、方法都“失效“了。为什么呢？因为它们都需要在性能问题发生的时刻才有效，而在这些事后分析的场景中，我们就很难发挥它们的威力了。</p> 
<p>那该怎么办呢？置之不理吗？其实以往，很多应用都是等到用户抱怨响应慢了，或者系统崩溃了后，才发现系统或者应用程序的性能出现了问题。虽然最终也能发现问题，但显然，这种方法是不可取的，因为严重影响了用户的体验。</p> 
<p>而要解决这个问题，就要搭建监控系统，把系统和应用程序的运行状况监控起来，并定义一系列的策略，在发生问题时第一时间告警通知。一个好的监控系统，不仅可以实时暴露系统的各种问题，更可以根据这些监控到的状态，自动分析和定位大致的瓶颈来源，从而更精确地把问题汇报给相关团队处理。</p> 
<p>要做好监控，最核心的就是全面的、可量化的指标，这包括系统和应用两个方面。</p><!-- [[[read_end]]] --> <p>从系统来说，监控系统要涵盖系统的整体资源使用情况，比如我们前面讲过的 
CPU、内存、磁盘和文件系统、网络等各种系统资源。</p> <p>而从应用程序来说，监控系统要涵盖应用程序内部的运行状态，这既包括进程的 CPU、磁盘 I/O 等整体运行状况，更需要包括诸如接口调用耗时、执行过程中的错误、内部对象的内存使用等应用程序内部的运行状况。</p> 
<p>今天，我就带你一起来看看，如何对 Linux 系统进行监控。而在下一节，我将继续为你讲解应用程序监控的思路。</p> <h2>USE 法</h2> <p>在开始监控系统之前，你肯定最想知道，怎么才能用简洁的方法，来描述系统资源的使用情况。你当然可以使用专栏中学到的各种性能工具，来分别收集各种资源的使用情况。不过不要忘记，每种资源的性能指标可都有很多，使用过多指标本身耗时耗力不说，也不容易为你建立起系统整体的运行状况。</p> 
<p>在这里，我为你介绍一种专门用于性能监控的 USE（Utilization Saturation and Errors）法。USE 法把系统资源的性能指标，简化成了三个类别，即使用率、饱和度以及错误数。</p> 
<ul> <li> <p>使用率，表示资源用于服务的时间或容量百分比。100% 的使用率，表示容量已经用尽或者全部时间都用于服务。</p> </li> <li> <p>饱和度，表示资源的繁忙程度，通常与等待队列的长度相关。100% 
的饱和度，表示资源无法接受更多的请求。</p> </li> <li> <p>错误数表示发生错误的事件个数。错误数越多，表明系统的问题越严重。</p> </li> </ul> <p>这三个类别的指标，涵盖了系统资源的常见性能瓶颈，所以常被用来快速定位系统资源的性能瓶颈。这样，无论是对 
CPU、内存、磁盘和文件系统、网络等硬件资源，还是对文件描述符数、连接数、连接跟踪数等软件资源，USE 方法都可以帮你快速定位出，是哪一种系统资源出现了性能瓶颈。</p> <p>那么，对于每一种系统资源，又有哪些常见的性能指标呢？回忆一下我们讲过的各种系统资源原理，并不难想到相关的性能指标。这里，我把常见的性能指标画了一张表格，方便你在需要时查看。</p> 
<p><img src="https://static001.geekbang.org/resource/image/cc/ee/ccd7a9350c270c0168bad6cc8d0b8aee.png" 
alt=""></p> <p>不过，需要注意的是，USE 方法只关注能体现系统资源性能瓶颈的核心指标，但这并不是说其他指标不重要。诸如系统日志、进程资源使用量、缓存使用量等其他各类指标，也都需要我们监控起来。只不过，它们通常用作辅助性能分析，而 
USE 方法的指标，则直接表明了系统的资源瓶颈。</p> <h2>监控系统</h2> <p>掌握 USE 方法以及需要监控的性能指标后，接下来要做的，就是建立监控系统，把这些指标保存下来；然后，根据这些监控到的状态，自动分析和定位大致的瓶颈来源；最后，再通过告警系统，把问题及时汇报给相关团队处理。</p> 
<p>可以看出，一个完整的监控系统通常由数据采集、数据存储、数据查询和处理、告警以及可视化展示等多个模块组成。所以，要从头搭建一个监控系统，其实也是一个很大的系统工程。</p> <p>不过，幸运的是，现在已经有很多开源的监控工具可以直接使用，比如最常见的 
Zabbix、Nagios、Prometheus 等等。</p> <p>下面，我就以 Prometheus 为例，为你介绍这几个组件的基本原理。如下图所示，就是 Prometheus 
的基本架构：</p> <p><img src="https://static001.geekbang.org/resource/image/7f/56/7f9c36db17785097ef9d186fd782ce56.png" 
alt=""></p> <p>（图片来自 <a href="https://prometheus.io/docs/introduction/overview/">prometheus.io</a>）</p> 
<p>先看数据采集模块。最左边的 Prometheus targets 就是数据采集的对象，而 Retrieval 则负责采集这些数据。从图中你也可以看到，Prometheus 同时支持 
Push 和 Pull 两种数据采集模式。</p> <ul> <li> <p>Pull 模式，由服务器端的采集模块来触发采集。只要采集目标提供了 HTTP 接口，就可以自由接入（这也是最常用的采集模式）。</p> 
</li> <li> <p>Push 模式，则是由各个采集目标主动向 Push Gateway（用于防止数据丢失）推送指标，再由服务器端从 Gateway 中拉取过去（这是移动应用中最常用的采集模式）。</p> 
</li> </ul> <p>由于需要监控的对象通常都是动态变化的，Prometheus 还提供了服务发现的机制，可以自动根据预配置的规则，动态发现需要监控的对象。这在 Kubernetes 
等容器平台中非常有效。</p> <p>第二个是数据存储模块。为了保持监控数据的持久化，图中的 TSDB（Time series database）模块，负责将采集到的数据持久化到 SSD 
等磁盘设备中。TSDB 是专门为时间序列数据设计的一种数据库，特点是以时间为索引、数据量大并且以追加的方式写入。</p> <p>第三个是数据查询和处理模块。刚才提到的 TSDB，在存储数据的同时，其实还提供了数据查询和基本的数据处理功能，而这也就是 
PromQL 语言。PromQL 提供了简洁的查询、过滤功能，并且支持基本的数据处理方法，是告警系统和可视化展示的基础。</p> <p>第四个是告警模块。右上角的 AlertManager 
提供了告警的功能，包括基于 PromQL 语言的触发条件、告警规则的配置管理以及告警的发送等。不过，虽然告警是必要的，但过于频繁的告警显然也不可取。所以，AlertManager 还支持通过分组、抑制或者静默等多种方式来聚合同类告警，并减少告警数量。</p> 
<p>最后一个是可视化展示模块。Prometheus 的 web UI 提供了简单的可视化界面，用于执行 PromQL 查询语句，但结果的展示比较单调。不过，一旦配合 Grafana，就可以构建非常强大的图形界面了。</p> 
<p>介绍完了这些组件，想必你对每个模块都有了比较清晰的认识。接下来，我们再来继续深入了解这些组件结合起来的整体功能。</p> <p>比如，以刚才提到的 USE 方法为例，我使用 Prometheus，可以收集 
Linux 服务器的 CPU、内存、磁盘、网络等各类资源的使用率、饱和度和错误数指标。然后，通过 Grafana 以及 PromQL 查询语句，就可以把它们以图形界面的方式直观展示出来。</p> 
<p><img src="https://static001.geekbang.org/resource/image/e5/91/e55600aa21fd6e8d96373f950b2a9991.png" 
alt=""><img src="https://static001.geekbang.org/resource/image/28/86/28410012526e7f91c93ce3db31e68286.png" 
alt=""></p> <h2>小结</h2> <p>今天，我带你一起梳理了系统监控的基本思路。</p> <p>系统监控的核心是资源的使用情况，包括 CPU、内存、磁盘和文件系统、网络等硬件资源，以及文件描述符数、连接数、连接跟踪数等软件资源。而这些资源，都可以通过 
USE 法来建立核心性能指标。</p> <p>USE 法把系统资源的性能指标，简化成了三个类别，即使用率、饱和度以及错误数。 这三者任一类别过高时，都代表相对应的系统资源有可能存在性能瓶颈。</p> 
<p>基于 USE 法建立性能指标后，还需要通过一套完整的监控系统，把这些指标从采集、存储、查询、处理，再到告警和可视化展示等串联起来。你可以基于 Zabbix、Prometheus 
等各种开源的监控产品，构建这套监控系统。这样，不仅可以将系统资源的瓶颈快速暴露出来，还可以借助监控的历史，事后追查定位问题。</p> <p>当然，除了系统监控之外，应用程序的监控也是必不可少的，我将在下一节课继续为你拆解。</p> 
<h2>思考</h2> <p>最后，我想邀请你一起来聊聊，你是怎么监控系统性能的。你通常会监控哪些系统的性能指标，又是如何搭建监控系统、如何根据这些指标来定位系统资源瓶颈的？你可以结合我的讲述，总结自己的思路。</p> 
<p>欢迎在留言区和我讨论，也欢迎把这篇文章分享给你的同事、朋友。我们一起在实战中演练，在交流中进步。</p> <p><img src="https://static001.geekbang.org/resource/image/a3/e9/a396aed4116c2c989771c1295736abe9.jpg" 
alt=""></p>', body_summary='', bundle='book', delta=0, body_format='full_html', langcode='zh-hans', 
revision_id=1086 where entity_id=1086 
 {executed in 0 msec}
2020-11-25 10:19:19.337 INFO  jdbc.sqltiming Line:373 - select nodefiledd0_.nid as nid1_10_, nodefiledd0_.changed as changed2_10_, nodefiledd0_.created 
as created3_10_, nodefiledd0_.default_langcode as default_4_10_, nodefiledd0_.langcode as langcode5_10_, 
nodefiledd0_.promote as promote6_10_, nodefiledd0_.revision_translation_affected as revision7_10_, 
nodefiledd0_.status as status8_10_, nodefiledd0_.sticky as sticky9_10_, nodefiledd0_.title 
as title10_10_, nodefiledd0_.type as type11_10_, nodefiledd0_.uid as uid12_10_, nodefiledd0_.vid 
as vid13_10_ from node_field_data nodefiledd0_ where nodefiledd0_.nid=1086 
 {executed in 0 msec}
2020-11-25 10:19:19.338 INFO  jdbc.resultsettable Line:610 - 
|-----|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|-----------------|-----|----|-----|
|nid  |changed    |created    |default_langcode |langcode |promote |revision_translation_affected |status |sticky |title            |type |uid |vid  |
|-----|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|-----------------|-----|----|-----|
|1086 |1606114999 |1606114999 |1                |zh-hans  |0       |1                             |1      |0      |53丨套路篇：系统监控的综合思路 |book |1   |1086 |
|-----|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|-----------------|-----|----|-----|

2020-11-25 10:19:19.339 INFO  jdbc.sqltiming Line:373 - select nodefieldr0_.nid as nid1_11_0_, nodefieldr0_.changed as changed2_11_0_, nodefieldr0_.created 
as created3_11_0_, nodefieldr0_.default_langcode as default_4_11_0_, nodefieldr0_.langcode 
as langcode5_11_0_, nodefieldr0_.promote as promote6_11_0_, nodefieldr0_.revision_translation_affected 
as revision7_11_0_, nodefieldr0_.status as status8_11_0_, nodefieldr0_.sticky as sticky9_11_0_, 
nodefieldr0_.title as title10_11_0_, nodefieldr0_.uid as uid11_11_0_, nodefieldr0_.vid as vid12_11_0_ 
from node_field_revision nodefieldr0_ where nodefieldr0_.nid=1086 
 {executed in 0 msec}
2020-11-25 10:19:19.340 INFO  jdbc.resultsettable Line:610 - 
|---------|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|-----------------|----|-----|
|nid      |changed    |created    |default_langcode |langcode |promote |revision_translation_affected |status |sticky |title            |uid |vid  |
|---------|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|-----------------|----|-----|
|[unread] |1606114999 |1606114999 |1                |zh-hans  |0       |1                             |1      |0      |53丨套路篇：系统监控的综合思路 |1   |1086 |
|---------|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|-----------------|----|-----|

2020-11-25 10:19:19.341 INFO  jdbc.sqltiming Line:373 - update node_field_data set changed=1606270759, created=1606270759, default_langcode=1, langcode='zh-hans', 
promote=0, revision_translation_affected=1, status=1, sticky=0, title='53丨套路篇：系统监控的综合思路', type='book', 
uid=1, vid=1086 where nid=1086 
 {executed in 0 msec}
2020-11-25 10:19:19.341 INFO  jdbc.sqltiming Line:373 - update node_field_revision set changed=1606270759, created=1606270759, default_langcode=1, 
langcode='zh-hans', promote=0, revision_translation_affected=1, status=1, sticky=0, title='53丨套路篇：系统监控的综合思路', 
uid=1, vid=1086 where nid=1086 
 {executed in 0 msec}
2020-11-25 10:19:19.346 INFO  jdbc.sqltiming Line:373 - select bookfieldm0_.entity_id as entity_i1_8_, bookfieldm0_.bundle as bundle2_8_, bookfieldm0_.delta 
as delta3_8_, bookfieldm0_.langcode as langcode4_8_, bookfieldm0_.field_media_value as field_me5_8_, 
bookfieldm0_.revision_id as revision6_8_ from node__field_media bookfieldm0_ where bookfieldm0_.entity_id=1086 
 {executed in 1 msec}
2020-11-25 10:19:19.346 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------------|------------|
|entity_id |bundle |delta |langcode |field_media_value |revision_id |
|----------|-------|------|---------|------------------|------------|
|1086      |book   |0     |zh-hans  |                  |1086        |
|----------|-------|------|---------|------------------|------------|

2020-11-25 10:19:19.348 INFO  jdbc.sqltiming Line:373 - select nodefieldm0_.entity_id as entity_i1_17_0_, nodefieldm0_.bundle as bundle2_17_0_, nodefieldm0_.delta 
as delta3_17_0_, nodefieldm0_.langcode as langcode4_17_0_, nodefieldm0_.field_media_value as 
field_me5_17_0_, nodefieldm0_.revision_id as revision6_17_0_ from node_revision__field_media 
nodefieldm0_ where nodefieldm0_.entity_id=1086 
 {executed in 0 msec}
2020-11-25 10:19:19.349 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------------|------------|
|entity_id |bundle |delta |langcode |field_media_value |revision_id |
|----------|-------|------|---------|------------------|------------|
|[unread]  |book   |0     |zh-hans  |                  |1086        |
|----------|-------|------|---------|------------------|------------|

2020-11-25 10:19:19.351 INFO  jdbc.sqltiming Line:373 - select bookfieldc0_.entity_id as entity_i1_5_, bookfieldc0_.bundle as bundle2_5_, bookfieldc0_.field_comment_value 
as field_co3_5_, bookfieldc0_.delta as delta4_5_, bookfieldc0_.field_comment_format as field_co5_5_, 
bookfieldc0_.langcode as langcode6_5_, bookfieldc0_.revision_id as revision7_5_ from node__field_comment 
bookfieldc0_ where bookfieldc0_.entity_id=1086 
 {executed in 0 msec}
2020-11-25 10:19:19.352 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|--------------------|------|---------------------|---------|------------|
|entity_id |bundle |field_comment_value |delta |field_comment_format |langcode |revision_id |
|----------|-------|--------------------|------|---------------------|---------|------------|
|1086      |book   |                    |0     |full_html            |zh-hans  |1086        |
|----------|-------|--------------------|------|---------------------|---------|------------|

2020-11-25 10:19:19.355 INFO  jdbc.sqltiming Line:373 - update node__field_comment set bundle='book', field_comment_value='<li class="reJj6Thl_0"><img 
src="https://wx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEKQMM4m7NHuicr55aRiblTSEWIYe0QqbpyHweaoAbG7j2v7UUElqqeP3Ihrm3UfDPDRb1Hv8LvPwXqA/132" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>ninuxer</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-29 </div> </div> <div 
class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">4</span> 
</div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 打卡day57 <br>最近刚好在利用cadvisor+promethues+grafana对运行容器进行资源监控，现在是用grafana基于图形的告警，对promethues的查询语言还在摸索中～ 
</div> <!----> <!----> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/13/ec/21/b0fe1bfd.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>Adam</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-31 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> </div> <!----> 
<!----> </div> </div> <div class="_3M6kV3zb_0"> 除了USE原则，还有一个RED原则 。 </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 
嗯嗯，RED方法更偏重于应用，在很多微服务中会用到。<br><br>Rate (R): The number of requests per second.<br>Errors (E): 
The number of failed requests.<br>Duration (D): The amount of time to process a request.</p> 
</div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/14/3d/77/45e5e06d.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>胡鹏</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-30 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> </div> <!----> 
<!----> </div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 我目前的水平是，看到接口慢了，说明存在性能瓶颈了，😂，还得继续努力 
</div> <!----> <!----> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/0f/6c/64/abb7bfe3.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>霹雳旸神</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-30 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> </div> <!----> 
<!----> </div> </div> <div class="_3M6kV3zb_0"> 公司交易系统监控还停留在hostmonitor来配置监控的阶段，各产品基本思想都差不多，老师这样一梳理脑子更清晰了，目前自己正在研究如何把交易系统容器化，等把百来套交易系统的集群搞起来后，再把老师推荐的监控方案亲自实践一遍，应该会学的更深刻 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 👍</p> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/13/ec/21/b0fe1bfd.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>Adam</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-29 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> </div> <!----> 
<!----> </div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 打卡,线上用prometheus+grafana监控k8s资源。prometheus够强大。 
</div> <!----> <!----> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/11/31/d8/18a2de6d.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>朱林浩</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-04-29 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> 如何查看内存饱和度，即内存换页量？ </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 
可以使用 sar -B</p> </div> </div></li> <li class="reJj6Thl_0"><img src="" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>如果</span> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2019-04-23 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> DAY53，打卡 <br> </div> <div class="_2r3UB1GX_0"> <span>展开</span><i 
class="iconfont"></i> </div> <!----> </div></li> <li class="reJj6Thl_0"><img src="https://thirdwx.qlogo.cn/mmopen/vi_32/nNLq6GHrFNm6HrxWeMLf9t31G8fO1s1j3qk995thicplR8Oo2JOJ546aQPCsRND58Q0HyjrdtK1udgdemzR2eaA/132" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>Wing</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-04-15 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 用什么命令可以得到这个 网络： 带宽使用率，重传报文数， 网卡收发错误数，丢包数。 
<br> </div> <!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: sar、netstat</p> 
</div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/16/22/15/c693b106.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>lerry</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-04-01 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> 我们是用zabbix来监控服务器的，最近有台虚拟机应用服务器，经常挂了，无法连接上，从vcenter后台也无法连上，每次只能强制关闭启动服务器，找了很久原因都没找到，查看zabbix挂了之前的资源使用情况，同样没发现问题，对于这种情况，还请老师给点思路啊，谢谢！ 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 重启的话，系统日志里面一般会有线索的，可以重启后查看系统日志（当然这些日志最好也是收集起来几种监控）</p> </div> 
</div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/10/19/31/b438b9cf.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>zg</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-31 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> 可以移植到ARM嵌入式Linux系统吗？ </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 
要看监控工具是不是支持ARM，比如Prometheus提供了ARM版本</p> </div> </div></li> <li class="reJj6Thl_0"><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eo9ls0YJfc9CQhxxqVNP57N4D4gHfqt6oP5UhxibqgRwqj9f8UVusDVH24QYzj5JtAfdvY35ay5amQ/132" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>高</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-31 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> 倪老师，您好，通过您的课程受益匪浅。最近我刚好在生产中遇到了个问题，k8s环境下，因为某个cgroup超出限制，系统不停的重启pod，最后引发系统crash。我们收集到了core 
dump文件，确定了最后是触发了linux的Bug导致系统crash；系统不停的重启pod，应该是内存泄露导致，引发了oom；通过coredump文件，我找到了一堆java线程，应该是这个所致，但是在分析过程中的一些指标还不是很清楚，希望能够得到指导；如果您方便的话，可以加我微信18910659557，非常期待您的答复 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 哪些指标不清楚在这里说一下？有疑问发到留言里面，其他同学也可以一起参与讨论</p> </div> </div></li> <li 
class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>我来也</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-30 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> [D53打卡] <br>划个水.😁 <br> <br>这个系统监控 与 云服务平台提供的有哪些差异,适用什么样的场景呢? 
<br> </div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div 
class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 云平台一般都会提供一些基本的指标监控，但很可能不够细致</p> </div> </div></li> 
<li class="reJj6Thl_0"><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/8OPzdpDraQMvCNWAicicDt54sDaIYJZicBLfMyibXVs4V0ZibEdkZlbzxxL7aGpRoeyvibag5LaAaaGKSdwYQMY2hUrQ/132" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>code2</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-30 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 见过上海超算中心的超级计算机系统性能监控系统，主要监控CPU的使用情况，可以预留部分CPU给重要任务，也是基于linux的操作系统，监控结果图形化显示与一个大屏幕上。 
</div> <!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 👍 </p> </div> </div></li> 
<li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/14/43/50/ef2cfbce.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>蒙</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-29 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 遇到的监控问题：有时候单个性能瓶颈往往引起一连串问题，比如swap使用，导致请求响应慢，请求堆积，线程增多，文件句柄数升高，cpu瞬间升高。归因分析比较困难。最后就变成重启大法好 
</div> <!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 嗯，这就需要熟悉这些基本的原理，结合原理是所有性能分析的基础</p> 
</div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/10/93/43/0e84492d.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>Maxwell</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-29 </div> </div> <div 
class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> 
</div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 文件描述符数，连接数，连接跟踪数这些指标监控系统如何监控呢？ 
</div> <!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 监控系统一般从proc和sys文件系统中读取</p> 
</div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/10/93/43/0e84492d.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>Maxwell</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-29 </div> </div> <div 
class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> 
</div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 怎么理解上面哪些性能指标的错误数呢？cpu错误数什么情况下出现，内存分配错误等 
</div> <!----> <!----> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/10/d8/08/87afa2aa.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>星辰</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-29 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> 刚好在做系统模版监控 有这个思路 框架就有了 </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <!----> </div></li>', delta=0, field_comment_format='full_html', 
langcode='zh-hans', revision_id=1086 where entity_id=1086 
 {executed in 0 msec}
2020-11-25 10:19:19.358 INFO  jdbc.sqltiming Line:373 - select nodefieldc0_.entity_id as entity_i1_14_0_, nodefieldc0_.bundle as bundle2_14_0_, nodefieldc0_.field_comment_value 
as field_co3_14_0_, nodefieldc0_.delta as delta4_14_0_, nodefieldc0_.field_comment_format as 
field_co5_14_0_, nodefieldc0_.langcode as langcode6_14_0_, nodefieldc0_.revision_id as revision7_14_0_ 
from node_revision__field_comment nodefieldc0_ where nodefieldc0_.entity_id=1086 
 {executed in 0 msec}
2020-11-25 10:19:19.359 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|--------------------|------|---------------------|---------|------------|
|entity_id |bundle |field_comment_value |delta |field_comment_format |langcode |revision_id |
|----------|-------|--------------------|------|---------------------|---------|------------|
|[unread]  |book   |                    |0     |full_html            |zh-hans  |1086        |
|----------|-------|--------------------|------|---------------------|---------|------------|

2020-11-25 10:19:19.361 INFO  jdbc.sqltiming Line:373 - update node_revision__field_comment set bundle='book', field_comment_value='<li class="reJj6Thl_0"><img 
src="https://wx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEKQMM4m7NHuicr55aRiblTSEWIYe0QqbpyHweaoAbG7j2v7UUElqqeP3Ihrm3UfDPDRb1Hv8LvPwXqA/132" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>ninuxer</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-29 </div> </div> <div 
class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">4</span> 
</div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 打卡day57 <br>最近刚好在利用cadvisor+promethues+grafana对运行容器进行资源监控，现在是用grafana基于图形的告警，对promethues的查询语言还在摸索中～ 
</div> <!----> <!----> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/13/ec/21/b0fe1bfd.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>Adam</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-31 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> </div> <!----> 
<!----> </div> </div> <div class="_3M6kV3zb_0"> 除了USE原则，还有一个RED原则 。 </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 
嗯嗯，RED方法更偏重于应用，在很多微服务中会用到。<br><br>Rate (R): The number of requests per second.<br>Errors (E): 
The number of failed requests.<br>Duration (D): The amount of time to process a request.</p> 
</div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/14/3d/77/45e5e06d.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>胡鹏</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-30 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> </div> <!----> 
<!----> </div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 我目前的水平是，看到接口慢了，说明存在性能瓶颈了，😂，还得继续努力 
</div> <!----> <!----> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/0f/6c/64/abb7bfe3.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>霹雳旸神</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-30 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> </div> <!----> 
<!----> </div> </div> <div class="_3M6kV3zb_0"> 公司交易系统监控还停留在hostmonitor来配置监控的阶段，各产品基本思想都差不多，老师这样一梳理脑子更清晰了，目前自己正在研究如何把交易系统容器化，等把百来套交易系统的集群搞起来后，再把老师推荐的监控方案亲自实践一遍，应该会学的更深刻 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 👍</p> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/13/ec/21/b0fe1bfd.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>Adam</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-29 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> </div> <!----> 
<!----> </div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 打卡,线上用prometheus+grafana监控k8s资源。prometheus够强大。 
</div> <!----> <!----> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/11/31/d8/18a2de6d.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>朱林浩</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-04-29 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> 如何查看内存饱和度，即内存换页量？ </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 
可以使用 sar -B</p> </div> </div></li> <li class="reJj6Thl_0"><img src="" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>如果</span> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2019-04-23 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> DAY53，打卡 <br> </div> <div class="_2r3UB1GX_0"> <span>展开</span><i 
class="iconfont"></i> </div> <!----> </div></li> <li class="reJj6Thl_0"><img src="https://thirdwx.qlogo.cn/mmopen/vi_32/nNLq6GHrFNm6HrxWeMLf9t31G8fO1s1j3qk995thicplR8Oo2JOJ546aQPCsRND58Q0HyjrdtK1udgdemzR2eaA/132" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>Wing</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-04-15 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 用什么命令可以得到这个 网络： 带宽使用率，重传报文数， 网卡收发错误数，丢包数。 
<br> </div> <!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: sar、netstat</p> 
</div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/16/22/15/c693b106.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>lerry</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-04-01 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> 我们是用zabbix来监控服务器的，最近有台虚拟机应用服务器，经常挂了，无法连接上，从vcenter后台也无法连上，每次只能强制关闭启动服务器，找了很久原因都没找到，查看zabbix挂了之前的资源使用情况，同样没发现问题，对于这种情况，还请老师给点思路啊，谢谢！ 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 重启的话，系统日志里面一般会有线索的，可以重启后查看系统日志（当然这些日志最好也是收集起来几种监控）</p> </div> 
</div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/10/19/31/b438b9cf.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>zg</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-31 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> 可以移植到ARM嵌入式Linux系统吗？ </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 
要看监控工具是不是支持ARM，比如Prometheus提供了ARM版本</p> </div> </div></li> <li class="reJj6Thl_0"><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eo9ls0YJfc9CQhxxqVNP57N4D4gHfqt6oP5UhxibqgRwqj9f8UVusDVH24QYzj5JtAfdvY35ay5amQ/132" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>高</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-31 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> 倪老师，您好，通过您的课程受益匪浅。最近我刚好在生产中遇到了个问题，k8s环境下，因为某个cgroup超出限制，系统不停的重启pod，最后引发系统crash。我们收集到了core 
dump文件，确定了最后是触发了linux的Bug导致系统crash；系统不停的重启pod，应该是内存泄露导致，引发了oom；通过coredump文件，我找到了一堆java线程，应该是这个所致，但是在分析过程中的一些指标还不是很清楚，希望能够得到指导；如果您方便的话，可以加我微信18910659557，非常期待您的答复 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 哪些指标不清楚在这里说一下？有疑问发到留言里面，其他同学也可以一起参与讨论</p> </div> </div></li> <li 
class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>我来也</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-30 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> [D53打卡] <br>划个水.😁 <br> <br>这个系统监控 与 云服务平台提供的有哪些差异,适用什么样的场景呢? 
<br> </div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div 
class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 云平台一般都会提供一些基本的指标监控，但很可能不够细致</p> </div> </div></li> 
<li class="reJj6Thl_0"><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/8OPzdpDraQMvCNWAicicDt54sDaIYJZicBLfMyibXVs4V0ZibEdkZlbzxxL7aGpRoeyvibag5LaAaaGKSdwYQMY2hUrQ/132" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>code2</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-30 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 见过上海超算中心的超级计算机系统性能监控系统，主要监控CPU的使用情况，可以预留部分CPU给重要任务，也是基于linux的操作系统，监控结果图形化显示与一个大屏幕上。 
</div> <!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 👍 </p> </div> </div></li> 
<li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/14/43/50/ef2cfbce.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>蒙</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-29 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 遇到的监控问题：有时候单个性能瓶颈往往引起一连串问题，比如swap使用，导致请求响应慢，请求堆积，线程增多，文件句柄数升高，cpu瞬间升高。归因分析比较困难。最后就变成重启大法好 
</div> <!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 嗯，这就需要熟悉这些基本的原理，结合原理是所有性能分析的基础</p> 
</div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/10/93/43/0e84492d.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>Maxwell</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-29 </div> </div> <div 
class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> 
</div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 文件描述符数，连接数，连接跟踪数这些指标监控系统如何监控呢？ 
</div> <!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 监控系统一般从proc和sys文件系统中读取</p> 
</div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/10/93/43/0e84492d.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>Maxwell</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-29 </div> </div> <div 
class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> 
</div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 怎么理解上面哪些性能指标的错误数呢？cpu错误数什么情况下出现，内存分配错误等 
</div> <!----> <!----> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/10/d8/08/87afa2aa.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>星辰</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-03-29 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> 刚好在做系统模版监控 有这个思路 框架就有了 </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <!----> </div></li>', delta=0, field_comment_format='full_html', 
langcode='zh-hans', revision_id=1086 where entity_id=1086 
 {executed in 1 msec}
2020-11-25 10:19:19.364 INFO  jdbc.sqltiming Line:373 - select bookfieldt0_.entity_id as entity_i1_9_, bookfieldt0_.bundle as bundle2_9_, bookfieldt0_.delta 
as delta3_9_, bookfieldt0_.langcode as langcode4_9_, bookfieldt0_.revision_id as revision5_9_, 
bookfieldt0_.field_thumb_value as field_th6_9_ from node__field_thumb bookfieldt0_ where bookfieldt0_.entity_id=1086 
 {executed in 0 msec}
2020-11-25 10:19:19.365 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------|------------------|
|entity_id |bundle |delta |langcode |revision_id |field_thumb_value |
|----------|-------|------|---------|------------|------------------|
|1086      |book   |0     |zh-hans  |1086        |                  |
|----------|-------|------|---------|------------|------------------|

2020-11-25 10:19:19.366 INFO  jdbc.sqltiming Line:373 - update node__field_thumb set bundle='book', delta=0, langcode='zh-hans', revision_id=1086, 
field_thumb_value='https://static001.geekbang.org/resource/image/39/68/393ab3e04bc65c18b2d0be7f745d4068.jpg' 
where entity_id=1086 
 {executed in 0 msec}
2020-11-25 10:19:19.371 INFO  jdbc.sqltiming Line:373 - select nodefieldt0_.entity_id as entity_i1_18_0_, nodefieldt0_.bundle as bundle2_18_0_, nodefieldt0_.delta 
as delta3_18_0_, nodefieldt0_.langcode as langcode4_18_0_, nodefieldt0_.revision_id as revision5_18_0_, 
nodefieldt0_.field_thumb_value as field_th6_18_0_ from node_revision__field_thumb nodefieldt0_ 
where nodefieldt0_.entity_id=1086 
 {executed in 1 msec}
2020-11-25 10:19:19.371 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------|------------------|
|entity_id |bundle |delta |langcode |revision_id |field_thumb_value |
|----------|-------|------|---------|------------|------------------|
|[unread]  |book   |0     |zh-hans  |1086        |                  |
|----------|-------|------|---------|------------|------------------|

2020-11-25 10:19:19.373 INFO  jdbc.sqltiming Line:373 - update node_revision__field_thumb set bundle='book', delta=0, langcode='zh-hans', revision_id=1086, 
field_thumb_value='https://static001.geekbang.org/resource/image/39/68/393ab3e04bc65c18b2d0be7f745d4068.jpg' 
where entity_id=1086 
 {executed in 0 msec}
2020-11-25 10:19:19.378 INFO  jdbc.sqltiming Line:373 - select bookfieldf0_.entity_id as entity_i1_6_0_, bookfieldf0_.bundle as bundle2_6_0_, bookfieldf0_.delta 
as delta3_6_0_, bookfieldf0_.field_fenlei_target_id as field_fe4_6_0_, bookfieldf0_.langcode 
as langcode5_6_0_, bookfieldf0_.revision_id as revision6_6_0_ from node__field_fenlei bookfieldf0_ 
where bookfieldf0_.entity_id=1086 
 {executed in 0 msec}
2020-11-25 10:19:19.379 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|-----------------------|---------|------------|
|entity_id |bundle |delta |field_fenlei_target_id |langcode |revision_id |
|----------|-------|------|-----------------------|---------|------------|
|[unread]  |book   |0     |1                      |zh-hans  |1086        |
|----------|-------|------|-----------------------|---------|------------|

2020-11-25 10:19:19.381 INFO  jdbc.sqltiming Line:373 - select nodefieldf0_.entity_id as entity_i1_15_0_, nodefieldf0_.bundle as bundle2_15_0_, nodefieldf0_.delta 
as delta3_15_0_, nodefieldf0_.field_fenlei_target_id as field_fe4_15_0_, nodefieldf0_.langcode 
as langcode5_15_0_, nodefieldf0_.revision_id as revision6_15_0_ from node_revision__field_fenlei 
nodefieldf0_ where nodefieldf0_.entity_id=1086 
 {executed in 0 msec}
2020-11-25 10:19:19.382 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|-----------------------|---------|------------|
|entity_id |bundle |delta |field_fenlei_target_id |langcode |revision_id |
|----------|-------|------|-----------------------|---------|------------|
|[unread]  |book   |0     |1                      |zh-hans  |1086        |
|----------|-------|------|-----------------------|---------|------------|

2020-11-25 10:19:19.384 INFO  jdbc.sqltiming Line:373 - select bookchecke0_.item_id as item_id1_2_, bookchecke0_.fsid as fsid2_2_, bookchecke0_.got 
as got3_2_, bookchecke0_.name as name4_2_, bookchecke0_.parse_fail as parse_fa5_2_, bookchecke0_.parsed 
as parsed6_2_, bookchecke0_.path as path7_2_, bookchecke0_.title as title8_2_, bookchecke0_.vid 
as vid9_2_ from book_check bookchecke0_ where bookchecke0_.fsid='183778161226336' and bookchecke0_.name='net_content' 
 {executed in 0 msec}
2020-11-25 10:19:19.385 INFO  jdbc.resultsettable Line:610 - 
|--------|---------|---------|---------|-----------|---------|---------|---------|---------|
|item_id |fsid     |got      |name     |parse_fail |parsed   |path     |title    |vid      |
|--------|---------|---------|---------|-----------|---------|---------|---------|---------|
|1087    |[unread] |[unread] |[unread] |[unread]   |[unread] |[unread] |[unread] |[unread] |
|--------|---------|---------|---------|-----------|---------|---------|---------|---------|

2020-11-25 10:19:19.859 INFO  jdbc.sqltiming Line:373 - update book_check set fsid='183778161226336', got=0, name='net_content', parse_fail='con_comment_thumb', 
parsed=0, path='12-Linux性能优化实战/06-综合实战篇 (13讲)/54丨套路篇：应用监控的一般思路.html', title='54丨套路篇：应用监控的一般思路', 
vid=1087 where item_id=1087 
 {executed in 1 msec}
2020-11-25 10:19:19.869 INFO  jdbc.sqltiming Line:373 - select nodebodyen0_.entity_id as entity_i1_4_, nodebodyen0_.body_value as body_val2_4_, nodebodyen0_.body_summary 
as body_sum3_4_, nodebodyen0_.bundle as bundle4_4_, nodebodyen0_.delta as delta5_4_, nodebodyen0_.body_format 
as body_for6_4_, nodebodyen0_.langcode as langcode7_4_, nodebodyen0_.revision_id as revision8_4_ 
from node__body nodebodyen0_ where nodebodyen0_.entity_id=1087 
 {executed in 1 msec}
2020-11-25 10:19:19.870 INFO  jdbc.resultsettable Line:610 - 
|----------|-----------|-------------|-------|------|------------|---------|------------|
|entity_id |body_value |body_summary |bundle |delta |body_format |langcode |revision_id |
|----------|-----------|-------------|-------|------|------------|---------|------------|
|1087      |           |             |book   |0     |full_html   |zh-hans  |1087        |
|----------|-----------|-------------|-------|------|------------|---------|------------|

2020-11-25 10:19:19.871 INFO  jdbc.sqltiming Line:373 - select nodebodyre0_.entity_id as entity_i1_13_0_, nodebodyre0_.body_value as body_val2_13_0_, 
nodebodyre0_.body_summary as body_sum3_13_0_, nodebodyre0_.bundle as bundle4_13_0_, nodebodyre0_.delta 
as delta5_13_0_, nodebodyre0_.body_format as body_for6_13_0_, nodebodyre0_.langcode as langcode7_13_0_, 
nodebodyre0_.revision_id as revision8_13_0_ from node_revision__body nodebodyre0_ where nodebodyre0_.entity_id=1087 
 {executed in 0 msec}
2020-11-25 10:19:19.872 INFO  jdbc.resultsettable Line:610 - 
|----------|-----------|-------------|-------|------|------------|---------|------------|
|entity_id |body_value |body_summary |bundle |delta |body_format |langcode |revision_id |
|----------|-----------|-------------|-------|------|------------|---------|------------|
|[unread]  |           |             |book   |0     |full_html   |zh-hans  |1087        |
|----------|-----------|-------------|-------|------|------------|---------|------------|

2020-11-25 10:19:19.878 INFO  jdbc.sqltiming Line:373 - select nodefiledd0_.nid as nid1_10_, nodefiledd0_.changed as changed2_10_, nodefiledd0_.created 
as created3_10_, nodefiledd0_.default_langcode as default_4_10_, nodefiledd0_.langcode as langcode5_10_, 
nodefiledd0_.promote as promote6_10_, nodefiledd0_.revision_translation_affected as revision7_10_, 
nodefiledd0_.status as status8_10_, nodefiledd0_.sticky as sticky9_10_, nodefiledd0_.title 
as title10_10_, nodefiledd0_.type as type11_10_, nodefiledd0_.uid as uid12_10_, nodefiledd0_.vid 
as vid13_10_ from node_field_data nodefiledd0_ where nodefiledd0_.nid=1087 
 {executed in 0 msec}
2020-11-25 10:19:19.879 INFO  jdbc.resultsettable Line:610 - 
|-----|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|-----------------|-----|----|-----|
|nid  |changed    |created    |default_langcode |langcode |promote |revision_translation_affected |status |sticky |title            |type |uid |vid  |
|-----|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|-----------------|-----|----|-----|
|1087 |1606115004 |1606115004 |1                |zh-hans  |0       |1                             |1      |0      |54丨套路篇：应用监控的一般思路 |book |1   |1087 |
|-----|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|-----------------|-----|----|-----|

2020-11-25 10:19:19.881 INFO  jdbc.sqltiming Line:373 - select nodefieldr0_.nid as nid1_11_0_, nodefieldr0_.changed as changed2_11_0_, nodefieldr0_.created 
as created3_11_0_, nodefieldr0_.default_langcode as default_4_11_0_, nodefieldr0_.langcode 
as langcode5_11_0_, nodefieldr0_.promote as promote6_11_0_, nodefieldr0_.revision_translation_affected 
as revision7_11_0_, nodefieldr0_.status as status8_11_0_, nodefieldr0_.sticky as sticky9_11_0_, 
nodefieldr0_.title as title10_11_0_, nodefieldr0_.uid as uid11_11_0_, nodefieldr0_.vid as vid12_11_0_ 
from node_field_revision nodefieldr0_ where nodefieldr0_.nid=1087 
 {executed in 1 msec}
2020-11-25 10:19:19.882 INFO  jdbc.resultsettable Line:610 - 
|---------|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|-----------------|----|-----|
|nid      |changed    |created    |default_langcode |langcode |promote |revision_translation_affected |status |sticky |title            |uid |vid  |
|---------|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|-----------------|----|-----|
|[unread] |1606115004 |1606115004 |1                |zh-hans  |0       |1                             |1      |0      |54丨套路篇：应用监控的一般思路 |1   |1087 |
|---------|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|-----------------|----|-----|

2020-11-25 10:19:19.885 INFO  jdbc.sqltiming Line:373 - update node_field_data set changed=1606270759, created=1606270759, default_langcode=1, langcode='zh-hans', 
promote=0, revision_translation_affected=1, status=1, sticky=0, title='54丨套路篇：应用监控的一般思路', type='book', 
uid=1, vid=1087 where nid=1087 
 {executed in 0 msec}
2020-11-25 10:19:19.886 INFO  jdbc.sqltiming Line:373 - update node_field_revision set changed=1606270759, created=1606270759, default_langcode=1, 
langcode='zh-hans', promote=0, revision_translation_affected=1, status=1, sticky=0, title='54丨套路篇：应用监控的一般思路', 
uid=1, vid=1087 where nid=1087 
 {executed in 0 msec}
2020-11-25 10:19:19.893 INFO  jdbc.sqltiming Line:373 - select bookfieldm0_.entity_id as entity_i1_8_, bookfieldm0_.bundle as bundle2_8_, bookfieldm0_.delta 
as delta3_8_, bookfieldm0_.langcode as langcode4_8_, bookfieldm0_.field_media_value as field_me5_8_, 
bookfieldm0_.revision_id as revision6_8_ from node__field_media bookfieldm0_ where bookfieldm0_.entity_id=1087 
 {executed in 0 msec}
2020-11-25 10:19:19.894 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------------|------------|
|entity_id |bundle |delta |langcode |field_media_value |revision_id |
|----------|-------|------|---------|------------------|------------|
|1087      |book   |0     |zh-hans  |                  |1087        |
|----------|-------|------|---------|------------------|------------|

2020-11-25 10:19:19.898 INFO  jdbc.sqltiming Line:373 - select nodefieldm0_.entity_id as entity_i1_17_0_, nodefieldm0_.bundle as bundle2_17_0_, nodefieldm0_.delta 
as delta3_17_0_, nodefieldm0_.langcode as langcode4_17_0_, nodefieldm0_.field_media_value as 
field_me5_17_0_, nodefieldm0_.revision_id as revision6_17_0_ from node_revision__field_media 
nodefieldm0_ where nodefieldm0_.entity_id=1087 
 {executed in 1 msec}
2020-11-25 10:19:19.898 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------------|------------|
|entity_id |bundle |delta |langcode |field_media_value |revision_id |
|----------|-------|------|---------|------------------|------------|
|[unread]  |book   |0     |zh-hans  |                  |1087        |
|----------|-------|------|---------|------------------|------------|

2020-11-25 10:19:19.902 INFO  jdbc.sqltiming Line:373 - select bookfieldc0_.entity_id as entity_i1_5_, bookfieldc0_.bundle as bundle2_5_, bookfieldc0_.field_comment_value 
as field_co3_5_, bookfieldc0_.delta as delta4_5_, bookfieldc0_.field_comment_format as field_co5_5_, 
bookfieldc0_.langcode as langcode6_5_, bookfieldc0_.revision_id as revision7_5_ from node__field_comment 
bookfieldc0_ where bookfieldc0_.entity_id=1087 
 {executed in 1 msec}
2020-11-25 10:19:19.902 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|--------------------|------|---------------------|---------|------------|
|entity_id |bundle |field_comment_value |delta |field_comment_format |langcode |revision_id |
|----------|-------|--------------------|------|---------------------|---------|------------|
|1087      |book   |                    |0     |full_html            |zh-hans  |1087        |
|----------|-------|--------------------|------|---------------------|---------|------------|

2020-11-25 10:19:19.905 INFO  jdbc.sqltiming Line:373 - select nodefieldc0_.entity_id as entity_i1_14_0_, nodefieldc0_.bundle as bundle2_14_0_, nodefieldc0_.field_comment_value 
as field_co3_14_0_, nodefieldc0_.delta as delta4_14_0_, nodefieldc0_.field_comment_format as 
field_co5_14_0_, nodefieldc0_.langcode as langcode6_14_0_, nodefieldc0_.revision_id as revision7_14_0_ 
from node_revision__field_comment nodefieldc0_ where nodefieldc0_.entity_id=1087 
 {executed in 0 msec}
2020-11-25 10:19:19.906 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|--------------------|------|---------------------|---------|------------|
|entity_id |bundle |field_comment_value |delta |field_comment_format |langcode |revision_id |
|----------|-------|--------------------|------|---------------------|---------|------------|
|[unread]  |book   |                    |0     |full_html            |zh-hans  |1087        |
|----------|-------|--------------------|------|---------------------|---------|------------|

2020-11-25 10:19:19.909 INFO  jdbc.sqltiming Line:373 - select bookfieldt0_.entity_id as entity_i1_9_, bookfieldt0_.bundle as bundle2_9_, bookfieldt0_.delta 
as delta3_9_, bookfieldt0_.langcode as langcode4_9_, bookfieldt0_.revision_id as revision5_9_, 
bookfieldt0_.field_thumb_value as field_th6_9_ from node__field_thumb bookfieldt0_ where bookfieldt0_.entity_id=1087 
 {executed in 1 msec}
2020-11-25 10:19:19.909 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------|------------------|
|entity_id |bundle |delta |langcode |revision_id |field_thumb_value |
|----------|-------|------|---------|------------|------------------|
|1087      |book   |0     |zh-hans  |1087        |                  |
|----------|-------|------|---------|------------|------------------|

2020-11-25 10:19:19.911 INFO  jdbc.sqltiming Line:373 - select nodefieldt0_.entity_id as entity_i1_18_0_, nodefieldt0_.bundle as bundle2_18_0_, nodefieldt0_.delta 
as delta3_18_0_, nodefieldt0_.langcode as langcode4_18_0_, nodefieldt0_.revision_id as revision5_18_0_, 
nodefieldt0_.field_thumb_value as field_th6_18_0_ from node_revision__field_thumb nodefieldt0_ 
where nodefieldt0_.entity_id=1087 
 {executed in 0 msec}
2020-11-25 10:19:19.912 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------|------------------|
|entity_id |bundle |delta |langcode |revision_id |field_thumb_value |
|----------|-------|------|---------|------------|------------------|
|[unread]  |book   |0     |zh-hans  |1087        |                  |
|----------|-------|------|---------|------------|------------------|

2020-11-25 10:19:19.914 INFO  jdbc.sqltiming Line:373 - select bookfieldf0_.entity_id as entity_i1_6_0_, bookfieldf0_.bundle as bundle2_6_0_, bookfieldf0_.delta 
as delta3_6_0_, bookfieldf0_.field_fenlei_target_id as field_fe4_6_0_, bookfieldf0_.langcode 
as langcode5_6_0_, bookfieldf0_.revision_id as revision6_6_0_ from node__field_fenlei bookfieldf0_ 
where bookfieldf0_.entity_id=1087 
 {executed in 0 msec}
2020-11-25 10:19:19.915 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|-----------------------|---------|------------|
|entity_id |bundle |delta |field_fenlei_target_id |langcode |revision_id |
|----------|-------|------|-----------------------|---------|------------|
|[unread]  |book   |0     |1                      |zh-hans  |1087        |
|----------|-------|------|-----------------------|---------|------------|

2020-11-25 10:19:19.917 INFO  jdbc.sqltiming Line:373 - select nodefieldf0_.entity_id as entity_i1_15_0_, nodefieldf0_.bundle as bundle2_15_0_, nodefieldf0_.delta 
as delta3_15_0_, nodefieldf0_.field_fenlei_target_id as field_fe4_15_0_, nodefieldf0_.langcode 
as langcode5_15_0_, nodefieldf0_.revision_id as revision6_15_0_ from node_revision__field_fenlei 
nodefieldf0_ where nodefieldf0_.entity_id=1087 
 {executed in 1 msec}
2020-11-25 10:19:19.917 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|-----------------------|---------|------------|
|entity_id |bundle |delta |field_fenlei_target_id |langcode |revision_id |
|----------|-------|------|-----------------------|---------|------------|
|[unread]  |book   |0     |1                      |zh-hans  |1087        |
|----------|-------|------|-----------------------|---------|------------|

2020-11-25 10:19:19.919 INFO  jdbc.sqltiming Line:373 - select bookchecke0_.item_id as item_id1_2_, bookchecke0_.fsid as fsid2_2_, bookchecke0_.got 
as got3_2_, bookchecke0_.name as name4_2_, bookchecke0_.parse_fail as parse_fa5_2_, bookchecke0_.parsed 
as parsed6_2_, bookchecke0_.path as path7_2_, bookchecke0_.title as title8_2_, bookchecke0_.vid 
as vid9_2_ from book_check bookchecke0_ where bookchecke0_.fsid='1437249222856' and bookchecke0_.name='net_content' 
 {executed in 0 msec}
2020-11-25 10:19:19.919 INFO  jdbc.resultsettable Line:610 - 
|--------|---------|---------|---------|-----------|---------|---------|---------|---------|
|item_id |fsid     |got      |name     |parse_fail |parsed   |path     |title    |vid      |
|--------|---------|---------|---------|-----------|---------|---------|---------|---------|
|1088    |[unread] |[unread] |[unread] |[unread]   |[unread] |[unread] |[unread] |[unread] |
|--------|---------|---------|---------|-----------|---------|---------|---------|---------|

2020-11-25 10:21:03.995 INFO  jdbc.sqltiming Line:373 - update book_check set fsid='1437249222856', got=1, name='net_content', parse_fail='', parsed=1, 
path='12-Linux性能优化实战/06-综合实战篇 (13讲)/55丨套路篇：分析性能问题的一般步骤.html', title='55丨套路篇：分析性能问题的一般步骤', vid=1088 
where item_id=1088 
 {executed in 1 msec}
2020-11-25 10:21:03.999 INFO  jdbc.sqltiming Line:373 - select nodebodyen0_.entity_id as entity_i1_4_, nodebodyen0_.body_value as body_val2_4_, nodebodyen0_.body_summary 
as body_sum3_4_, nodebodyen0_.bundle as bundle4_4_, nodebodyen0_.delta as delta5_4_, nodebodyen0_.body_format 
as body_for6_4_, nodebodyen0_.langcode as langcode7_4_, nodebodyen0_.revision_id as revision8_4_ 
from node__body nodebodyen0_ where nodebodyen0_.entity_id=1088 
 {executed in 0 msec}
2020-11-25 10:21:03.999 INFO  jdbc.resultsettable Line:610 - 
|----------|-----------|-------------|-------|------|------------|---------|------------|
|entity_id |body_value |body_summary |bundle |delta |body_format |langcode |revision_id |
|----------|-----------|-------------|-------|------|------------|---------|------------|
|1088      |           |             |book   |0     |full_html   |zh-hans  |1088        |
|----------|-----------|-------------|-------|------|------------|---------|------------|

2020-11-25 10:21:04.000 INFO  jdbc.sqltiming Line:373 - select nodebodyre0_.entity_id as entity_i1_13_0_, nodebodyre0_.body_value as body_val2_13_0_, 
nodebodyre0_.body_summary as body_sum3_13_0_, nodebodyre0_.bundle as bundle4_13_0_, nodebodyre0_.delta 
as delta5_13_0_, nodebodyre0_.body_format as body_for6_13_0_, nodebodyre0_.langcode as langcode7_13_0_, 
nodebodyre0_.revision_id as revision8_13_0_ from node_revision__body nodebodyre0_ where nodebodyre0_.entity_id=1088 
 {executed in 0 msec}
2020-11-25 10:21:04.001 INFO  jdbc.resultsettable Line:610 - 
|----------|-----------|-------------|-------|------|------------|---------|------------|
|entity_id |body_value |body_summary |bundle |delta |body_format |langcode |revision_id |
|----------|-----------|-------------|-------|------|------------|---------|------------|
|[unread]  |           |             |book   |0     |full_html   |zh-hans  |1088        |
|----------|-----------|-------------|-------|------|------------|---------|------------|

2020-11-25 10:21:04.002 INFO  jdbc.sqltiming Line:373 - update node__body set body_value='<p>你好，我是倪朋飞。</p> <p>上一节，我们一起学习了，应用程序监控的基本思路，先简单回顾一下。</p> 
<p>应用程序的监控，可以分为指标监控和日志监控两大块。</p> <ul> <li> <p>指标监控，主要是对一定时间段内的性能指标进行测量，然后再通过时间序列的方式，进行处理、存储和告警。</p> 
</li> <li> <p>而日志监控，则可以提供更详细的上下文信息，通常通过 ELK 技术栈，来进行收集、索引和图形化展示。</p> </li> </ul> <p>在跨多个不同应用的复杂业务场景中，你还可以构建全链路跟踪系统。这样，你就可以动态跟踪调用链中各个组件的性能，生成整个应用的调用拓扑图，从而加快定位复杂应用的性能问题。</p> 
<p>不过，如果你收到监控系统的告警，发现系统资源或者应用程序出现性能瓶颈，又该如何进一步分析它的根源呢？今天，我就分别从系统资源瓶颈和应用程序瓶颈这两个角度，带你一起来看看，性能分析的一般步骤。</p> 
<h2>系统资源瓶颈</h2> <p>首先来看系统资源的瓶颈，这也是最为常见的性能问题。</p> <p>在系统监控的综合思路篇中，我曾经介绍过，系统资源的瓶颈，可以通过 USE 法，即<strong>使用率、饱和度以及错误数这三类指标来衡量</strong>。系统的资源，可以分为硬件资源和软件资源两类。</p> 
<ul> <li> <p>如 CPU、内存、磁盘和文件系统以及网络等，都是最常见的硬件资源。</p> </li> <li> <p>而文件描述符数、连接跟踪数、套接字缓冲区大小等，则是典型的软件资源。</p> 
</li> </ul><!-- [[[read_end]]] --> <p>这样，在你收到监控系统告警时，就可以对照这些资源列表，再根据指标的不同来进行定位。</p> <p>实际上，咱们专栏前四大模块的核心，正是学会去分析这些资源瓶颈导致的性能问题。所以，当你碰到了系统资源的性能瓶颈时，前面模块的所有思路、方法以及工具，都完全可以照用。</p> 
<p>接下来，我就从 CPU 性能、内存性能、磁盘和文件系统 I/O 性能以及网络性能等四个方面，带你回顾一下它们的分析步骤。</p> <h3>CPU 性能分析</h3> <p>第一种最常见的系统资源是 
CPU。关于 CPU 的性能分析方法，我在<a href="https://time.geekbang.org/column/article/72685">如何迅速分析出系统 CPU 
的瓶颈</a>中，已经为你整理了一个迅速分析 CPU 性能瓶颈的思路。</p> <p>还记得这张图吗？利用 top、vmstat、pidstat、strace 以及 perf 等几个最常见的工具，获取 
CPU 性能指标后，再结合进程与 CPU 的工作原理，就可以迅速定位出 CPU 性能瓶颈的来源。</p> <p><img src="https://static001.geekbang.org/resource/image/23/cd/238ee65ac4c8e32ef4f96fb0ba8cb0cd.png" 
alt=""></p> <p>实际上，top、pidstat、vmstat 这类工具所汇报的 CPU 性能指标，都源自 /proc 文件系统（比如 /proc/loadavg、/proc/stat、/proc/softirqs 
等）。这些指标，都应该通过监控系统监控起来。虽然并非所有指标都需要报警，但这些指标却可以加快性能问题的定位分析。</p> <p>比如说，当你收到系统的用户 CPU 使用率过高告警时，从监控系统中直接查询到，导致 
CPU 使用率过高的进程；然后再登录到进程所在的 Linux 服务器中，分析该进程的行为。</p> <p>你可以使用 strace，查看进程的系统调用汇总；也可以使用 perf 等工具，找出进程的热点函数；甚至还可以使用动态追踪的方法，来观察进程的当前执行过程，直到确定瓶颈的根源。</p> 
<h3>内存性能分析</h3> <p>说完了 CPU 的性能分析，再来看看第二种系统资源，即内存。关于内存性能的分析方法，我在<a href="https://time.geekbang.org/column/article/76460">如何“快准狠”找到系统内存的问题</a>中，也已经为你整理了一个快速分析的思路。</p> 
<p>下面这张图，就是一个迅速定位内存瓶颈的流程。我们可以通过 free 和 vmstat 输出的性能指标，确认内存瓶颈；然后，再根据内存问题的类型，进一步分析内存的使用、分配、泄漏以及缓存等，最后找出问题的来源。</p> 
<p><img src="https://static001.geekbang.org/resource/image/29/98/292d64ac6bce0fe6a7a6b4250f34e998.png" 
alt=""></p> <p>同 CPU 性能一样，很多内存的性能指标，也来源于 /proc 文件系统（比如 /proc/meminfo、/proc/slabinfo 等），它们也都应该通过监控系统监控起来。这样，当你收到内存告警时，就可以从监控系统中，直接得到上图中的各项性能指标，从而加快性能问题的定位过程。</p> 
<p>比如说，当你收到内存不足的告警时，首先可以从监控系统中。找出占用内存最多的几个进程。然后，再根据这些进程的内存占用历史，观察是否存在内存泄漏问题。确定出最可疑的进程后，再登录到进程所在的 
Linux 服务器中，分析该进程的内存空间或者内存分配，最后弄清楚进程为什么会占用大量内存。</p> <h3>磁盘和文件系统 I/O 性能分析</h3> <p>接下来，我们再来看第三种系统资源，即磁盘和文件系统的 
I/O。关于磁盘和文件系统的 I/O 性能分析方法，我在<a href="https://time.geekbang.org/column/article/79001">如何迅速分析出系统 
I/O 的瓶颈</a>中也已经为你整理了一个快速分析的思路。</p> <p>我们来看下面这张图。当你使用 iostat ，发现磁盘 I/O 存在性能瓶颈（比如 I/O 使用率过高、响应时间过长或者等待队列长度突然增大等）后，可以再通过 
pidstat、 vmstat 等，确认 I/O 的来源。接着，再根据来源的不同，进一步分析文件系统和磁盘的使用率、缓存以及进程的 I/O 等，从而揪出 I/O 问题的真凶。</p> 
<p><img src="https://static001.geekbang.org/resource/image/e0/0b/e075287cff9b32ba3964746fdaf2960b.png" 
alt=""></p> <p>同 CPU 和内存性能类似，很多磁盘和文件系统的性能指标，也来源于 /proc 和 /sys 文件系统（比如 /proc/diskstats、/sys/block/sda/stat 
等）。自然，它们也应该通过监控系统监控起来。这样，当你收到 I/O 性能告警时，就可以从监控系统中，直接得到上图中的各项性能指标，从而加快性能定位的过程。</p> <p>比如说，当你发现某块磁盘的 
I/O 使用率为 100% 时，首先可以从监控系统中，找出 I/O 最多的进程。然后，再登录到进程所在的 Linux 服务器中，借助 strace、lsof、perf 等工具，分析该进程的 
I/O 行为。最后，再结合应用程序的原理，找出大量 I/O 的原因。</p> <h3>网络性能分析</h3> <p>最后的网络性能，其实包含两类资源，即网络接口和内核资源。在<a href="https://time.geekbang.org/column/article/83783">网络性能优化的几个思路</a>中，我也曾提到过，网络性能的分析，要从 
Linux 网络协议栈的原理来切入。下面这张图，就是 Linux 网络协议栈的基本原理，包括应用层、套机字接口、传输层、网络层以及链路层等。</p> <p><img src="https://static001.geekbang.org/resource/image/a1/3f/a118911721f9b67ce9c83de15666753f.png" 
alt=""></p> <p>而要分析网络的性能，自然也是要从这几个协议层入手，通过使用率、饱和度以及错误数这几类性能指标，观察是否存在性能问题。比如 ：</p> <ul> <li> 
<p>在链路层，可以从网络接口的吞吐量、丢包、错误以及软中断和网络功能卸载等角度分析；</p> </li> <li> <p>在网络层，可以从路由、分片、叠加网络等角度进行分析；</p> 
</li> <li> <p>在传输层，可以从 TCP、UDP 的协议原理出发，从连接数、吞吐量、延迟、重传等角度进行分析；</p> </li> <li> <p>在应用层，可以从应用层协议（如 
HTTP 和 DNS）、请求数（QPS）、套接字缓存等角度进行分析。</p> </li> </ul> <p>同前面几种资源类似，网络的性能指标也都来源于内核，包括 /proc 文件系统（如 
/proc/net）、网络接口以及 conntrack 等内核模块。这些指标同样需要被监控系统监控。这样，当你收到网络告警时，就可以从监控系统中，查询这些协议层的各项性能指标，从而更快定位出性能问题。</p> 
<p>比如，当你收到网络不通的告警时，就可以从监控系统中，查找各个协议层的丢包指标，确认丢包所在的协议层。然后，从监控系统的数据中，确认网络带宽、缓冲区、连接跟踪数等软硬件，是否存在性能瓶颈。最后，再登录到发生问题的 
Linux 服务器中，借助 netstat、tcpdump、bcc 等工具，分析网络的收发数据，并且结合内核中的网络选项以及 TCP 等网络协议的原理，找出问题的来源。</p> <h2>应用程序瓶颈</h2> 
<p>除了以上这些来自网络资源的瓶颈外，还有很多瓶颈，其实直接来自应用程序。比如，最典型的应用程序性能问题，就是吞吐量（并发请求数）下降、错误率升高以及响应时间增大。</p> <p>不过，在我看来，这些应用程序性能问题虽然各种各样，但就其本质来源，实际上只有三种，也就是资源瓶颈、依赖服务瓶颈以及应用自身的瓶颈。</p> 
<p>第一种资源瓶颈，其实还是指刚才提到的 CPU、内存、磁盘和文件系统 I/O、网络以及内核资源等各类软硬件资源出现了瓶颈，从而导致应用程序的运行受限。对于这种情况，我们就可以用前面系统资源瓶颈模块提到的各种方法来分析。</p> 
<p>第二种依赖服务的瓶颈，也就是诸如数据库、分布式缓存、中间件等应用程序，直接或者间接调用的服务出现了性能问题，从而导致应用程序的响应变慢，或者错误率升高。这说白了就是跨应用的性能问题，使用全链路跟踪系统，就可以帮你快速定位这类问题的根源。</p> 
<p>最后一种，应用程序自身的性能问题，包括了多线程处理不当、死锁、业务算法的复杂度过高等等。对于这类问题，在我们前面讲过的应用程序指标监控以及日志监控中，观察关键环节的耗时和内部执行过程中的错误，就可以帮你缩小问题的范围。</p> 
<p>不过，由于这是应用程序内部的状态，外部通常不能直接获取详细的性能数据，所以就需要应用程序在设计和开发时，就提供出这些指标，以便监控系统可以了解应用程序的内部运行状态。</p> 
<p>如果这些手段过后还是无法找出瓶颈，你还可以用系统资源模块提到的各类进程分析工具，来进行分析定位。比如：</p> <ul> <li> <p>你可以用 strace，观察系统调用；</p> 
</li> <li> <p>使用 perf 和火焰图，分析热点函数；</p> </li> <li> <p>甚至使用动态追踪技术，来分析进程的执行状态。</p> </li> </ul> 
<p>当然，系统资源和应用程序本来就是相互影响、相辅相成的一个整体。实际上，很多资源瓶颈，也是应用程序自身运行导致的。比如，进程的内存泄漏，会导致系统内存不足；进程过多的 I/O 请求，会拖慢整个系统的 
I/O 请求等。</p> <p>所以，很多情况下，资源瓶颈和应用自身瓶颈，其实都是同一个问题导致的，并不需要我们重复分析。</p> <h2>小结</h2> <p>今天，我带你从系统资源瓶颈和应用程序瓶颈这两个角度，梳理了性能问题分析的一般步骤。</p> 
<p>从系统资源瓶颈的角度来说，USE 法是最为有效的方法，即从使用率、饱和度以及错误数这三个方面，来分析 CPU、内存、磁盘和文件系统 I/O、网络以及内核资源限制等各类软硬件资源。关于这些资源的分析方法，我也带你一起回顾了咱们专栏前面几大模块的分析套路。</p> 
<p>从应用程序瓶颈的角度来说，我们可以把性能问题的来源，分为资源瓶颈、依赖服务瓶颈以及应用自身瓶颈这三类。</p> <ul> <li> <p>资源瓶颈跟系统资源瓶颈，本质是一样的。</p> 
</li> <li> <p>依赖服务瓶颈，你可以使用全链路跟踪系统进行定位。</p> </li> <li> <p>而应用自身的问题，你可以通过系统调用、热点函数，或者应用自身的指标监控以及日志监控等，进行分析定位。</p> 
</li> </ul> <p>值得注意的是，虽然我把瓶颈分为了系统和应用两个角度，但在实际运行时，这两者往往是相辅相成、相互影响的。<strong>系统是应用的运行环境，系统的瓶颈会导致应用的性能下降；而应用的不合理设计，也会引发系统资源的瓶颈</strong>。我们做性能分析，就是要结合应用程序和操作系统的原理，揪出引发问题的真凶。</p> 
<h2>思考</h2> <p>最后，我想邀请你一起来聊聊，你平时是怎么分析和定位性能问题的？有没有哪个印象深刻的经历可以跟我分享呢？你可以结合我的讲述，总结自己的思路。</p> <p>欢迎在留言区和我讨论，也欢迎把这篇文章分享给你的同事、朋友。我们一起在实战中演练，在交流中进步。</p> 
<p><img src="https://static001.geekbang.org/resource/image/a3/e9/a396aed4116c2c989771c1295736abe9.jpg" 
alt=""></p>', body_summary='', bundle='book', delta=0, body_format='full_html', langcode='zh-hans', 
revision_id=1088 where entity_id=1088 
 {executed in 0 msec}
2020-11-25 10:21:04.003 INFO  jdbc.sqltiming Line:373 - update node_revision__body set body_value='<p>你好，我是倪朋飞。</p> <p>上一节，我们一起学习了，应用程序监控的基本思路，先简单回顾一下。</p> 
<p>应用程序的监控，可以分为指标监控和日志监控两大块。</p> <ul> <li> <p>指标监控，主要是对一定时间段内的性能指标进行测量，然后再通过时间序列的方式，进行处理、存储和告警。</p> 
</li> <li> <p>而日志监控，则可以提供更详细的上下文信息，通常通过 ELK 技术栈，来进行收集、索引和图形化展示。</p> </li> </ul> <p>在跨多个不同应用的复杂业务场景中，你还可以构建全链路跟踪系统。这样，你就可以动态跟踪调用链中各个组件的性能，生成整个应用的调用拓扑图，从而加快定位复杂应用的性能问题。</p> 
<p>不过，如果你收到监控系统的告警，发现系统资源或者应用程序出现性能瓶颈，又该如何进一步分析它的根源呢？今天，我就分别从系统资源瓶颈和应用程序瓶颈这两个角度，带你一起来看看，性能分析的一般步骤。</p> 
<h2>系统资源瓶颈</h2> <p>首先来看系统资源的瓶颈，这也是最为常见的性能问题。</p> <p>在系统监控的综合思路篇中，我曾经介绍过，系统资源的瓶颈，可以通过 USE 法，即<strong>使用率、饱和度以及错误数这三类指标来衡量</strong>。系统的资源，可以分为硬件资源和软件资源两类。</p> 
<ul> <li> <p>如 CPU、内存、磁盘和文件系统以及网络等，都是最常见的硬件资源。</p> </li> <li> <p>而文件描述符数、连接跟踪数、套接字缓冲区大小等，则是典型的软件资源。</p> 
</li> </ul><!-- [[[read_end]]] --> <p>这样，在你收到监控系统告警时，就可以对照这些资源列表，再根据指标的不同来进行定位。</p> <p>实际上，咱们专栏前四大模块的核心，正是学会去分析这些资源瓶颈导致的性能问题。所以，当你碰到了系统资源的性能瓶颈时，前面模块的所有思路、方法以及工具，都完全可以照用。</p> 
<p>接下来，我就从 CPU 性能、内存性能、磁盘和文件系统 I/O 性能以及网络性能等四个方面，带你回顾一下它们的分析步骤。</p> <h3>CPU 性能分析</h3> <p>第一种最常见的系统资源是 
CPU。关于 CPU 的性能分析方法，我在<a href="https://time.geekbang.org/column/article/72685">如何迅速分析出系统 CPU 
的瓶颈</a>中，已经为你整理了一个迅速分析 CPU 性能瓶颈的思路。</p> <p>还记得这张图吗？利用 top、vmstat、pidstat、strace 以及 perf 等几个最常见的工具，获取 
CPU 性能指标后，再结合进程与 CPU 的工作原理，就可以迅速定位出 CPU 性能瓶颈的来源。</p> <p><img src="https://static001.geekbang.org/resource/image/23/cd/238ee65ac4c8e32ef4f96fb0ba8cb0cd.png" 
alt=""></p> <p>实际上，top、pidstat、vmstat 这类工具所汇报的 CPU 性能指标，都源自 /proc 文件系统（比如 /proc/loadavg、/proc/stat、/proc/softirqs 
等）。这些指标，都应该通过监控系统监控起来。虽然并非所有指标都需要报警，但这些指标却可以加快性能问题的定位分析。</p> <p>比如说，当你收到系统的用户 CPU 使用率过高告警时，从监控系统中直接查询到，导致 
CPU 使用率过高的进程；然后再登录到进程所在的 Linux 服务器中，分析该进程的行为。</p> <p>你可以使用 strace，查看进程的系统调用汇总；也可以使用 perf 等工具，找出进程的热点函数；甚至还可以使用动态追踪的方法，来观察进程的当前执行过程，直到确定瓶颈的根源。</p> 
<h3>内存性能分析</h3> <p>说完了 CPU 的性能分析，再来看看第二种系统资源，即内存。关于内存性能的分析方法，我在<a href="https://time.geekbang.org/column/article/76460">如何“快准狠”找到系统内存的问题</a>中，也已经为你整理了一个快速分析的思路。</p> 
<p>下面这张图，就是一个迅速定位内存瓶颈的流程。我们可以通过 free 和 vmstat 输出的性能指标，确认内存瓶颈；然后，再根据内存问题的类型，进一步分析内存的使用、分配、泄漏以及缓存等，最后找出问题的来源。</p> 
<p><img src="https://static001.geekbang.org/resource/image/29/98/292d64ac6bce0fe6a7a6b4250f34e998.png" 
alt=""></p> <p>同 CPU 性能一样，很多内存的性能指标，也来源于 /proc 文件系统（比如 /proc/meminfo、/proc/slabinfo 等），它们也都应该通过监控系统监控起来。这样，当你收到内存告警时，就可以从监控系统中，直接得到上图中的各项性能指标，从而加快性能问题的定位过程。</p> 
<p>比如说，当你收到内存不足的告警时，首先可以从监控系统中。找出占用内存最多的几个进程。然后，再根据这些进程的内存占用历史，观察是否存在内存泄漏问题。确定出最可疑的进程后，再登录到进程所在的 
Linux 服务器中，分析该进程的内存空间或者内存分配，最后弄清楚进程为什么会占用大量内存。</p> <h3>磁盘和文件系统 I/O 性能分析</h3> <p>接下来，我们再来看第三种系统资源，即磁盘和文件系统的 
I/O。关于磁盘和文件系统的 I/O 性能分析方法，我在<a href="https://time.geekbang.org/column/article/79001">如何迅速分析出系统 
I/O 的瓶颈</a>中也已经为你整理了一个快速分析的思路。</p> <p>我们来看下面这张图。当你使用 iostat ，发现磁盘 I/O 存在性能瓶颈（比如 I/O 使用率过高、响应时间过长或者等待队列长度突然增大等）后，可以再通过 
pidstat、 vmstat 等，确认 I/O 的来源。接着，再根据来源的不同，进一步分析文件系统和磁盘的使用率、缓存以及进程的 I/O 等，从而揪出 I/O 问题的真凶。</p> 
<p><img src="https://static001.geekbang.org/resource/image/e0/0b/e075287cff9b32ba3964746fdaf2960b.png" 
alt=""></p> <p>同 CPU 和内存性能类似，很多磁盘和文件系统的性能指标，也来源于 /proc 和 /sys 文件系统（比如 /proc/diskstats、/sys/block/sda/stat 
等）。自然，它们也应该通过监控系统监控起来。这样，当你收到 I/O 性能告警时，就可以从监控系统中，直接得到上图中的各项性能指标，从而加快性能定位的过程。</p> <p>比如说，当你发现某块磁盘的 
I/O 使用率为 100% 时，首先可以从监控系统中，找出 I/O 最多的进程。然后，再登录到进程所在的 Linux 服务器中，借助 strace、lsof、perf 等工具，分析该进程的 
I/O 行为。最后，再结合应用程序的原理，找出大量 I/O 的原因。</p> <h3>网络性能分析</h3> <p>最后的网络性能，其实包含两类资源，即网络接口和内核资源。在<a href="https://time.geekbang.org/column/article/83783">网络性能优化的几个思路</a>中，我也曾提到过，网络性能的分析，要从 
Linux 网络协议栈的原理来切入。下面这张图，就是 Linux 网络协议栈的基本原理，包括应用层、套机字接口、传输层、网络层以及链路层等。</p> <p><img src="https://static001.geekbang.org/resource/image/a1/3f/a118911721f9b67ce9c83de15666753f.png" 
alt=""></p> <p>而要分析网络的性能，自然也是要从这几个协议层入手，通过使用率、饱和度以及错误数这几类性能指标，观察是否存在性能问题。比如 ：</p> <ul> <li> 
<p>在链路层，可以从网络接口的吞吐量、丢包、错误以及软中断和网络功能卸载等角度分析；</p> </li> <li> <p>在网络层，可以从路由、分片、叠加网络等角度进行分析；</p> 
</li> <li> <p>在传输层，可以从 TCP、UDP 的协议原理出发，从连接数、吞吐量、延迟、重传等角度进行分析；</p> </li> <li> <p>在应用层，可以从应用层协议（如 
HTTP 和 DNS）、请求数（QPS）、套接字缓存等角度进行分析。</p> </li> </ul> <p>同前面几种资源类似，网络的性能指标也都来源于内核，包括 /proc 文件系统（如 
/proc/net）、网络接口以及 conntrack 等内核模块。这些指标同样需要被监控系统监控。这样，当你收到网络告警时，就可以从监控系统中，查询这些协议层的各项性能指标，从而更快定位出性能问题。</p> 
<p>比如，当你收到网络不通的告警时，就可以从监控系统中，查找各个协议层的丢包指标，确认丢包所在的协议层。然后，从监控系统的数据中，确认网络带宽、缓冲区、连接跟踪数等软硬件，是否存在性能瓶颈。最后，再登录到发生问题的 
Linux 服务器中，借助 netstat、tcpdump、bcc 等工具，分析网络的收发数据，并且结合内核中的网络选项以及 TCP 等网络协议的原理，找出问题的来源。</p> <h2>应用程序瓶颈</h2> 
<p>除了以上这些来自网络资源的瓶颈外，还有很多瓶颈，其实直接来自应用程序。比如，最典型的应用程序性能问题，就是吞吐量（并发请求数）下降、错误率升高以及响应时间增大。</p> <p>不过，在我看来，这些应用程序性能问题虽然各种各样，但就其本质来源，实际上只有三种，也就是资源瓶颈、依赖服务瓶颈以及应用自身的瓶颈。</p> 
<p>第一种资源瓶颈，其实还是指刚才提到的 CPU、内存、磁盘和文件系统 I/O、网络以及内核资源等各类软硬件资源出现了瓶颈，从而导致应用程序的运行受限。对于这种情况，我们就可以用前面系统资源瓶颈模块提到的各种方法来分析。</p> 
<p>第二种依赖服务的瓶颈，也就是诸如数据库、分布式缓存、中间件等应用程序，直接或者间接调用的服务出现了性能问题，从而导致应用程序的响应变慢，或者错误率升高。这说白了就是跨应用的性能问题，使用全链路跟踪系统，就可以帮你快速定位这类问题的根源。</p> 
<p>最后一种，应用程序自身的性能问题，包括了多线程处理不当、死锁、业务算法的复杂度过高等等。对于这类问题，在我们前面讲过的应用程序指标监控以及日志监控中，观察关键环节的耗时和内部执行过程中的错误，就可以帮你缩小问题的范围。</p> 
<p>不过，由于这是应用程序内部的状态，外部通常不能直接获取详细的性能数据，所以就需要应用程序在设计和开发时，就提供出这些指标，以便监控系统可以了解应用程序的内部运行状态。</p> 
<p>如果这些手段过后还是无法找出瓶颈，你还可以用系统资源模块提到的各类进程分析工具，来进行分析定位。比如：</p> <ul> <li> <p>你可以用 strace，观察系统调用；</p> 
</li> <li> <p>使用 perf 和火焰图，分析热点函数；</p> </li> <li> <p>甚至使用动态追踪技术，来分析进程的执行状态。</p> </li> </ul> 
<p>当然，系统资源和应用程序本来就是相互影响、相辅相成的一个整体。实际上，很多资源瓶颈，也是应用程序自身运行导致的。比如，进程的内存泄漏，会导致系统内存不足；进程过多的 I/O 请求，会拖慢整个系统的 
I/O 请求等。</p> <p>所以，很多情况下，资源瓶颈和应用自身瓶颈，其实都是同一个问题导致的，并不需要我们重复分析。</p> <h2>小结</h2> <p>今天，我带你从系统资源瓶颈和应用程序瓶颈这两个角度，梳理了性能问题分析的一般步骤。</p> 
<p>从系统资源瓶颈的角度来说，USE 法是最为有效的方法，即从使用率、饱和度以及错误数这三个方面，来分析 CPU、内存、磁盘和文件系统 I/O、网络以及内核资源限制等各类软硬件资源。关于这些资源的分析方法，我也带你一起回顾了咱们专栏前面几大模块的分析套路。</p> 
<p>从应用程序瓶颈的角度来说，我们可以把性能问题的来源，分为资源瓶颈、依赖服务瓶颈以及应用自身瓶颈这三类。</p> <ul> <li> <p>资源瓶颈跟系统资源瓶颈，本质是一样的。</p> 
</li> <li> <p>依赖服务瓶颈，你可以使用全链路跟踪系统进行定位。</p> </li> <li> <p>而应用自身的问题，你可以通过系统调用、热点函数，或者应用自身的指标监控以及日志监控等，进行分析定位。</p> 
</li> </ul> <p>值得注意的是，虽然我把瓶颈分为了系统和应用两个角度，但在实际运行时，这两者往往是相辅相成、相互影响的。<strong>系统是应用的运行环境，系统的瓶颈会导致应用的性能下降；而应用的不合理设计，也会引发系统资源的瓶颈</strong>。我们做性能分析，就是要结合应用程序和操作系统的原理，揪出引发问题的真凶。</p> 
<h2>思考</h2> <p>最后，我想邀请你一起来聊聊，你平时是怎么分析和定位性能问题的？有没有哪个印象深刻的经历可以跟我分享呢？你可以结合我的讲述，总结自己的思路。</p> <p>欢迎在留言区和我讨论，也欢迎把这篇文章分享给你的同事、朋友。我们一起在实战中演练，在交流中进步。</p> 
<p><img src="https://static001.geekbang.org/resource/image/a3/e9/a396aed4116c2c989771c1295736abe9.jpg" 
alt=""></p>', body_summary='', bundle='book', delta=0, body_format='full_html', langcode='zh-hans', 
revision_id=1088 where entity_id=1088 
 {executed in 0 msec}
2020-11-25 10:21:04.008 INFO  jdbc.sqltiming Line:373 - select nodefiledd0_.nid as nid1_10_, nodefiledd0_.changed as changed2_10_, nodefiledd0_.created 
as created3_10_, nodefiledd0_.default_langcode as default_4_10_, nodefiledd0_.langcode as langcode5_10_, 
nodefiledd0_.promote as promote6_10_, nodefiledd0_.revision_translation_affected as revision7_10_, 
nodefiledd0_.status as status8_10_, nodefiledd0_.sticky as sticky9_10_, nodefiledd0_.title 
as title10_10_, nodefiledd0_.type as type11_10_, nodefiledd0_.uid as uid12_10_, nodefiledd0_.vid 
as vid13_10_ from node_field_data nodefiledd0_ where nodefiledd0_.nid=1088 
 {executed in 0 msec}
2020-11-25 10:21:04.009 INFO  jdbc.resultsettable Line:610 - 
|-----|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|-------------------|-----|----|-----|
|nid  |changed    |created    |default_langcode |langcode |promote |revision_translation_affected |status |sticky |title              |type |uid |vid  |
|-----|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|-------------------|-----|----|-----|
|1088 |1606115009 |1606115009 |1                |zh-hans  |0       |1                             |1      |0      |55丨套路篇：分析性能问题的一般步骤 |book |1   |1088 |
|-----|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|-------------------|-----|----|-----|

2020-11-25 10:21:04.009 INFO  jdbc.sqltiming Line:373 - select nodefieldr0_.nid as nid1_11_0_, nodefieldr0_.changed as changed2_11_0_, nodefieldr0_.created 
as created3_11_0_, nodefieldr0_.default_langcode as default_4_11_0_, nodefieldr0_.langcode 
as langcode5_11_0_, nodefieldr0_.promote as promote6_11_0_, nodefieldr0_.revision_translation_affected 
as revision7_11_0_, nodefieldr0_.status as status8_11_0_, nodefieldr0_.sticky as sticky9_11_0_, 
nodefieldr0_.title as title10_11_0_, nodefieldr0_.uid as uid11_11_0_, nodefieldr0_.vid as vid12_11_0_ 
from node_field_revision nodefieldr0_ where nodefieldr0_.nid=1088 
 {executed in 0 msec}
2020-11-25 10:21:04.010 INFO  jdbc.resultsettable Line:610 - 
|---------|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|-------------------|----|-----|
|nid      |changed    |created    |default_langcode |langcode |promote |revision_translation_affected |status |sticky |title              |uid |vid  |
|---------|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|-------------------|----|-----|
|[unread] |1606115009 |1606115009 |1                |zh-hans  |0       |1                             |1      |0      |55丨套路篇：分析性能问题的一般步骤 |1   |1088 |
|---------|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|-------------------|----|-----|

2020-11-25 10:21:04.011 INFO  jdbc.sqltiming Line:373 - update node_field_data set changed=1606270864, created=1606270864, default_langcode=1, langcode='zh-hans', 
promote=0, revision_translation_affected=1, status=1, sticky=0, title='55丨套路篇：分析性能问题的一般步骤', 
type='book', uid=1, vid=1088 where nid=1088 
 {executed in 0 msec}
2020-11-25 10:21:04.011 INFO  jdbc.sqltiming Line:373 - update node_field_revision set changed=1606270864, created=1606270864, default_langcode=1, 
langcode='zh-hans', promote=0, revision_translation_affected=1, status=1, sticky=0, title='55丨套路篇：分析性能问题的一般步骤', 
uid=1, vid=1088 where nid=1088 
 {executed in 0 msec}
2020-11-25 10:21:04.016 INFO  jdbc.sqltiming Line:373 - select bookfieldm0_.entity_id as entity_i1_8_, bookfieldm0_.bundle as bundle2_8_, bookfieldm0_.delta 
as delta3_8_, bookfieldm0_.langcode as langcode4_8_, bookfieldm0_.field_media_value as field_me5_8_, 
bookfieldm0_.revision_id as revision6_8_ from node__field_media bookfieldm0_ where bookfieldm0_.entity_id=1088 
 {executed in 0 msec}
2020-11-25 10:21:04.017 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------------|------------|
|entity_id |bundle |delta |langcode |field_media_value |revision_id |
|----------|-------|------|---------|------------------|------------|
|1088      |book   |0     |zh-hans  |                  |1088        |
|----------|-------|------|---------|------------------|------------|

2020-11-25 10:21:04.018 INFO  jdbc.sqltiming Line:373 - select nodefieldm0_.entity_id as entity_i1_17_0_, nodefieldm0_.bundle as bundle2_17_0_, nodefieldm0_.delta 
as delta3_17_0_, nodefieldm0_.langcode as langcode4_17_0_, nodefieldm0_.field_media_value as 
field_me5_17_0_, nodefieldm0_.revision_id as revision6_17_0_ from node_revision__field_media 
nodefieldm0_ where nodefieldm0_.entity_id=1088 
 {executed in 0 msec}
2020-11-25 10:21:04.019 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------------|------------|
|entity_id |bundle |delta |langcode |field_media_value |revision_id |
|----------|-------|------|---------|------------------|------------|
|[unread]  |book   |0     |zh-hans  |                  |1088        |
|----------|-------|------|---------|------------------|------------|

2020-11-25 10:21:04.020 INFO  jdbc.sqltiming Line:373 - select bookfieldc0_.entity_id as entity_i1_5_, bookfieldc0_.bundle as bundle2_5_, bookfieldc0_.field_comment_value 
as field_co3_5_, bookfieldc0_.delta as delta4_5_, bookfieldc0_.field_comment_format as field_co5_5_, 
bookfieldc0_.langcode as langcode6_5_, bookfieldc0_.revision_id as revision7_5_ from node__field_comment 
bookfieldc0_ where bookfieldc0_.entity_id=1088 
 {executed in 0 msec}
2020-11-25 10:21:04.021 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|--------------------|------|---------------------|---------|------------|
|entity_id |bundle |field_comment_value |delta |field_comment_format |langcode |revision_id |
|----------|-------|--------------------|------|---------------------|---------|------------|
|1088      |book   |                    |0     |full_html            |zh-hans  |1088        |
|----------|-------|--------------------|------|---------------------|---------|------------|

2020-11-25 10:21:04.022 INFO  jdbc.sqltiming Line:373 - update node__field_comment set bundle='book', field_comment_value='<li class="reJj6Thl_0"><img 
src="https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>我来也</span> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2019-04-03 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> </div> <!----> 
<!----> </div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> [D55打卡] <br>集合了各模块套路的套路篇，哈哈。 </div> 
<!----> <!----> </div></li> <li class="reJj6Thl_0"><img src="https://wx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEKQMM4m7NHuicr55aRiblTSEWIYe0QqbpyHweaoAbG7j2v7UUElqqeP3Ihrm3UfDPDRb1Hv8LvPwXqA/132" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>ninuxer</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-04-03 </div> </div> <div 
class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> 
</div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 打卡day59 <br>本篇内容综合了之前的几大块的套路～ 
</div> <!----> <!----> </div></li> <li class="reJj6Thl_0"><img src="" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>如果</span> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2019-04-23 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> DAY55，打卡 </div> <div class="_2r3UB1GX_0"> <span>展开</span><i 
class="iconfont"></i> </div> <!----> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/14/3d/77/45e5e06d.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>胡鹏</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-04-07 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> 平时用php的xhprof,或是go的prof图，分析代码性能， </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 
👍谢谢分享</p> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/10/2e/72/145c10db.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>每日都想上...</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-04-05 </div> </div> <div 
class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> 
</div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0"> 喜欢老师的讲解 </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <!----> </div></li> <li class="reJj6Thl_0"><img 
src="https://static001.geekbang.org/account/avatar/00/0f/a3/25/484d39bb.jpg" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>coyang</span> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2019-04-03 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> 非常喜欢倪老师的专栏，期待下一部分实战演练。 </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <!----> </div></li>', delta=0, field_comment_format='full_html', 
langcode='zh-hans', revision_id=1088 where entity_id=1088 
 {executed in 0 msec}
2020-11-25 10:21:04.026 INFO  jdbc.sqltiming Line:373 - select nodefieldc0_.entity_id as entity_i1_14_0_, nodefieldc0_.bundle as bundle2_14_0_, nodefieldc0_.field_comment_value 
as field_co3_14_0_, nodefieldc0_.delta as delta4_14_0_, nodefieldc0_.field_comment_format as 
field_co5_14_0_, nodefieldc0_.langcode as langcode6_14_0_, nodefieldc0_.revision_id as revision7_14_0_ 
from node_revision__field_comment nodefieldc0_ where nodefieldc0_.entity_id=1088 
 {executed in 0 msec}
2020-11-25 10:21:04.027 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|--------------------|------|---------------------|---------|------------|
|entity_id |bundle |field_comment_value |delta |field_comment_format |langcode |revision_id |
|----------|-------|--------------------|------|---------------------|---------|------------|
|[unread]  |book   |                    |0     |full_html            |zh-hans  |1088        |
|----------|-------|--------------------|------|---------------------|---------|------------|

2020-11-25 10:21:04.028 INFO  jdbc.sqltiming Line:373 - update node_revision__field_comment set bundle='book', field_comment_value='<li class="reJj6Thl_0"><img 
src="https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>我来也</span> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2019-04-03 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> </div> <!----> 
<!----> </div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> [D55打卡] <br>集合了各模块套路的套路篇，哈哈。 </div> 
<!----> <!----> </div></li> <li class="reJj6Thl_0"><img src="https://wx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEKQMM4m7NHuicr55aRiblTSEWIYe0QqbpyHweaoAbG7j2v7UUElqqeP3Ihrm3UfDPDRb1Hv8LvPwXqA/132" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>ninuxer</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-04-03 </div> </div> <div 
class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> 
</div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 打卡day59 <br>本篇内容综合了之前的几大块的套路～ 
</div> <!----> <!----> </div></li> <li class="reJj6Thl_0"><img src="" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>如果</span> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2019-04-23 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> DAY55，打卡 </div> <div class="_2r3UB1GX_0"> <span>展开</span><i 
class="iconfont"></i> </div> <!----> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/14/3d/77/45e5e06d.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>胡鹏</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-04-07 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> 平时用php的xhprof,或是go的prof图，分析代码性能， </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 
👍谢谢分享</p> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/10/2e/72/145c10db.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>每日都想上...</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-04-05 </div> </div> <div 
class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> 
</div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0"> 喜欢老师的讲解 </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <!----> </div></li> <li class="reJj6Thl_0"><img 
src="https://static001.geekbang.org/account/avatar/00/0f/a3/25/484d39bb.jpg" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>coyang</span> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2019-04-03 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> 非常喜欢倪老师的专栏，期待下一部分实战演练。 </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <!----> </div></li>', delta=0, field_comment_format='full_html', 
langcode='zh-hans', revision_id=1088 where entity_id=1088 
 {executed in 0 msec}
2020-11-25 10:21:04.032 INFO  jdbc.sqltiming Line:373 - select bookfieldt0_.entity_id as entity_i1_9_, bookfieldt0_.bundle as bundle2_9_, bookfieldt0_.delta 
as delta3_9_, bookfieldt0_.langcode as langcode4_9_, bookfieldt0_.revision_id as revision5_9_, 
bookfieldt0_.field_thumb_value as field_th6_9_ from node__field_thumb bookfieldt0_ where bookfieldt0_.entity_id=1088 
 {executed in 0 msec}
2020-11-25 10:21:04.032 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------|------------------|
|entity_id |bundle |delta |langcode |revision_id |field_thumb_value |
|----------|-------|------|---------|------------|------------------|
|1088      |book   |0     |zh-hans  |1088        |                  |
|----------|-------|------|---------|------------|------------------|

2020-11-25 10:21:04.034 INFO  jdbc.sqltiming Line:373 - update node__field_thumb set bundle='book', delta=0, langcode='zh-hans', revision_id=1088, 
field_thumb_value='https://static001.geekbang.org/resource/image/cf/0f/cfabc5ca733944869e2a3f8b0b00d30f.jpg' 
where entity_id=1088 
 {executed in 0 msec}
2020-11-25 10:21:04.038 INFO  jdbc.sqltiming Line:373 - select nodefieldt0_.entity_id as entity_i1_18_0_, nodefieldt0_.bundle as bundle2_18_0_, nodefieldt0_.delta 
as delta3_18_0_, nodefieldt0_.langcode as langcode4_18_0_, nodefieldt0_.revision_id as revision5_18_0_, 
nodefieldt0_.field_thumb_value as field_th6_18_0_ from node_revision__field_thumb nodefieldt0_ 
where nodefieldt0_.entity_id=1088 
 {executed in 1 msec}
2020-11-25 10:21:04.038 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------|------------------|
|entity_id |bundle |delta |langcode |revision_id |field_thumb_value |
|----------|-------|------|---------|------------|------------------|
|[unread]  |book   |0     |zh-hans  |1088        |                  |
|----------|-------|------|---------|------------|------------------|

2020-11-25 10:21:04.039 INFO  jdbc.sqltiming Line:373 - update node_revision__field_thumb set bundle='book', delta=0, langcode='zh-hans', revision_id=1088, 
field_thumb_value='https://static001.geekbang.org/resource/image/cf/0f/cfabc5ca733944869e2a3f8b0b00d30f.jpg' 
where entity_id=1088 
 {executed in 0 msec}
2020-11-25 10:21:04.043 INFO  jdbc.sqltiming Line:373 - select bookfieldf0_.entity_id as entity_i1_6_0_, bookfieldf0_.bundle as bundle2_6_0_, bookfieldf0_.delta 
as delta3_6_0_, bookfieldf0_.field_fenlei_target_id as field_fe4_6_0_, bookfieldf0_.langcode 
as langcode5_6_0_, bookfieldf0_.revision_id as revision6_6_0_ from node__field_fenlei bookfieldf0_ 
where bookfieldf0_.entity_id=1088 
 {executed in 0 msec}
2020-11-25 10:21:04.043 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|-----------------------|---------|------------|
|entity_id |bundle |delta |field_fenlei_target_id |langcode |revision_id |
|----------|-------|------|-----------------------|---------|------------|
|[unread]  |book   |0     |1                      |zh-hans  |1088        |
|----------|-------|------|-----------------------|---------|------------|

2020-11-25 10:21:04.045 INFO  jdbc.sqltiming Line:373 - select nodefieldf0_.entity_id as entity_i1_15_0_, nodefieldf0_.bundle as bundle2_15_0_, nodefieldf0_.delta 
as delta3_15_0_, nodefieldf0_.field_fenlei_target_id as field_fe4_15_0_, nodefieldf0_.langcode 
as langcode5_15_0_, nodefieldf0_.revision_id as revision6_15_0_ from node_revision__field_fenlei 
nodefieldf0_ where nodefieldf0_.entity_id=1088 
 {executed in 0 msec}
2020-11-25 10:21:04.045 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|-----------------------|---------|------------|
|entity_id |bundle |delta |field_fenlei_target_id |langcode |revision_id |
|----------|-------|------|-----------------------|---------|------------|
|[unread]  |book   |0     |1                      |zh-hans  |1088        |
|----------|-------|------|-----------------------|---------|------------|

2020-11-25 10:21:04.047 INFO  jdbc.sqltiming Line:373 - select bookchecke0_.item_id as item_id1_2_, bookchecke0_.fsid as fsid2_2_, bookchecke0_.got 
as got3_2_, bookchecke0_.name as name4_2_, bookchecke0_.parse_fail as parse_fa5_2_, bookchecke0_.parsed 
as parsed6_2_, bookchecke0_.path as path7_2_, bookchecke0_.title as title8_2_, bookchecke0_.vid 
as vid9_2_ from book_check bookchecke0_ where bookchecke0_.fsid='691728719222792' and bookchecke0_.name='net_content' 
 {executed in 0 msec}
2020-11-25 10:21:04.047 INFO  jdbc.resultsettable Line:610 - 
|--------|---------|---------|---------|-----------|---------|---------|---------|---------|
|item_id |fsid     |got      |name     |parse_fail |parsed   |path     |title    |vid      |
|--------|---------|---------|---------|-----------|---------|---------|---------|---------|
|1089    |[unread] |[unread] |[unread] |[unread]   |[unread] |[unread] |[unread] |[unread] |
|--------|---------|---------|---------|-----------|---------|---------|---------|---------|

2020-11-25 10:21:10.743 INFO  jdbc.sqltiming Line:373 - update book_check set fsid='691728719222792', got=1, name='net_content', parse_fail='', parsed=1, 
path='12-Linux性能优化实战/06-综合实战篇 (13讲)/56丨套路篇：优化性能问题的一般方法.html', title='56丨套路篇：优化性能问题的一般方法', vid=1089 
where item_id=1089 
 {executed in 0 msec}
2020-11-25 10:21:10.750 INFO  jdbc.sqltiming Line:373 - select nodebodyen0_.entity_id as entity_i1_4_, nodebodyen0_.body_value as body_val2_4_, nodebodyen0_.body_summary 
as body_sum3_4_, nodebodyen0_.bundle as bundle4_4_, nodebodyen0_.delta as delta5_4_, nodebodyen0_.body_format 
as body_for6_4_, nodebodyen0_.langcode as langcode7_4_, nodebodyen0_.revision_id as revision8_4_ 
from node__body nodebodyen0_ where nodebodyen0_.entity_id=1089 
 {executed in 0 msec}
2020-11-25 10:21:10.751 INFO  jdbc.resultsettable Line:610 - 
|----------|-----------|-------------|-------|------|------------|---------|------------|
|entity_id |body_value |body_summary |bundle |delta |body_format |langcode |revision_id |
|----------|-----------|-------------|-------|------|------------|---------|------------|
|1089      |           |             |book   |0     |full_html   |zh-hans  |1089        |
|----------|-----------|-------------|-------|------|------------|---------|------------|

2020-11-25 10:21:10.751 INFO  jdbc.sqltiming Line:373 - select nodebodyre0_.entity_id as entity_i1_13_0_, nodebodyre0_.body_value as body_val2_13_0_, 
nodebodyre0_.body_summary as body_sum3_13_0_, nodebodyre0_.bundle as bundle4_13_0_, nodebodyre0_.delta 
as delta5_13_0_, nodebodyre0_.body_format as body_for6_13_0_, nodebodyre0_.langcode as langcode7_13_0_, 
nodebodyre0_.revision_id as revision8_13_0_ from node_revision__body nodebodyre0_ where nodebodyre0_.entity_id=1089 
 {executed in 0 msec}
2020-11-25 10:21:10.752 INFO  jdbc.resultsettable Line:610 - 
|----------|-----------|-------------|-------|------|------------|---------|------------|
|entity_id |body_value |body_summary |bundle |delta |body_format |langcode |revision_id |
|----------|-----------|-------------|-------|------|------------|---------|------------|
|[unread]  |           |             |book   |0     |full_html   |zh-hans  |1089        |
|----------|-----------|-------------|-------|------|------------|---------|------------|

2020-11-25 10:21:10.754 INFO  jdbc.sqltiming Line:373 - update node__body set body_value='<p>你好，我是倪朋飞。</p> <p>上一节，我带你一起梳理了，性能问题分析的一般步骤。先带你简单回顾一下。</p> 
<p>我们可以从系统资源瓶颈和应用程序瓶颈，这两个角度来分析性能问题的根源。</p> <p>从系统资源瓶颈的角度来说，USE 法是最为有效的方法，即从使用率、饱和度以及错误数这三个方面，来分析 
CPU、内存、磁盘和文件系统 I/O、网络以及内核资源限制等各类软硬件资源。至于这些资源的分析方法，我也带你一起回顾了，咱们专栏前面几大模块的分析套路。</p> <p>从应用程序瓶颈的角度来说，可以把性能问题的来源，分为资源瓶颈、依赖服务瓶颈以及应用自身的瓶颈这三类。</p> 
<ul> <li> <p>资源瓶颈的分析思路，跟系统资源瓶颈是一样的。</p> </li> <li> <p>依赖服务的瓶颈，可以使用全链路跟踪系统，进行快速定位。</p> </li> 
<li> <p>而应用自身的问题，则可以通过系统调用、热点函数，或者应用自身的指标和日志等，进行分析定位。</p> </li> </ul> <p>当然，虽然系统和应用是两个不同的角度，但在实际运行时，它们往往相辅相成、相互影响。</p> 
<ul> <li> <p>系统是应用的运行环境，系统瓶颈会导致应用的性能下降。</p> </li> <li> <p>而应用程序不合理的设计，也会引发系统资源的瓶颈。</p> </li> 
</ul> <p>我们做性能分析，就是要结合应用程序和操作系统的原理，揪出引发问题的“真凶“。</p> <p>找到性能问题的来源后，整个优化工作其实也就完成了一大半，因为这些瓶颈为我们指明了优化的方向。不过，对于性能优化来说，又有哪些常见的方法呢？</p><!-- 
[[[read_end]]] --> <p>今天，我就带你一起来看看，性能优化的一般方法。同上一节的性能分析一样，我们也可以从系统和应用程序，这两个不同的角度来进行性能优化。</p> 
<h2>系统优化</h2> <p>首先来看系统的优化。在上一节，我曾经介绍过，USE 法可以用来分析系统软硬件资源的瓶颈，那么，相对应的优化方法，当然也是从这些资源瓶颈入手。</p> 
<p>实际上，咱们专栏的前四个模块，除了最核心的系统资源瓶颈分析之外，也已经包含了这些常见资源瓶颈的优化方法。</p> <p>接下来，我就从 CPU 性能、内存性能、磁盘和文件系统 
I/O 性能以及网络性能等四个方面，带你回顾一下它们的优化方法。</p> <h3>CPU 优化</h3> <p>首先来看 CPU 性能的优化方法。在<a href="https://time.geekbang.org/column/article/73151">CPU 
性能优化的几个思路</a>中，我曾经介绍过，<strong>CPU 性能优化的核心，在于排除所有不必要的工作、充分利用 CPU 缓存并减少进程调度对性能的影响。</strong></p> 
<p>从这几个方面出发，我相信你已经想到了很多的优化方法。这里，我主要强调一下，最典型的三种优化方法。</p> <ul> <li> <p>第一种，把进程绑定到一个或者多个 CPU 上，充分利用 
CPU 缓存的本地性，并减少进程间的相互影响。</p> </li> <li> <p>第二种，为中断处理程序开启多 CPU 负载均衡，以便在发生大量中断时，可以充分利用多 CPU 的优势分摊负载。</p> 
</li> <li> <p>第三种，使用 Cgroups 等方法，为进程设置资源限制，避免个别进程消耗过多的 CPU。同时，为核心应用程序设置更高的优先级，减少低优先级任务的影响。</p> 
</li> </ul> <h3>内存优化</h3> <p>说完了 CPU 的性能优化，我们再来看看，怎么优化内存的性能。在<a href="https://time.geekbang.org/column/article/76460">如何“快准狠”找到系统内存的问题</a>中，我曾经为你梳理了常见的一些内存问题，比如可用内存不足、内存泄漏、Swap 
过多、缺页异常过多以及缓存过多等等。所以，说白了，内存性能的优化，也就是要解决这些内存使用的问题。</p> <p>在我看来，你可以通过以下几种方法，来优化内存的性能。</p> <ul> 
<li> <p>第一种，除非有必要，Swap 应该禁止掉。这样就可以避免 Swap 的额外 I/O ，带来内存访问变慢的问题。</p> </li> <li> <p>第二种，使用 Cgroups 
等方法，为进程设置内存限制。这样就可以避免个别进程消耗过多内存，而影响了其他进程。对于核心应用，还应该降低 oom_score，避免被 OOM 杀死。</p> </li> <li> 
<p>第三种，使用大页、内存池等方法，减少内存的动态分配，从而减少缺页异常。</p> </li> </ul> <h3>磁盘和文件系统 I/O 优化</h3> <p>接下来，我们再来看第三类系统资源，即磁盘和文件系统 
I/O 的优化方法。在<a href="https://time.geekbang.org/column/article/79368">磁盘 I/O 性能优化的几个思路</a> 中，我已经为你梳理了一些常见的优化思路，这其中有三种最典型的方法。</p> 
<ul> <li> <p>第一种，也是最简单的方法，通过 SSD 替代 HDD、或者使用 RAID 等方法，提升 I/O 性能。</p> </li> <li> <p>第二种，针对磁盘和应用程序 
I/O 模式的特征，选择最适合的 I/O 调度算法。比如，SSD 和虚拟机中的磁盘，通常用的是 noop 调度算法；而数据库应用，更推荐使用 deadline 算法。</p> </li> 
<li> <p>第三，优化文件系统和磁盘的缓存、缓冲区，比如优化脏页的刷新频率、脏页限额，以及内核回收目录项缓存和索引节点缓存的倾向等等。</p> </li> </ul> <p>除此之外，使用不同磁盘隔离不同应用的数据、优化文件系统的配置选项、优化磁盘预读、增大磁盘队列长度等，也都是常用的优化思路。</p> 
<h3>网络优化</h3> <p>最后一个是网络的性能优化。在<a href="https://time.geekbang.org/column/article/83783">网络性能优化的几个思路</a>中，我也已经为你梳理了一些常见的优化思路。这些优化方法都是从 
Linux 的网络协议栈出发，针对每个协议层的工作原理进行优化。这里，我同样强调一下，最典型的几种网络优化方法。</p> <p>首先，从内核资源和网络协议的角度来说，我们可以对内核选项进行优化，比如：</p> 
<ul> <li> <p>你可以增大套接字缓冲区、连接跟踪表、最大半连接数、最大文件描述符数、本地端口范围等内核资源配额；</p> </li> <li> <p>也可以减少 TIMEOUT 
超时时间、SYN+ACK 重传数、Keepalive 探测时间等异常处理参数；</p> </li> <li> <p>还可以开启端口复用、反向地址校验，并调整 MTU 大小等降低内核的负担。</p> 
</li> </ul> <p>这些都是内核选项优化的最常见措施。</p> <p>其次，从网络接口的角度来说，我们可以考虑对网络接口的功能进行优化，比如：</p> <ul> <li> 
<p>你可以将原来 CPU 上执行的工作，卸载到网卡中执行，即开启网卡的 GRO、GSO、RSS、VXLAN 等卸载功能；</p> </li> <li> <p>也可以开启网络接口的多队列功能，这样，每个队列就可以用不同的中断号，调度到不同 
CPU 上执行；</p> </li> <li> <p>还可以增大网络接口的缓冲区大小以及队列长度等，提升网络传输的吞吐量。</p> </li> </ul> <p>最后，在极限性能情况（比如 
C10M）下，内核的网络协议栈可能是最主要的性能瓶颈，所以，一般会考虑绕过内核协议栈。</p> <ul> <li> <p>你可以使用 DPDK 技术，跳过内核协议栈，直接由用户态进程用轮询的方式，来处理网络请求。同时，再结合大页、CPU 
绑定、内存对齐、流水线并发等多种机制，优化网络包的处理效率。</p> </li> <li> <p>你还可以使用内核自带的 XDP 技术，在网络包进入内核协议栈前，就对其进行处理。这样，也可以达到目的，获得很好的性能。</p> 
</li> </ul> <h2>应用程序优化</h2> <p>说完了系统软硬件资源的优化，接下来，我们再来看看应用程序的优化思路。</p> <p>虽然系统的软硬件资源，是保证应用程序正常运行的基础，但你要知道，<strong>性能优化的最佳位置，还是应用程序内部</strong>。为什么这么说呢？我简单举两个例子你就明白了。</p> 
<p>第一个例子，是系统 CPU 使用率（sys%）过高的问题。有时候出现问题，虽然表面现象是系统 CPU 使用率过高，但待你分析过后，很可能会发现，应用程序的不合理系统调用才是罪魁祸首。这种情况下，优化应用程序内部系统调用的逻辑，显然要比优化内核要简单也有用得多。</p> 
<p>再比如说，数据库的 CPU 使用率高、I/O 响应慢，也是最常见的一种性能问题。这种问题，一般来说，并不是因为数据库本身性能不好，而是应用程序不合理的表结构或者 SQL 查询语句导致的。这时候，优化应用程序中数据库表结构的逻辑或者 
SQL 语句，显然要比优化数据库本身，能带来更大的收益。</p> <p>所以，在观察性能指标时，你应该先查看<strong>应用程序的响应时间、吞吐量以及错误率</strong>等指标，因为它们才是性能优化要解决的终极问题。以终为始，从这些角度出发，你一定能想到很多优化方法，而我比较推荐下面几种方法。</p> 
<ul> <li> <p>第一，从 CPU 使用的角度来说，简化代码、优化算法、异步处理以及编译器优化等，都是常用的降低 CPU 使用率的方法，这样可以利用有限的 CPU 处理更多的请求。</p> 
</li> <li> <p>第二，从数据访问的角度来说，使用缓存、写时复制、增加 I/O 尺寸等，都是常用的减少磁盘 I/O 的方法，这样可以获得更快的数据处理速度。</p> </li> 
<li> <p>第三，从内存管理的角度来说，使用大页、内存池等方法，可以预先分配内存，减少内存的动态分配，从而更好地内存访问性能。</p> </li> <li> <p>第四，从网络的角度来说，使用 
I/O 多路复用、长连接代替短连接、DNS 缓存等方法，可以优化网络 I/O 并减少网络请求数，从而减少网络延时带来的性能问题。</p> </li> <li> <p>第五，从进程的工作模型来说，异步处理、多线程或多进程等，可以充分利用每一个 
CPU 的处理能力，从而提高应用程序的吞吐能力。</p> </li> </ul> <p>除此之外，你还可以使用消息队列、CDN、负载均衡等各种方法，来优化应用程序的架构，将原来单机要承担的任务，调度到多台服务器中并行处理。这样也往往能获得更好的整体性能。</p> 
<h2>小结</h2> <p>今天，我带你一起，从系统和应用程序这两个角度，梳理了常见的性能优化方法。</p> <p>从系统的角度来说，CPU、内存、磁盘和文件系统 I/O、网络以及内核数据结构等各类软硬件资源，为应用程序提供了运行的环境，也是我们性能优化的重点对象。你可以参考咱们专栏前面四个模块的优化篇，优化这些资源。</p> 
<p>从应用程序的角度来说，降低 CPU 使用，减少数据访问和网络 I/O，使用缓存、异步处理以及多进程多线程等，都是常用的性能优化方法。除了这些单机优化方法，调整应用程序的架构，或是利用水平扩展，将任务调度到多台服务器中并行处理，也是常用的优化思路。</p> 
<p>虽然性能优化的方法很多，不过，我还是那句话，一定要避免过早优化。性能优化往往会提高复杂性，这一方面降低了可维护性，另一方面也为适应复杂多变的新需求带来障碍。</p> <p>所以，性能优化最好是逐步完善，动态进行；不追求一步到位，而要首先保证，能满足当前的性能要求。发现性能不满足要求或者出现性能瓶颈后，再根据性能分析的结果，选择最重要的性能问题进行优化。</p> 
<h2>思考</h2> <p>最后，我想邀请你一起来聊聊，当碰到性能问题后，你是怎么进行优化的？有没有哪个印象深刻的经历可以跟我分享呢？你可以结合我的讲述，总结自己的思路。</p> 
<p>欢迎在留言区和我讨论，也欢迎把这篇文章分享给你的同事、朋友。我们一起在实战中演练，在交流中进步。</p>', body_summary='', bundle='book', delta=0, 
body_format='full_html', langcode='zh-hans', revision_id=1089 where entity_id=1089 
 {executed in 0 msec}
2020-11-25 10:21:10.755 INFO  jdbc.sqltiming Line:373 - update node_revision__body set body_value='<p>你好，我是倪朋飞。</p> <p>上一节，我带你一起梳理了，性能问题分析的一般步骤。先带你简单回顾一下。</p> 
<p>我们可以从系统资源瓶颈和应用程序瓶颈，这两个角度来分析性能问题的根源。</p> <p>从系统资源瓶颈的角度来说，USE 法是最为有效的方法，即从使用率、饱和度以及错误数这三个方面，来分析 
CPU、内存、磁盘和文件系统 I/O、网络以及内核资源限制等各类软硬件资源。至于这些资源的分析方法，我也带你一起回顾了，咱们专栏前面几大模块的分析套路。</p> <p>从应用程序瓶颈的角度来说，可以把性能问题的来源，分为资源瓶颈、依赖服务瓶颈以及应用自身的瓶颈这三类。</p> 
<ul> <li> <p>资源瓶颈的分析思路，跟系统资源瓶颈是一样的。</p> </li> <li> <p>依赖服务的瓶颈，可以使用全链路跟踪系统，进行快速定位。</p> </li> 
<li> <p>而应用自身的问题，则可以通过系统调用、热点函数，或者应用自身的指标和日志等，进行分析定位。</p> </li> </ul> <p>当然，虽然系统和应用是两个不同的角度，但在实际运行时，它们往往相辅相成、相互影响。</p> 
<ul> <li> <p>系统是应用的运行环境，系统瓶颈会导致应用的性能下降。</p> </li> <li> <p>而应用程序不合理的设计，也会引发系统资源的瓶颈。</p> </li> 
</ul> <p>我们做性能分析，就是要结合应用程序和操作系统的原理，揪出引发问题的“真凶“。</p> <p>找到性能问题的来源后，整个优化工作其实也就完成了一大半，因为这些瓶颈为我们指明了优化的方向。不过，对于性能优化来说，又有哪些常见的方法呢？</p><!-- 
[[[read_end]]] --> <p>今天，我就带你一起来看看，性能优化的一般方法。同上一节的性能分析一样，我们也可以从系统和应用程序，这两个不同的角度来进行性能优化。</p> 
<h2>系统优化</h2> <p>首先来看系统的优化。在上一节，我曾经介绍过，USE 法可以用来分析系统软硬件资源的瓶颈，那么，相对应的优化方法，当然也是从这些资源瓶颈入手。</p> 
<p>实际上，咱们专栏的前四个模块，除了最核心的系统资源瓶颈分析之外，也已经包含了这些常见资源瓶颈的优化方法。</p> <p>接下来，我就从 CPU 性能、内存性能、磁盘和文件系统 
I/O 性能以及网络性能等四个方面，带你回顾一下它们的优化方法。</p> <h3>CPU 优化</h3> <p>首先来看 CPU 性能的优化方法。在<a href="https://time.geekbang.org/column/article/73151">CPU 
性能优化的几个思路</a>中，我曾经介绍过，<strong>CPU 性能优化的核心，在于排除所有不必要的工作、充分利用 CPU 缓存并减少进程调度对性能的影响。</strong></p> 
<p>从这几个方面出发，我相信你已经想到了很多的优化方法。这里，我主要强调一下，最典型的三种优化方法。</p> <ul> <li> <p>第一种，把进程绑定到一个或者多个 CPU 上，充分利用 
CPU 缓存的本地性，并减少进程间的相互影响。</p> </li> <li> <p>第二种，为中断处理程序开启多 CPU 负载均衡，以便在发生大量中断时，可以充分利用多 CPU 的优势分摊负载。</p> 
</li> <li> <p>第三种，使用 Cgroups 等方法，为进程设置资源限制，避免个别进程消耗过多的 CPU。同时，为核心应用程序设置更高的优先级，减少低优先级任务的影响。</p> 
</li> </ul> <h3>内存优化</h3> <p>说完了 CPU 的性能优化，我们再来看看，怎么优化内存的性能。在<a href="https://time.geekbang.org/column/article/76460">如何“快准狠”找到系统内存的问题</a>中，我曾经为你梳理了常见的一些内存问题，比如可用内存不足、内存泄漏、Swap 
过多、缺页异常过多以及缓存过多等等。所以，说白了，内存性能的优化，也就是要解决这些内存使用的问题。</p> <p>在我看来，你可以通过以下几种方法，来优化内存的性能。</p> <ul> 
<li> <p>第一种，除非有必要，Swap 应该禁止掉。这样就可以避免 Swap 的额外 I/O ，带来内存访问变慢的问题。</p> </li> <li> <p>第二种，使用 Cgroups 
等方法，为进程设置内存限制。这样就可以避免个别进程消耗过多内存，而影响了其他进程。对于核心应用，还应该降低 oom_score，避免被 OOM 杀死。</p> </li> <li> 
<p>第三种，使用大页、内存池等方法，减少内存的动态分配，从而减少缺页异常。</p> </li> </ul> <h3>磁盘和文件系统 I/O 优化</h3> <p>接下来，我们再来看第三类系统资源，即磁盘和文件系统 
I/O 的优化方法。在<a href="https://time.geekbang.org/column/article/79368">磁盘 I/O 性能优化的几个思路</a> 中，我已经为你梳理了一些常见的优化思路，这其中有三种最典型的方法。</p> 
<ul> <li> <p>第一种，也是最简单的方法，通过 SSD 替代 HDD、或者使用 RAID 等方法，提升 I/O 性能。</p> </li> <li> <p>第二种，针对磁盘和应用程序 
I/O 模式的特征，选择最适合的 I/O 调度算法。比如，SSD 和虚拟机中的磁盘，通常用的是 noop 调度算法；而数据库应用，更推荐使用 deadline 算法。</p> </li> 
<li> <p>第三，优化文件系统和磁盘的缓存、缓冲区，比如优化脏页的刷新频率、脏页限额，以及内核回收目录项缓存和索引节点缓存的倾向等等。</p> </li> </ul> <p>除此之外，使用不同磁盘隔离不同应用的数据、优化文件系统的配置选项、优化磁盘预读、增大磁盘队列长度等，也都是常用的优化思路。</p> 
<h3>网络优化</h3> <p>最后一个是网络的性能优化。在<a href="https://time.geekbang.org/column/article/83783">网络性能优化的几个思路</a>中，我也已经为你梳理了一些常见的优化思路。这些优化方法都是从 
Linux 的网络协议栈出发，针对每个协议层的工作原理进行优化。这里，我同样强调一下，最典型的几种网络优化方法。</p> <p>首先，从内核资源和网络协议的角度来说，我们可以对内核选项进行优化，比如：</p> 
<ul> <li> <p>你可以增大套接字缓冲区、连接跟踪表、最大半连接数、最大文件描述符数、本地端口范围等内核资源配额；</p> </li> <li> <p>也可以减少 TIMEOUT 
超时时间、SYN+ACK 重传数、Keepalive 探测时间等异常处理参数；</p> </li> <li> <p>还可以开启端口复用、反向地址校验，并调整 MTU 大小等降低内核的负担。</p> 
</li> </ul> <p>这些都是内核选项优化的最常见措施。</p> <p>其次，从网络接口的角度来说，我们可以考虑对网络接口的功能进行优化，比如：</p> <ul> <li> 
<p>你可以将原来 CPU 上执行的工作，卸载到网卡中执行，即开启网卡的 GRO、GSO、RSS、VXLAN 等卸载功能；</p> </li> <li> <p>也可以开启网络接口的多队列功能，这样，每个队列就可以用不同的中断号，调度到不同 
CPU 上执行；</p> </li> <li> <p>还可以增大网络接口的缓冲区大小以及队列长度等，提升网络传输的吞吐量。</p> </li> </ul> <p>最后，在极限性能情况（比如 
C10M）下，内核的网络协议栈可能是最主要的性能瓶颈，所以，一般会考虑绕过内核协议栈。</p> <ul> <li> <p>你可以使用 DPDK 技术，跳过内核协议栈，直接由用户态进程用轮询的方式，来处理网络请求。同时，再结合大页、CPU 
绑定、内存对齐、流水线并发等多种机制，优化网络包的处理效率。</p> </li> <li> <p>你还可以使用内核自带的 XDP 技术，在网络包进入内核协议栈前，就对其进行处理。这样，也可以达到目的，获得很好的性能。</p> 
</li> </ul> <h2>应用程序优化</h2> <p>说完了系统软硬件资源的优化，接下来，我们再来看看应用程序的优化思路。</p> <p>虽然系统的软硬件资源，是保证应用程序正常运行的基础，但你要知道，<strong>性能优化的最佳位置，还是应用程序内部</strong>。为什么这么说呢？我简单举两个例子你就明白了。</p> 
<p>第一个例子，是系统 CPU 使用率（sys%）过高的问题。有时候出现问题，虽然表面现象是系统 CPU 使用率过高，但待你分析过后，很可能会发现，应用程序的不合理系统调用才是罪魁祸首。这种情况下，优化应用程序内部系统调用的逻辑，显然要比优化内核要简单也有用得多。</p> 
<p>再比如说，数据库的 CPU 使用率高、I/O 响应慢，也是最常见的一种性能问题。这种问题，一般来说，并不是因为数据库本身性能不好，而是应用程序不合理的表结构或者 SQL 查询语句导致的。这时候，优化应用程序中数据库表结构的逻辑或者 
SQL 语句，显然要比优化数据库本身，能带来更大的收益。</p> <p>所以，在观察性能指标时，你应该先查看<strong>应用程序的响应时间、吞吐量以及错误率</strong>等指标，因为它们才是性能优化要解决的终极问题。以终为始，从这些角度出发，你一定能想到很多优化方法，而我比较推荐下面几种方法。</p> 
<ul> <li> <p>第一，从 CPU 使用的角度来说，简化代码、优化算法、异步处理以及编译器优化等，都是常用的降低 CPU 使用率的方法，这样可以利用有限的 CPU 处理更多的请求。</p> 
</li> <li> <p>第二，从数据访问的角度来说，使用缓存、写时复制、增加 I/O 尺寸等，都是常用的减少磁盘 I/O 的方法，这样可以获得更快的数据处理速度。</p> </li> 
<li> <p>第三，从内存管理的角度来说，使用大页、内存池等方法，可以预先分配内存，减少内存的动态分配，从而更好地内存访问性能。</p> </li> <li> <p>第四，从网络的角度来说，使用 
I/O 多路复用、长连接代替短连接、DNS 缓存等方法，可以优化网络 I/O 并减少网络请求数，从而减少网络延时带来的性能问题。</p> </li> <li> <p>第五，从进程的工作模型来说，异步处理、多线程或多进程等，可以充分利用每一个 
CPU 的处理能力，从而提高应用程序的吞吐能力。</p> </li> </ul> <p>除此之外，你还可以使用消息队列、CDN、负载均衡等各种方法，来优化应用程序的架构，将原来单机要承担的任务，调度到多台服务器中并行处理。这样也往往能获得更好的整体性能。</p> 
<h2>小结</h2> <p>今天，我带你一起，从系统和应用程序这两个角度，梳理了常见的性能优化方法。</p> <p>从系统的角度来说，CPU、内存、磁盘和文件系统 I/O、网络以及内核数据结构等各类软硬件资源，为应用程序提供了运行的环境，也是我们性能优化的重点对象。你可以参考咱们专栏前面四个模块的优化篇，优化这些资源。</p> 
<p>从应用程序的角度来说，降低 CPU 使用，减少数据访问和网络 I/O，使用缓存、异步处理以及多进程多线程等，都是常用的性能优化方法。除了这些单机优化方法，调整应用程序的架构，或是利用水平扩展，将任务调度到多台服务器中并行处理，也是常用的优化思路。</p> 
<p>虽然性能优化的方法很多，不过，我还是那句话，一定要避免过早优化。性能优化往往会提高复杂性，这一方面降低了可维护性，另一方面也为适应复杂多变的新需求带来障碍。</p> <p>所以，性能优化最好是逐步完善，动态进行；不追求一步到位，而要首先保证，能满足当前的性能要求。发现性能不满足要求或者出现性能瓶颈后，再根据性能分析的结果，选择最重要的性能问题进行优化。</p> 
<h2>思考</h2> <p>最后，我想邀请你一起来聊聊，当碰到性能问题后，你是怎么进行优化的？有没有哪个印象深刻的经历可以跟我分享呢？你可以结合我的讲述，总结自己的思路。</p> 
<p>欢迎在留言区和我讨论，也欢迎把这篇文章分享给你的同事、朋友。我们一起在实战中演练，在交流中进步。</p>', body_summary='', bundle='book', delta=0, 
body_format='full_html', langcode='zh-hans', revision_id=1089 where entity_id=1089 
 {executed in 0 msec}
2020-11-25 10:21:10.759 INFO  jdbc.sqltiming Line:373 - select nodefiledd0_.nid as nid1_10_, nodefiledd0_.changed as changed2_10_, nodefiledd0_.created 
as created3_10_, nodefiledd0_.default_langcode as default_4_10_, nodefiledd0_.langcode as langcode5_10_, 
nodefiledd0_.promote as promote6_10_, nodefiledd0_.revision_translation_affected as revision7_10_, 
nodefiledd0_.status as status8_10_, nodefiledd0_.sticky as sticky9_10_, nodefiledd0_.title 
as title10_10_, nodefiledd0_.type as type11_10_, nodefiledd0_.uid as uid12_10_, nodefiledd0_.vid 
as vid13_10_ from node_field_data nodefiledd0_ where nodefiledd0_.nid=1089 
 {executed in 1 msec}
2020-11-25 10:21:10.759 INFO  jdbc.resultsettable Line:610 - 
|-----|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|-------------------|-----|----|-----|
|nid  |changed    |created    |default_langcode |langcode |promote |revision_translation_affected |status |sticky |title              |type |uid |vid  |
|-----|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|-------------------|-----|----|-----|
|1089 |1606115013 |1606115013 |1                |zh-hans  |0       |1                             |1      |0      |56丨套路篇：优化性能问题的一般方法 |book |1   |1089 |
|-----|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|-------------------|-----|----|-----|

2020-11-25 10:21:10.760 INFO  jdbc.sqltiming Line:373 - select nodefieldr0_.nid as nid1_11_0_, nodefieldr0_.changed as changed2_11_0_, nodefieldr0_.created 
as created3_11_0_, nodefieldr0_.default_langcode as default_4_11_0_, nodefieldr0_.langcode 
as langcode5_11_0_, nodefieldr0_.promote as promote6_11_0_, nodefieldr0_.revision_translation_affected 
as revision7_11_0_, nodefieldr0_.status as status8_11_0_, nodefieldr0_.sticky as sticky9_11_0_, 
nodefieldr0_.title as title10_11_0_, nodefieldr0_.uid as uid11_11_0_, nodefieldr0_.vid as vid12_11_0_ 
from node_field_revision nodefieldr0_ where nodefieldr0_.nid=1089 
 {executed in 0 msec}
2020-11-25 10:21:10.760 INFO  jdbc.resultsettable Line:610 - 
|---------|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|-------------------|----|-----|
|nid      |changed    |created    |default_langcode |langcode |promote |revision_translation_affected |status |sticky |title              |uid |vid  |
|---------|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|-------------------|----|-----|
|[unread] |1606115013 |1606115013 |1                |zh-hans  |0       |1                             |1      |0      |56丨套路篇：优化性能问题的一般方法 |1   |1089 |
|---------|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|-------------------|----|-----|

2020-11-25 10:21:10.762 INFO  jdbc.sqltiming Line:373 - update node_field_data set changed=1606270870, created=1606270870, default_langcode=1, langcode='zh-hans', 
promote=0, revision_translation_affected=1, status=1, sticky=0, title='56丨套路篇：优化性能问题的一般方法', 
type='book', uid=1, vid=1089 where nid=1089 
 {executed in 0 msec}
2020-11-25 10:21:10.762 INFO  jdbc.sqltiming Line:373 - update node_field_revision set changed=1606270870, created=1606270870, default_langcode=1, 
langcode='zh-hans', promote=0, revision_translation_affected=1, status=1, sticky=0, title='56丨套路篇：优化性能问题的一般方法', 
uid=1, vid=1089 where nid=1089 
 {executed in 0 msec}
2020-11-25 10:21:10.766 INFO  jdbc.sqltiming Line:373 - select bookfieldm0_.entity_id as entity_i1_8_, bookfieldm0_.bundle as bundle2_8_, bookfieldm0_.delta 
as delta3_8_, bookfieldm0_.langcode as langcode4_8_, bookfieldm0_.field_media_value as field_me5_8_, 
bookfieldm0_.revision_id as revision6_8_ from node__field_media bookfieldm0_ where bookfieldm0_.entity_id=1089 
 {executed in 0 msec}
2020-11-25 10:21:10.766 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------------|------------|
|entity_id |bundle |delta |langcode |field_media_value |revision_id |
|----------|-------|------|---------|------------------|------------|
|1089      |book   |0     |zh-hans  |                  |1089        |
|----------|-------|------|---------|------------------|------------|

2020-11-25 10:21:10.768 INFO  jdbc.sqltiming Line:373 - select nodefieldm0_.entity_id as entity_i1_17_0_, nodefieldm0_.bundle as bundle2_17_0_, nodefieldm0_.delta 
as delta3_17_0_, nodefieldm0_.langcode as langcode4_17_0_, nodefieldm0_.field_media_value as 
field_me5_17_0_, nodefieldm0_.revision_id as revision6_17_0_ from node_revision__field_media 
nodefieldm0_ where nodefieldm0_.entity_id=1089 
 {executed in 0 msec}
2020-11-25 10:21:10.769 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------------|------------|
|entity_id |bundle |delta |langcode |field_media_value |revision_id |
|----------|-------|------|---------|------------------|------------|
|[unread]  |book   |0     |zh-hans  |                  |1089        |
|----------|-------|------|---------|------------------|------------|

2020-11-25 10:21:10.771 INFO  jdbc.sqltiming Line:373 - select bookfieldc0_.entity_id as entity_i1_5_, bookfieldc0_.bundle as bundle2_5_, bookfieldc0_.field_comment_value 
as field_co3_5_, bookfieldc0_.delta as delta4_5_, bookfieldc0_.field_comment_format as field_co5_5_, 
bookfieldc0_.langcode as langcode6_5_, bookfieldc0_.revision_id as revision7_5_ from node__field_comment 
bookfieldc0_ where bookfieldc0_.entity_id=1089 
 {executed in 1 msec}
2020-11-25 10:21:10.771 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|--------------------|------|---------------------|---------|------------|
|entity_id |bundle |field_comment_value |delta |field_comment_format |langcode |revision_id |
|----------|-------|--------------------|------|---------------------|---------|------------|
|1089      |book   |                    |0     |full_html            |zh-hans  |1089        |
|----------|-------|--------------------|------|---------------------|---------|------------|

2020-11-25 10:21:10.773 INFO  jdbc.sqltiming Line:373 - update node__field_comment set bundle='book', field_comment_value='<li class="reJj6Thl_0"><img 
src="https://static001.geekbang.org/account/avatar/00/14/0c/ca/6173350b.jpg" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>郭江伟</span> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2019-04-05 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">10</span> </div> <!----> 
<!----> </div> </div> <div class="_3M6kV3zb_0"> 每篇都认真看过， 还要二刷 ，二刷准备联系趣谈操作系统专栏一起刷。 <br>今年计划熟悉Linux内核 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <!----> </div></li> 
<li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>我来也</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-04-05 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">2</span> </div> <!----> 
<!----> </div> </div> <div class="_3M6kV3zb_0"> [D56打卡] <br>“性能优化的最佳位置，还是应用程序内部” <br> <br>硬件性能摆在那，操作系统就那些。 
<br>这些都是摆在那，我们改变不了的。 <br>能改变的只有自己的程序。 </div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> 
</div> <!----> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/12/e7/e0/33521e13.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>付坤</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-04-08 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> </div> <!----> 
<!----> </div> </div> <div class="_3M6kV3zb_0"> 大赞👍，我在实战的时候，总会遇到突然想不起来接下来的详细指标该用哪个工具了，还要一篇一篇的翻老师的文章去找。 
<br>本来还打算自己总结一篇各个指标查看用到的工具，没想到老师已经总结好了，谢谢老师。 </div> <div class="_2r3UB1GX_0"> <span>展开</span><i 
class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 👍</p> 
</div> </div></li> <li class="reJj6Thl_0"><img src="https://wx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEKQMM4m7NHuicr55aRiblTSEWIYe0QqbpyHweaoAbG7j2v7UUElqqeP3Ihrm3UfDPDRb1Hv8LvPwXqA/132" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>ninuxer</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-04-06 </div> </div> <div 
class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> 
</div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 打卡day60 <br>从分析到优化，为啥感觉分析出来容易，优化却不太容易，分析只是一个线性事情，但优化，却是一个系统性事情 
</div> <!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 嗯，还要看具体场景和性能要求，有些场景比较简单，只需要修改系统配置就可以解决；不过也有很多需要调整软件架构来解决</p> 
</div> </div></li> <li class="reJj6Thl_0"><img src="" class="_2273kGdT_0"> <div class="_2CG0SquK_0"> 
<div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>如果</span> <!----> </div> <div 
class="_1H1Z49Dr_0"> 2019-04-23 </div> </div> <div class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> 
<i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> </div> </div> <div 
class="_3M6kV3zb_0"> DAY56，打卡 </div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> 
</div> <!----> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/12/86/fa/4bcd7365.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>玉剑冰锋</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-04-08 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 说到这里想请教老师一个问题，我们经常说到磁盘I/O，单挂裸盘和做RAID，如果从读写角度单挂裸盘同时读写是不是一定比RAID好，但是从长期维护角度来说RAID更易于维护，想请教老师如何取舍？ 
</div> <!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 从可靠性角度来说，单盘是不推荐的，磁盘损坏数据就丢失了。性能的话，要看使用什么RAID级了</p> 
</div> </div></li>', delta=0, field_comment_format='full_html', langcode='zh-hans', revision_id=1089 
where entity_id=1089 
 {executed in 0 msec}
2020-11-25 10:21:10.776 INFO  jdbc.sqltiming Line:373 - select nodefieldc0_.entity_id as entity_i1_14_0_, nodefieldc0_.bundle as bundle2_14_0_, nodefieldc0_.field_comment_value 
as field_co3_14_0_, nodefieldc0_.delta as delta4_14_0_, nodefieldc0_.field_comment_format as 
field_co5_14_0_, nodefieldc0_.langcode as langcode6_14_0_, nodefieldc0_.revision_id as revision7_14_0_ 
from node_revision__field_comment nodefieldc0_ where nodefieldc0_.entity_id=1089 
 {executed in 1 msec}
2020-11-25 10:21:10.776 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|--------------------|------|---------------------|---------|------------|
|entity_id |bundle |field_comment_value |delta |field_comment_format |langcode |revision_id |
|----------|-------|--------------------|------|---------------------|---------|------------|
|[unread]  |book   |                    |0     |full_html            |zh-hans  |1089        |
|----------|-------|--------------------|------|---------------------|---------|------------|

2020-11-25 10:21:10.778 INFO  jdbc.sqltiming Line:373 - update node_revision__field_comment set bundle='book', field_comment_value='<li class="reJj6Thl_0"><img 
src="https://static001.geekbang.org/account/avatar/00/14/0c/ca/6173350b.jpg" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>郭江伟</span> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2019-04-05 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">10</span> </div> <!----> 
<!----> </div> </div> <div class="_3M6kV3zb_0"> 每篇都认真看过， 还要二刷 ，二刷准备联系趣谈操作系统专栏一起刷。 <br>今年计划熟悉Linux内核 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <!----> </div></li> 
<li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>我来也</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-04-05 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">2</span> </div> <!----> 
<!----> </div> </div> <div class="_3M6kV3zb_0"> [D56打卡] <br>“性能优化的最佳位置，还是应用程序内部” <br> <br>硬件性能摆在那，操作系统就那些。 
<br>这些都是摆在那，我们改变不了的。 <br>能改变的只有自己的程序。 </div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> 
</div> <!----> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/12/e7/e0/33521e13.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>付坤</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-04-08 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> </div> <!----> 
<!----> </div> </div> <div class="_3M6kV3zb_0"> 大赞👍，我在实战的时候，总会遇到突然想不起来接下来的详细指标该用哪个工具了，还要一篇一篇的翻老师的文章去找。 
<br>本来还打算自己总结一篇各个指标查看用到的工具，没想到老师已经总结好了，谢谢老师。 </div> <div class="_2r3UB1GX_0"> <span>展开</span><i 
class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 👍</p> 
</div> </div></li> <li class="reJj6Thl_0"><img src="https://wx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEKQMM4m7NHuicr55aRiblTSEWIYe0QqbpyHweaoAbG7j2v7UUElqqeP3Ihrm3UfDPDRb1Hv8LvPwXqA/132" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>ninuxer</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-04-06 </div> </div> <div 
class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> 
</div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 打卡day60 <br>从分析到优化，为啥感觉分析出来容易，优化却不太容易，分析只是一个线性事情，但优化，却是一个系统性事情 
</div> <!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 嗯，还要看具体场景和性能要求，有些场景比较简单，只需要修改系统配置就可以解决；不过也有很多需要调整软件架构来解决</p> 
</div> </div></li> <li class="reJj6Thl_0"><img src="" class="_2273kGdT_0"> <div class="_2CG0SquK_0"> 
<div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>如果</span> <!----> </div> <div 
class="_1H1Z49Dr_0"> 2019-04-23 </div> </div> <div class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> 
<i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> </div> </div> <div 
class="_3M6kV3zb_0"> DAY56，打卡 </div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> 
</div> <!----> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/12/86/fa/4bcd7365.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>玉剑冰锋</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-04-08 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 说到这里想请教老师一个问题，我们经常说到磁盘I/O，单挂裸盘和做RAID，如果从读写角度单挂裸盘同时读写是不是一定比RAID好，但是从长期维护角度来说RAID更易于维护，想请教老师如何取舍？ 
</div> <!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 从可靠性角度来说，单盘是不推荐的，磁盘损坏数据就丢失了。性能的话，要看使用什么RAID级了</p> 
</div> </div></li>', delta=0, field_comment_format='full_html', langcode='zh-hans', revision_id=1089 
where entity_id=1089 
 {executed in 1 msec}
2020-11-25 10:21:10.780 INFO  jdbc.sqltiming Line:373 - select bookfieldt0_.entity_id as entity_i1_9_, bookfieldt0_.bundle as bundle2_9_, bookfieldt0_.delta 
as delta3_9_, bookfieldt0_.langcode as langcode4_9_, bookfieldt0_.revision_id as revision5_9_, 
bookfieldt0_.field_thumb_value as field_th6_9_ from node__field_thumb bookfieldt0_ where bookfieldt0_.entity_id=1089 
 {executed in 0 msec}
2020-11-25 10:21:10.781 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------|------------------|
|entity_id |bundle |delta |langcode |revision_id |field_thumb_value |
|----------|-------|------|---------|------------|------------------|
|1089      |book   |0     |zh-hans  |1089        |                  |
|----------|-------|------|---------|------------|------------------|

2020-11-25 10:21:10.782 INFO  jdbc.sqltiming Line:373 - update node__field_thumb set bundle='book', delta=0, langcode='zh-hans', revision_id=1089, 
field_thumb_value='https://static001.geekbang.org/resource/image/52/bc/52133140a093338b6bead8503154f5bc.jpg' 
where entity_id=1089 
 {executed in 0 msec}
2020-11-25 10:21:10.785 INFO  jdbc.sqltiming Line:373 - select nodefieldt0_.entity_id as entity_i1_18_0_, nodefieldt0_.bundle as bundle2_18_0_, nodefieldt0_.delta 
as delta3_18_0_, nodefieldt0_.langcode as langcode4_18_0_, nodefieldt0_.revision_id as revision5_18_0_, 
nodefieldt0_.field_thumb_value as field_th6_18_0_ from node_revision__field_thumb nodefieldt0_ 
where nodefieldt0_.entity_id=1089 
 {executed in 0 msec}
2020-11-25 10:21:10.785 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------|------------------|
|entity_id |bundle |delta |langcode |revision_id |field_thumb_value |
|----------|-------|------|---------|------------|------------------|
|[unread]  |book   |0     |zh-hans  |1089        |                  |
|----------|-------|------|---------|------------|------------------|

2020-11-25 10:21:10.787 INFO  jdbc.sqltiming Line:373 - update node_revision__field_thumb set bundle='book', delta=0, langcode='zh-hans', revision_id=1089, 
field_thumb_value='https://static001.geekbang.org/resource/image/52/bc/52133140a093338b6bead8503154f5bc.jpg' 
where entity_id=1089 
 {executed in 0 msec}
2020-11-25 10:21:10.789 INFO  jdbc.sqltiming Line:373 - select bookfieldf0_.entity_id as entity_i1_6_0_, bookfieldf0_.bundle as bundle2_6_0_, bookfieldf0_.delta 
as delta3_6_0_, bookfieldf0_.field_fenlei_target_id as field_fe4_6_0_, bookfieldf0_.langcode 
as langcode5_6_0_, bookfieldf0_.revision_id as revision6_6_0_ from node__field_fenlei bookfieldf0_ 
where bookfieldf0_.entity_id=1089 
 {executed in 0 msec}
2020-11-25 10:21:10.790 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|-----------------------|---------|------------|
|entity_id |bundle |delta |field_fenlei_target_id |langcode |revision_id |
|----------|-------|------|-----------------------|---------|------------|
|[unread]  |book   |0     |1                      |zh-hans  |1089        |
|----------|-------|------|-----------------------|---------|------------|

2020-11-25 10:21:10.792 INFO  jdbc.sqltiming Line:373 - select nodefieldf0_.entity_id as entity_i1_15_0_, nodefieldf0_.bundle as bundle2_15_0_, nodefieldf0_.delta 
as delta3_15_0_, nodefieldf0_.field_fenlei_target_id as field_fe4_15_0_, nodefieldf0_.langcode 
as langcode5_15_0_, nodefieldf0_.revision_id as revision6_15_0_ from node_revision__field_fenlei 
nodefieldf0_ where nodefieldf0_.entity_id=1089 
 {executed in 1 msec}
2020-11-25 10:21:10.792 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|-----------------------|---------|------------|
|entity_id |bundle |delta |field_fenlei_target_id |langcode |revision_id |
|----------|-------|------|-----------------------|---------|------------|
|[unread]  |book   |0     |1                      |zh-hans  |1089        |
|----------|-------|------|-----------------------|---------|------------|

2020-11-25 10:21:10.794 INFO  jdbc.sqltiming Line:373 - select bookchecke0_.item_id as item_id1_2_, bookchecke0_.fsid as fsid2_2_, bookchecke0_.got 
as got3_2_, bookchecke0_.name as name4_2_, bookchecke0_.parse_fail as parse_fa5_2_, bookchecke0_.parsed 
as parsed6_2_, bookchecke0_.path as path7_2_, bookchecke0_.title as title8_2_, bookchecke0_.vid 
as vid9_2_ from book_check bookchecke0_ where bookchecke0_.fsid='295391431099914' and bookchecke0_.name='net_content' 
 {executed in 0 msec}
2020-11-25 10:21:10.794 INFO  jdbc.resultsettable Line:610 - 
|--------|---------|---------|---------|-----------|---------|---------|---------|---------|
|item_id |fsid     |got      |name     |parse_fail |parsed   |path     |title    |vid      |
|--------|---------|---------|---------|-----------|---------|---------|---------|---------|
|1090    |[unread] |[unread] |[unread] |[unread]   |[unread] |[unread] |[unread] |[unread] |
|--------|---------|---------|---------|-----------|---------|---------|---------|---------|

2020-11-25 10:24:43.352 INFO  jdbc.sqltiming Line:373 - update book_check set fsid='295391431099914', got=1, name='net_content', parse_fail='', parsed=1, 
path='12-Linux性能优化实战/06-综合实战篇 (13讲)/57丨套路篇：Linux性能工具速查.html', title='57丨套路篇：Linux性能工具速查', vid=1090 
where item_id=1090 
 {executed in 0 msec}
2020-11-25 10:24:43.356 INFO  jdbc.sqltiming Line:373 - select nodebodyen0_.entity_id as entity_i1_4_, nodebodyen0_.body_value as body_val2_4_, nodebodyen0_.body_summary 
as body_sum3_4_, nodebodyen0_.bundle as bundle4_4_, nodebodyen0_.delta as delta5_4_, nodebodyen0_.body_format 
as body_for6_4_, nodebodyen0_.langcode as langcode7_4_, nodebodyen0_.revision_id as revision8_4_ 
from node__body nodebodyen0_ where nodebodyen0_.entity_id=1090 
 {executed in 0 msec}
2020-11-25 10:24:43.356 INFO  jdbc.resultsettable Line:610 - 
|----------|-----------|-------------|-------|------|------------|---------|------------|
|entity_id |body_value |body_summary |bundle |delta |body_format |langcode |revision_id |
|----------|-----------|-------------|-------|------|------------|---------|------------|
|1090      |           |             |book   |0     |full_html   |zh-hans  |1090        |
|----------|-----------|-------------|-------|------|------------|---------|------------|

2020-11-25 10:24:43.357 INFO  jdbc.sqltiming Line:373 - select nodebodyre0_.entity_id as entity_i1_13_0_, nodebodyre0_.body_value as body_val2_13_0_, 
nodebodyre0_.body_summary as body_sum3_13_0_, nodebodyre0_.bundle as bundle4_13_0_, nodebodyre0_.delta 
as delta5_13_0_, nodebodyre0_.body_format as body_for6_13_0_, nodebodyre0_.langcode as langcode7_13_0_, 
nodebodyre0_.revision_id as revision8_13_0_ from node_revision__body nodebodyre0_ where nodebodyre0_.entity_id=1090 
 {executed in 0 msec}
2020-11-25 10:24:43.358 INFO  jdbc.resultsettable Line:610 - 
|----------|-----------|-------------|-------|------|------------|---------|------------|
|entity_id |body_value |body_summary |bundle |delta |body_format |langcode |revision_id |
|----------|-----------|-------------|-------|------|------------|---------|------------|
|[unread]  |           |             |book   |0     |full_html   |zh-hans  |1090        |
|----------|-----------|-------------|-------|------|------------|---------|------------|

2020-11-25 10:24:43.360 INFO  jdbc.sqltiming Line:373 - update node__body set body_value='<p>你好，我是倪朋飞。</p> <p>上一节，我带你一起梳理了常见的性能优化思路，先简单回顾一下。</p> <p>我们可以从系统和应用程序两个角度，来进行性能优化。</p> 
<ul> <li> <p>从系统的角度来说，主要是对 CPU、内存、网络、磁盘 I/O 以及内核软件资源等进行优化。</p> </li> <li> <p>而从应用程序的角度来说，主要是简化代码、降低 
CPU 使用、减少网络请求和磁盘 I/O，并借助缓存、异步处理、多进程和多线程等，提高应用程序的吞吐能力。</p> </li> </ul> <p>性能优化最好逐步完善，动态进行。不要追求一步到位，而要首先保证能满足当前的性能要求。性能优化通常意味着复杂度的提升，也意味着可维护性的降低。</p> 
<p>如果你发现单机的性能调优带来过高复杂度，一定不要沉迷于单机的极限性能，而要从软件架构的角度，以水平扩展的方法来提升性能。</p> <p>工欲善其事，必先利其器。我们知道，在性能分析和优化时，借助合适的性能工具，可以让整个过程事半功倍。你还记得有哪些常用的性能工具吗？今天，我就带你一起梳理一下常用的性能工具，以便你在需要时，可以迅速找到自己想要的。</p> 
<h2>性能工具速查</h2> <p>在梳理性能工具之前，首先给你提一个问题，那就是，在什么情况下，我们才需要去查找、挑选性能工具呢？你可以先自己想一下，再继续下面的内容。</p> 
<p>其实在我看来，只有当你想了解某个性能指标，却不知道该怎么办的时候，才会想到，“要是有一个性能工具速查表就好了”这个问题。如果已知一个性能工具可用，我们更多会去查看这个工具的手册，找出它的功能、用法以及注意事项。</p><!-- 
[[[read_end]]] --> <p>关于工具手册的查看，man 应该是我们最熟悉的方法，我在专栏中多次介绍过。实际上，除了 man 之外，还有另外一个查询命令手册的方法，也就是 
info。</p> <p>info 可以理解为 man 的详细版本，提供了诸如节点跳转等更强大的功能。相对来说，man 的输出比较简洁，而 info 的输出更详细。所以，我们通常使用 
man 来查询工具的使用方法，只有在 man 的输出不太好理解时，才会再去参考 info 文档。</p> <p>当然，我说过了，要查询手册，前提一定是已知哪个工具可用。如果你还不知道要用哪个工具，就要根据想了解的指标，去查找有哪些工具可用。这其中：</p> 
<ul> <li> <p>有些工具不需要额外安装，就可以直接使用，比如内核的 /proc 文件系统；</p> </li> <li> <p>而有些工具，则需要安装额外的软件包，比如 sar、pidstat、iostat 
等。</p> </li> </ul> <p><strong>所以，在选择性能工具时，除了要考虑性能指标这个目的外，还要结合待分析的环境来综合考虑</strong>。比如，实际环境是否允许安装软件包，是否需要新的内核版本等。</p> 
<p>明白了工具选择的基本原则后，我们来看 Linux 的性能工具。首先还是要推荐下面这张图，也就是 Brendan Gregg 整理的性能工具谱图。我在专栏中多次提到过，你肯定也已经参考过。<br> 
<img src="https://static001.geekbang.org/resource/image/b0/01/b07ca95ef8a3d2c89b0996a042d33901.png" 
alt=""><br> （图片来自 <a href="http://www.brendangregg.com/linuxperf.html">brendangregg.com</a>）</p> 
<p>这张图从 Linux 内核的各个子系统出发，汇总了对各个子系统进行性能分析时，你可以选择的工具。不过，虽然这个图是性能分析最好的参考资料之一，它其实还不够具体。</p> <p>比如，当你需要查看某个性能指标时，这张图里对应的子系统部分，可能有多个性能工具可供选择。但实际上，并非所有这些工具都适用，具体要用哪个，还需要你去查找每个工具的手册，对比分析做出选择。</p> 
<p>那么，有没有更好的方法来理解这些工具呢？<strong>我的建议，还是从性能指标出发，根据性能指标的不同，将性能工具划分为不同类型</strong>。比如，最常见的就是可以根据 
CPU、内存、磁盘 I/O 以及网络的各类性能指标，将这些工具进行分类。</p> <p>接下来，我就从 CPU、内存、磁盘 I/O 以及网络等几个角度，梳理这些常见的 Linux 性能工具，特别是从性能指标的角度出发，理清楚到底有哪些工具，可以用来监测特定的性能指标。这些工具，实际上贯穿在我们专栏各模块的各个案例中。为了方便你查看，我将它们都整理成了表格，并增加了每个工具的使用场景。</p> 
<h2>CPU 性能工具</h2> <p>首先，从 CPU 的角度来说，主要的性能指标就是 CPU 的使用率、上下文切换以及 CPU Cache 的命中率等。下面这张图就列出了常见的 
CPU 性能指标。<br> <img src="https://static001.geekbang.org/resource/image/9a/69/9a211905538faffb5b3221ee01776a69.png" 
alt=""><br> 从这些指标出发，再把 CPU 使用率，划分为系统和进程两个维度，我们就可以得到，下面这个 CPU 性能工具速查表。注意，因为每种性能指标都可能对应多种工具，我在每个指标的说明中，都帮你总结了这些工具的特点和注意事项。这些也是你需要特别关注的地方。<br> 
<img src="https://static001.geekbang.org/resource/image/28/b0/28cb85011289f83804c51c1fb275dab0.png" 
alt=""></p> <h2>内存性能工具</h2> <p>接着我们来看内存方面。从内存的角度来说，主要的性能指标，就是系统内存的分配和使用、进程内存的分配和使用以及 SWAP 的用量。下面这张图列出了常见的内存性能指标。<br> 
<img src="https://static001.geekbang.org/resource/image/ee/c0/ee36f73b9213063b3bcdaed2245944c0.png" 
alt=""><br> 从这些指标出发，我们就可以得到如下表所示的内存性能工具速查表。同 CPU 性能工具一样，这儿我也帮你梳理了，常见工具的特点和注意事项。<br> <img src="https://static001.geekbang.org/resource/image/79/f8/79ad5caf0a2c105b7e9ce77877d493f8.png" 
alt=""><br> 注：最后一行 pcstat 的源码链接为 <a href="https://github.com/tobert/pcstat">https://github.com/tobert/pcstat</a></p> 
<h2>磁盘 I/O 性能工具</h2> <p>接下来，从文件系统和磁盘 I/O 的角度来说，主要性能指标，就是文件系统的使用、缓存和缓冲区的使用，以及磁盘 I/O 的使用率、吞吐量和延迟等。下面这张图列出了常见的 
I/O 性能指标。<br> <img src="https://static001.geekbang.org/resource/image/72/3b/723431a944034b51a9ef13a8a1d4d03b.png" 
alt=""><br> 从这些指标出发，我们就可以得到，下面这个文件系统和磁盘 I/O 性能工具速查表。同 CPU 和内存性能工具一样，我也梳理出了这些工具的特点和注意事项。<br> 
<img src="https://static001.geekbang.org/resource/image/c2/a3/c232dcb4185f7b7ba95c126889cf6fa3.png" 
alt=""></p> <h2>网络性能工具</h2> <p>最后，从网络的角度来说，主要性能指标就是吞吐量、响应时间、连接数、丢包数等。根据 TCP/IP 网络协议栈的原理，我们可以把这些性能指标，进一步细化为每层协议的具体指标。这里我同样用一张图，分别从链路层、网络层、传输层和应用层，列出了各层的主要指标。<br> 
<img src="https://static001.geekbang.org/resource/image/37/a4/37d04c213acfa650bd7467e3000356a4.png" 
alt=""><br> 从这些指标出发，我们就可以得到下面的网络性能工具速查表。同样的，我也帮你梳理了各种工具的特点和注意事项。<br> <img src="https://static001.geekbang.org/resource/image/5d/5d/5dde213baffd7811ab73c82883b2a75d.png" 
alt=""></p> <h2>基准测试工具</h2> <p>除了性能分析外，很多时候，我们还需要对系统性能进行基准测试。比如，</p> <ul> <li> <p>在文件系统和磁盘 
I/O 模块中，我们使用 fio 工具，测试了磁盘 I/O 的性能。</p> </li> <li> <p>在网络模块中，我们使用 iperf、pktgen 等，测试了网络的性能。</p> 
</li> <li> <p>而在很多基于 Nginx 的案例中，我们则使用 ab、wrk 等，测试 Nginx 应用的性能。</p> </li> </ul> <p>除了专栏里介绍过的这些工具外，对于 
Linux 的各个子系统来说，还有很多其他的基准测试工具可能会用到。下面这张图，是 Brendan Gregg 整理的 Linux 基准测试工具图谱，你可以保存下来，在需要时参考。<br> 
<img src="https://static001.geekbang.org/resource/image/f0/e9/f094f489049602e1058e02edc708e6e9.png" 
alt=""><br> （图片来自 <a href="http://www.brendangregg.com/linuxperf.html">brendangregg.com</a>）</p> 
<h2>小结</h2> <p>今天，我们一起梳理了常见的性能工具，并从 CPU、内存、文件系统和磁盘 I/O、网络以及基准测试等不同的角度，汇总了各类性能指标所对应的性能工具速查表。</p> 
<p>当分析性能问题时，大的来说，主要有这么两个步骤：</p> <ul> <li> <p>第一步，从性能瓶颈出发，根据系统和应用程序的运行原理，确认待分析的性能指标。</p> </li> 
<li> <p>第二步，根据这些图表，选出最合适的性能工具，然后了解并使用工具，从而更快观测到需要的性能数据。</p> </li> </ul> <p>虽然 Linux 的性能指标和性能工具都比较多，但熟悉了各指标含义后，你自然就会发现这些工具同性能指标间的关联。顺着这个思路往下走，掌握这些工具的选用其实并不难。</p> 
<p>当然，正如咱们专栏一直强调的，不要把性能工具当成性能分析和优化的全部。</p> <ul> <li> <p>一方面，性能分析和优化的核心，是对系统和应用程序运行原理的掌握，而性能工具只是辅助你更快完成这个过程的帮手。</p> 
</li> <li> <p>另一方面，完善的监控系统，可以提供绝大部分性能分析所需的基准数据。从这些数据中，你很可能就能大致定位出性能瓶颈，也就不用再去手动执行各类工具了。</p> 
</li> </ul> <h2>思考</h2> <p>最后，我想邀请你一起来聊聊，你都使用过哪些性能工具。你通常是怎么选择性能工具的？又是如何想到要用这些性能工具，来排查和分析性能问题的？你可以结合我的讲述，总结自己的思路。</p> 
<p>欢迎在留言区和我讨论，也欢迎你把这篇文章分享给你的同事、朋友。我们一起在实战中演练，在交流中进步。</p> <p><img src="https://static001.geekbang.org/resource/image/a3/e9/a396aed4116c2c989771c1295736abe9.jpg" 
alt=""></p>', body_summary='', bundle='book', delta=0, body_format='full_html', langcode='zh-hans', 
revision_id=1090 where entity_id=1090 
 {executed in 1 msec}
2020-11-25 10:24:43.360 INFO  jdbc.sqltiming Line:373 - update node_revision__body set body_value='<p>你好，我是倪朋飞。</p> <p>上一节，我带你一起梳理了常见的性能优化思路，先简单回顾一下。</p> 
<p>我们可以从系统和应用程序两个角度，来进行性能优化。</p> <ul> <li> <p>从系统的角度来说，主要是对 CPU、内存、网络、磁盘 I/O 以及内核软件资源等进行优化。</p> 
</li> <li> <p>而从应用程序的角度来说，主要是简化代码、降低 CPU 使用、减少网络请求和磁盘 I/O，并借助缓存、异步处理、多进程和多线程等，提高应用程序的吞吐能力。</p> 
</li> </ul> <p>性能优化最好逐步完善，动态进行。不要追求一步到位，而要首先保证能满足当前的性能要求。性能优化通常意味着复杂度的提升，也意味着可维护性的降低。</p> <p>如果你发现单机的性能调优带来过高复杂度，一定不要沉迷于单机的极限性能，而要从软件架构的角度，以水平扩展的方法来提升性能。</p> 
<p>工欲善其事，必先利其器。我们知道，在性能分析和优化时，借助合适的性能工具，可以让整个过程事半功倍。你还记得有哪些常用的性能工具吗？今天，我就带你一起梳理一下常用的性能工具，以便你在需要时，可以迅速找到自己想要的。</p> 
<h2>性能工具速查</h2> <p>在梳理性能工具之前，首先给你提一个问题，那就是，在什么情况下，我们才需要去查找、挑选性能工具呢？你可以先自己想一下，再继续下面的内容。</p> 
<p>其实在我看来，只有当你想了解某个性能指标，却不知道该怎么办的时候，才会想到，“要是有一个性能工具速查表就好了”这个问题。如果已知一个性能工具可用，我们更多会去查看这个工具的手册，找出它的功能、用法以及注意事项。</p><!-- 
[[[read_end]]] --> <p>关于工具手册的查看，man 应该是我们最熟悉的方法，我在专栏中多次介绍过。实际上，除了 man 之外，还有另外一个查询命令手册的方法，也就是 
info。</p> <p>info 可以理解为 man 的详细版本，提供了诸如节点跳转等更强大的功能。相对来说，man 的输出比较简洁，而 info 的输出更详细。所以，我们通常使用 
man 来查询工具的使用方法，只有在 man 的输出不太好理解时，才会再去参考 info 文档。</p> <p>当然，我说过了，要查询手册，前提一定是已知哪个工具可用。如果你还不知道要用哪个工具，就要根据想了解的指标，去查找有哪些工具可用。这其中：</p> 
<ul> <li> <p>有些工具不需要额外安装，就可以直接使用，比如内核的 /proc 文件系统；</p> </li> <li> <p>而有些工具，则需要安装额外的软件包，比如 sar、pidstat、iostat 
等。</p> </li> </ul> <p><strong>所以，在选择性能工具时，除了要考虑性能指标这个目的外，还要结合待分析的环境来综合考虑</strong>。比如，实际环境是否允许安装软件包，是否需要新的内核版本等。</p> 
<p>明白了工具选择的基本原则后，我们来看 Linux 的性能工具。首先还是要推荐下面这张图，也就是 Brendan Gregg 整理的性能工具谱图。我在专栏中多次提到过，你肯定也已经参考过。<br> 
<img src="https://static001.geekbang.org/resource/image/b0/01/b07ca95ef8a3d2c89b0996a042d33901.png" 
alt=""><br> （图片来自 <a href="http://www.brendangregg.com/linuxperf.html">brendangregg.com</a>）</p> 
<p>这张图从 Linux 内核的各个子系统出发，汇总了对各个子系统进行性能分析时，你可以选择的工具。不过，虽然这个图是性能分析最好的参考资料之一，它其实还不够具体。</p> <p>比如，当你需要查看某个性能指标时，这张图里对应的子系统部分，可能有多个性能工具可供选择。但实际上，并非所有这些工具都适用，具体要用哪个，还需要你去查找每个工具的手册，对比分析做出选择。</p> 
<p>那么，有没有更好的方法来理解这些工具呢？<strong>我的建议，还是从性能指标出发，根据性能指标的不同，将性能工具划分为不同类型</strong>。比如，最常见的就是可以根据 
CPU、内存、磁盘 I/O 以及网络的各类性能指标，将这些工具进行分类。</p> <p>接下来，我就从 CPU、内存、磁盘 I/O 以及网络等几个角度，梳理这些常见的 Linux 性能工具，特别是从性能指标的角度出发，理清楚到底有哪些工具，可以用来监测特定的性能指标。这些工具，实际上贯穿在我们专栏各模块的各个案例中。为了方便你查看，我将它们都整理成了表格，并增加了每个工具的使用场景。</p> 
<h2>CPU 性能工具</h2> <p>首先，从 CPU 的角度来说，主要的性能指标就是 CPU 的使用率、上下文切换以及 CPU Cache 的命中率等。下面这张图就列出了常见的 
CPU 性能指标。<br> <img src="https://static001.geekbang.org/resource/image/9a/69/9a211905538faffb5b3221ee01776a69.png" 
alt=""><br> 从这些指标出发，再把 CPU 使用率，划分为系统和进程两个维度，我们就可以得到，下面这个 CPU 性能工具速查表。注意，因为每种性能指标都可能对应多种工具，我在每个指标的说明中，都帮你总结了这些工具的特点和注意事项。这些也是你需要特别关注的地方。<br> 
<img src="https://static001.geekbang.org/resource/image/28/b0/28cb85011289f83804c51c1fb275dab0.png" 
alt=""></p> <h2>内存性能工具</h2> <p>接着我们来看内存方面。从内存的角度来说，主要的性能指标，就是系统内存的分配和使用、进程内存的分配和使用以及 SWAP 的用量。下面这张图列出了常见的内存性能指标。<br> 
<img src="https://static001.geekbang.org/resource/image/ee/c0/ee36f73b9213063b3bcdaed2245944c0.png" 
alt=""><br> 从这些指标出发，我们就可以得到如下表所示的内存性能工具速查表。同 CPU 性能工具一样，这儿我也帮你梳理了，常见工具的特点和注意事项。<br> <img src="https://static001.geekbang.org/resource/image/79/f8/79ad5caf0a2c105b7e9ce77877d493f8.png" 
alt=""><br> 注：最后一行 pcstat 的源码链接为 <a href="https://github.com/tobert/pcstat">https://github.com/tobert/pcstat</a></p> 
<h2>磁盘 I/O 性能工具</h2> <p>接下来，从文件系统和磁盘 I/O 的角度来说，主要性能指标，就是文件系统的使用、缓存和缓冲区的使用，以及磁盘 I/O 的使用率、吞吐量和延迟等。下面这张图列出了常见的 
I/O 性能指标。<br> <img src="https://static001.geekbang.org/resource/image/72/3b/723431a944034b51a9ef13a8a1d4d03b.png" 
alt=""><br> 从这些指标出发，我们就可以得到，下面这个文件系统和磁盘 I/O 性能工具速查表。同 CPU 和内存性能工具一样，我也梳理出了这些工具的特点和注意事项。<br> 
<img src="https://static001.geekbang.org/resource/image/c2/a3/c232dcb4185f7b7ba95c126889cf6fa3.png" 
alt=""></p> <h2>网络性能工具</h2> <p>最后，从网络的角度来说，主要性能指标就是吞吐量、响应时间、连接数、丢包数等。根据 TCP/IP 网络协议栈的原理，我们可以把这些性能指标，进一步细化为每层协议的具体指标。这里我同样用一张图，分别从链路层、网络层、传输层和应用层，列出了各层的主要指标。<br> 
<img src="https://static001.geekbang.org/resource/image/37/a4/37d04c213acfa650bd7467e3000356a4.png" 
alt=""><br> 从这些指标出发，我们就可以得到下面的网络性能工具速查表。同样的，我也帮你梳理了各种工具的特点和注意事项。<br> <img src="https://static001.geekbang.org/resource/image/5d/5d/5dde213baffd7811ab73c82883b2a75d.png" 
alt=""></p> <h2>基准测试工具</h2> <p>除了性能分析外，很多时候，我们还需要对系统性能进行基准测试。比如，</p> <ul> <li> <p>在文件系统和磁盘 
I/O 模块中，我们使用 fio 工具，测试了磁盘 I/O 的性能。</p> </li> <li> <p>在网络模块中，我们使用 iperf、pktgen 等，测试了网络的性能。</p> 
</li> <li> <p>而在很多基于 Nginx 的案例中，我们则使用 ab、wrk 等，测试 Nginx 应用的性能。</p> </li> </ul> <p>除了专栏里介绍过的这些工具外，对于 
Linux 的各个子系统来说，还有很多其他的基准测试工具可能会用到。下面这张图，是 Brendan Gregg 整理的 Linux 基准测试工具图谱，你可以保存下来，在需要时参考。<br> 
<img src="https://static001.geekbang.org/resource/image/f0/e9/f094f489049602e1058e02edc708e6e9.png" 
alt=""><br> （图片来自 <a href="http://www.brendangregg.com/linuxperf.html">brendangregg.com</a>）</p> 
<h2>小结</h2> <p>今天，我们一起梳理了常见的性能工具，并从 CPU、内存、文件系统和磁盘 I/O、网络以及基准测试等不同的角度，汇总了各类性能指标所对应的性能工具速查表。</p> 
<p>当分析性能问题时，大的来说，主要有这么两个步骤：</p> <ul> <li> <p>第一步，从性能瓶颈出发，根据系统和应用程序的运行原理，确认待分析的性能指标。</p> </li> 
<li> <p>第二步，根据这些图表，选出最合适的性能工具，然后了解并使用工具，从而更快观测到需要的性能数据。</p> </li> </ul> <p>虽然 Linux 的性能指标和性能工具都比较多，但熟悉了各指标含义后，你自然就会发现这些工具同性能指标间的关联。顺着这个思路往下走，掌握这些工具的选用其实并不难。</p> 
<p>当然，正如咱们专栏一直强调的，不要把性能工具当成性能分析和优化的全部。</p> <ul> <li> <p>一方面，性能分析和优化的核心，是对系统和应用程序运行原理的掌握，而性能工具只是辅助你更快完成这个过程的帮手。</p> 
</li> <li> <p>另一方面，完善的监控系统，可以提供绝大部分性能分析所需的基准数据。从这些数据中，你很可能就能大致定位出性能瓶颈，也就不用再去手动执行各类工具了。</p> 
</li> </ul> <h2>思考</h2> <p>最后，我想邀请你一起来聊聊，你都使用过哪些性能工具。你通常是怎么选择性能工具的？又是如何想到要用这些性能工具，来排查和分析性能问题的？你可以结合我的讲述，总结自己的思路。</p> 
<p>欢迎在留言区和我讨论，也欢迎你把这篇文章分享给你的同事、朋友。我们一起在实战中演练，在交流中进步。</p> <p><img src="https://static001.geekbang.org/resource/image/a3/e9/a396aed4116c2c989771c1295736abe9.jpg" 
alt=""></p>', body_summary='', bundle='book', delta=0, body_format='full_html', langcode='zh-hans', 
revision_id=1090 where entity_id=1090 
 {executed in 0 msec}
2020-11-25 10:24:43.364 INFO  jdbc.sqltiming Line:373 - select nodefiledd0_.nid as nid1_10_, nodefiledd0_.changed as changed2_10_, nodefiledd0_.created 
as created3_10_, nodefiledd0_.default_langcode as default_4_10_, nodefiledd0_.langcode as langcode5_10_, 
nodefiledd0_.promote as promote6_10_, nodefiledd0_.revision_translation_affected as revision7_10_, 
nodefiledd0_.status as status8_10_, nodefiledd0_.sticky as sticky9_10_, nodefiledd0_.title 
as title10_10_, nodefiledd0_.type as type11_10_, nodefiledd0_.uid as uid12_10_, nodefiledd0_.vid 
as vid13_10_ from node_field_data nodefiledd0_ where nodefiledd0_.nid=1090 
 {executed in 0 msec}
2020-11-25 10:24:43.365 INFO  jdbc.resultsettable Line:610 - 
|-----|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|-------------------|-----|----|-----|
|nid  |changed    |created    |default_langcode |langcode |promote |revision_translation_affected |status |sticky |title              |type |uid |vid  |
|-----|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|-------------------|-----|----|-----|
|1090 |1606115018 |1606115018 |1                |zh-hans  |0       |1                             |1      |0      |57丨套路篇：Linux性能工具速查 |book |1   |1090 |
|-----|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|-------------------|-----|----|-----|

2020-11-25 10:24:43.365 INFO  jdbc.sqltiming Line:373 - select nodefieldr0_.nid as nid1_11_0_, nodefieldr0_.changed as changed2_11_0_, nodefieldr0_.created 
as created3_11_0_, nodefieldr0_.default_langcode as default_4_11_0_, nodefieldr0_.langcode 
as langcode5_11_0_, nodefieldr0_.promote as promote6_11_0_, nodefieldr0_.revision_translation_affected 
as revision7_11_0_, nodefieldr0_.status as status8_11_0_, nodefieldr0_.sticky as sticky9_11_0_, 
nodefieldr0_.title as title10_11_0_, nodefieldr0_.uid as uid11_11_0_, nodefieldr0_.vid as vid12_11_0_ 
from node_field_revision nodefieldr0_ where nodefieldr0_.nid=1090 
 {executed in 0 msec}
2020-11-25 10:24:43.366 INFO  jdbc.resultsettable Line:610 - 
|---------|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|-------------------|----|-----|
|nid      |changed    |created    |default_langcode |langcode |promote |revision_translation_affected |status |sticky |title              |uid |vid  |
|---------|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|-------------------|----|-----|
|[unread] |1606115018 |1606115018 |1                |zh-hans  |0       |1                             |1      |0      |57丨套路篇：Linux性能工具速查 |1   |1090 |
|---------|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|-------------------|----|-----|

2020-11-25 10:24:43.368 INFO  jdbc.sqltiming Line:373 - update node_field_data set changed=1606271083, created=1606271083, default_langcode=1, langcode='zh-hans', 
promote=0, revision_translation_affected=1, status=1, sticky=0, title='57丨套路篇：Linux性能工具速查', 
type='book', uid=1, vid=1090 where nid=1090 
 {executed in 0 msec}
2020-11-25 10:24:43.368 INFO  jdbc.sqltiming Line:373 - update node_field_revision set changed=1606271083, created=1606271083, default_langcode=1, 
langcode='zh-hans', promote=0, revision_translation_affected=1, status=1, sticky=0, title='57丨套路篇：Linux性能工具速查', 
uid=1, vid=1090 where nid=1090 
 {executed in 0 msec}
2020-11-25 10:24:43.372 INFO  jdbc.sqltiming Line:373 - select bookfieldm0_.entity_id as entity_i1_8_, bookfieldm0_.bundle as bundle2_8_, bookfieldm0_.delta 
as delta3_8_, bookfieldm0_.langcode as langcode4_8_, bookfieldm0_.field_media_value as field_me5_8_, 
bookfieldm0_.revision_id as revision6_8_ from node__field_media bookfieldm0_ where bookfieldm0_.entity_id=1090 
 {executed in 0 msec}
2020-11-25 10:24:43.373 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------------|------------|
|entity_id |bundle |delta |langcode |field_media_value |revision_id |
|----------|-------|------|---------|------------------|------------|
|1090      |book   |0     |zh-hans  |                  |1090        |
|----------|-------|------|---------|------------------|------------|

2020-11-25 10:24:43.375 INFO  jdbc.sqltiming Line:373 - select nodefieldm0_.entity_id as entity_i1_17_0_, nodefieldm0_.bundle as bundle2_17_0_, nodefieldm0_.delta 
as delta3_17_0_, nodefieldm0_.langcode as langcode4_17_0_, nodefieldm0_.field_media_value as 
field_me5_17_0_, nodefieldm0_.revision_id as revision6_17_0_ from node_revision__field_media 
nodefieldm0_ where nodefieldm0_.entity_id=1090 
 {executed in 0 msec}
2020-11-25 10:24:43.375 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------------|------------|
|entity_id |bundle |delta |langcode |field_media_value |revision_id |
|----------|-------|------|---------|------------------|------------|
|[unread]  |book   |0     |zh-hans  |                  |1090        |
|----------|-------|------|---------|------------------|------------|

2020-11-25 10:24:43.377 INFO  jdbc.sqltiming Line:373 - select bookfieldc0_.entity_id as entity_i1_5_, bookfieldc0_.bundle as bundle2_5_, bookfieldc0_.field_comment_value 
as field_co3_5_, bookfieldc0_.delta as delta4_5_, bookfieldc0_.field_comment_format as field_co5_5_, 
bookfieldc0_.langcode as langcode6_5_, bookfieldc0_.revision_id as revision7_5_ from node__field_comment 
bookfieldc0_ where bookfieldc0_.entity_id=1090 
 {executed in 0 msec}
2020-11-25 10:24:43.378 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|--------------------|------|---------------------|---------|------------|
|entity_id |bundle |field_comment_value |delta |field_comment_format |langcode |revision_id |
|----------|-------|--------------------|------|---------------------|---------|------------|
|1090      |book   |                    |0     |full_html            |zh-hans  |1090        |
|----------|-------|--------------------|------|---------------------|---------|------------|

2020-11-25 10:24:43.379 INFO  jdbc.sqltiming Line:373 - update node__field_comment set bundle='book', field_comment_value='<li class="reJj6Thl_0"><img 
src="https://static001.geekbang.org/account/avatar/00/11/9b/ba/333b59e5.jpg" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>Linuxer</span> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2019-04-08 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">6</span> </div> <!----> 
<!----> </div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 有一个问题请教，很多时候工具有了，但是对于指标是否在合理范围好像没有明确的标准，都是经验式的 
</div> <!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 嗯 这确实是经验式的，没有绝对的指标，不同应用不同场景都不太一样。不过USE法的这些指标都比较直观，可以优先查看</p> 
</div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/14/3a/6e/e39e90ca.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>大坏狐狸</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-04-15 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> </div> <!----> 
<!----> </div> </div> <div class="_3M6kV3zb_0"> 我看到nethogs的时候去尝试理解一下，结果v0.8.0 会有如下错误：creating 
socket failed while establishing local IP - are you root? <br>即使是root用户去执行。看网上说v0.8.1 解决了这个问题。所以就下载了8.5版本。 
<br> <br>wget -c https://github.com/raboof/nethogs/archive/v0.8.5.tar.gz <br>tar xf v0.8.5.tar.gz 
<br>cd ./nethogs-0.8.5/ <br> <br>sudo apt-get install libncurses5-dev libpcap-dev <br>make 
&amp;&amp; sudo make install </div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> 
</div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 👍 谢谢分享</p> </div> </div></li> 
<li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/10/4e/0f/c43745e7.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>hola</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-04-08 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> </div> <!----> 
<!----> </div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 可以做一期dtrace的讲解吗？感觉这个工具很厉害，但是挺复杂的 
</div> <!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: dtrace在linux上无法使用，其实我也不熟。官方网站上有个很详细的文档，可以去看看</p> 
</div> </div></li> <li class="reJj6Thl_0"><img src="https://wx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEKQMM4m7NHuicr55aRiblTSEWIYe0QqbpyHweaoAbG7j2v7UUElqqeP3Ihrm3UfDPDRb1Hv8LvPwXqA/132" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>ninuxer</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-04-08 </div> </div> <div 
class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> 
</div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0"> 打卡day61 <br>这工具，还是要经常用，感觉用各个模块的套路篇，来的更快点～ 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <!----> </div></li> 
<li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/12/c0/ce/fc41ad5e.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>陳先森</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-05-07 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 原理大致清楚，但是工具不是太熟悉···还是得多练，概念性的东西当时记住了后面又容易忘，知识还是要温故而知新···还是要多看几遍，多敲几遍才记得住。慢慢的干货 
</div> <!----> <!----> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>我来也</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-04-08 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> [D57打卡] <br>对性能分析的原理,比之前了解的多多了. <br>工具还是要经常用才行,不用就容易忘记. 
有时用man还可以想起一点点来. <br> <br>今天又把这些指标和工具又温习了一遍,以后也要常拿出来温习才行. <br>毕竟目前的主要工作还不是性能分析这一块. </div> <div 
class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <!----> </div></li>', 
delta=0, field_comment_format='full_html', langcode='zh-hans', revision_id=1090 where entity_id=1090 
 {executed in 0 msec}
2020-11-25 10:24:43.383 INFO  jdbc.sqltiming Line:373 - select nodefieldc0_.entity_id as entity_i1_14_0_, nodefieldc0_.bundle as bundle2_14_0_, nodefieldc0_.field_comment_value 
as field_co3_14_0_, nodefieldc0_.delta as delta4_14_0_, nodefieldc0_.field_comment_format as 
field_co5_14_0_, nodefieldc0_.langcode as langcode6_14_0_, nodefieldc0_.revision_id as revision7_14_0_ 
from node_revision__field_comment nodefieldc0_ where nodefieldc0_.entity_id=1090 
 {executed in 0 msec}
2020-11-25 10:24:43.384 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|--------------------|------|---------------------|---------|------------|
|entity_id |bundle |field_comment_value |delta |field_comment_format |langcode |revision_id |
|----------|-------|--------------------|------|---------------------|---------|------------|
|[unread]  |book   |                    |0     |full_html            |zh-hans  |1090        |
|----------|-------|--------------------|------|---------------------|---------|------------|

2020-11-25 10:24:43.385 INFO  jdbc.sqltiming Line:373 - update node_revision__field_comment set bundle='book', field_comment_value='<li class="reJj6Thl_0"><img 
src="https://static001.geekbang.org/account/avatar/00/11/9b/ba/333b59e5.jpg" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <span>Linuxer</span> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2019-04-08 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">6</span> </div> <!----> 
<!----> </div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 有一个问题请教，很多时候工具有了，但是对于指标是否在合理范围好像没有明确的标准，都是经验式的 
</div> <!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 嗯 这确实是经验式的，没有绝对的指标，不同应用不同场景都不太一样。不过USE法的这些指标都比较直观，可以优先查看</p> 
</div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/14/3a/6e/e39e90ca.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>大坏狐狸</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-04-15 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> </div> <!----> 
<!----> </div> </div> <div class="_3M6kV3zb_0"> 我看到nethogs的时候去尝试理解一下，结果v0.8.0 会有如下错误：creating 
socket failed while establishing local IP - are you root? <br>即使是root用户去执行。看网上说v0.8.1 解决了这个问题。所以就下载了8.5版本。 
<br> <br>wget -c https://github.com/raboof/nethogs/archive/v0.8.5.tar.gz <br>tar xf v0.8.5.tar.gz 
<br>cd ./nethogs-0.8.5/ <br> <br>sudo apt-get install libncurses5-dev libpcap-dev <br>make 
&amp;&amp; sudo make install </div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> 
</div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 👍 谢谢分享</p> </div> </div></li> 
<li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/10/4e/0f/c43745e7.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>hola</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-04-08 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> </div> <!----> 
<!----> </div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 可以做一期dtrace的讲解吗？感觉这个工具很厉害，但是挺复杂的 
</div> <!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: dtrace在linux上无法使用，其实我也不熟。官方网站上有个很详细的文档，可以去看看</p> 
</div> </div></li> <li class="reJj6Thl_0"><img src="https://wx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEKQMM4m7NHuicr55aRiblTSEWIYe0QqbpyHweaoAbG7j2v7UUElqqeP3Ihrm3UfDPDRb1Hv8LvPwXqA/132" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>ninuxer</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-04-08 </div> </div> <div 
class="_2eMTs2JE_0"> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> 
</div> <!----> <!----> </div> </div> <div class="_3M6kV3zb_0"> 打卡day61 <br>这工具，还是要经常用，感觉用各个模块的套路篇，来的更快点～ 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <!----> </div></li> 
<li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/12/c0/ce/fc41ad5e.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>陳先森</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-05-07 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 原理大致清楚，但是工具不是太熟悉···还是得多练，概念性的东西当时记住了后面又容易忘，知识还是要温故而知新···还是要多看几遍，多敲几遍才记得住。慢慢的干货 
</div> <!----> <!----> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<span>我来也</span> <!----> </div> <div class="_1H1Z49Dr_0"> 2019-04-08 </div> </div> <div class="_2eMTs2JE_0"> 
<div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> <!----> 
</div> </div> <div class="_3M6kV3zb_0"> [D57打卡] <br>对性能分析的原理,比之前了解的多多了. <br>工具还是要经常用才行,不用就容易忘记. 
有时用man还可以想起一点点来. <br> <br>今天又把这些指标和工具又温习了一遍,以后也要常拿出来温习才行. <br>毕竟目前的主要工作还不是性能分析这一块. </div> <div 
class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <!----> </div></li>', 
delta=0, field_comment_format='full_html', langcode='zh-hans', revision_id=1090 where entity_id=1090 
 {executed in 0 msec}
2020-11-25 10:24:43.389 INFO  jdbc.sqltiming Line:373 - select bookfieldt0_.entity_id as entity_i1_9_, bookfieldt0_.bundle as bundle2_9_, bookfieldt0_.delta 
as delta3_9_, bookfieldt0_.langcode as langcode4_9_, bookfieldt0_.revision_id as revision5_9_, 
bookfieldt0_.field_thumb_value as field_th6_9_ from node__field_thumb bookfieldt0_ where bookfieldt0_.entity_id=1090 
 {executed in 0 msec}
2020-11-25 10:24:43.390 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------|------------------|
|entity_id |bundle |delta |langcode |revision_id |field_thumb_value |
|----------|-------|------|---------|------------|------------------|
|1090      |book   |0     |zh-hans  |1090        |                  |
|----------|-------|------|---------|------------|------------------|

2020-11-25 10:24:43.391 INFO  jdbc.sqltiming Line:373 - update node__field_thumb set bundle='book', delta=0, langcode='zh-hans', revision_id=1090, 
field_thumb_value='https://static001.geekbang.org/resource/image/d6/65/d617d2bfac973a06f35dd8cc1d458665.jpg' 
where entity_id=1090 
 {executed in 0 msec}
2020-11-25 10:24:43.395 INFO  jdbc.sqltiming Line:373 - select nodefieldt0_.entity_id as entity_i1_18_0_, nodefieldt0_.bundle as bundle2_18_0_, nodefieldt0_.delta 
as delta3_18_0_, nodefieldt0_.langcode as langcode4_18_0_, nodefieldt0_.revision_id as revision5_18_0_, 
nodefieldt0_.field_thumb_value as field_th6_18_0_ from node_revision__field_thumb nodefieldt0_ 
where nodefieldt0_.entity_id=1090 
 {executed in 0 msec}
2020-11-25 10:24:43.396 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------|------------------|
|entity_id |bundle |delta |langcode |revision_id |field_thumb_value |
|----------|-------|------|---------|------------|------------------|
|[unread]  |book   |0     |zh-hans  |1090        |                  |
|----------|-------|------|---------|------------|------------------|

2020-11-25 10:24:43.397 INFO  jdbc.sqltiming Line:373 - update node_revision__field_thumb set bundle='book', delta=0, langcode='zh-hans', revision_id=1090, 
field_thumb_value='https://static001.geekbang.org/resource/image/d6/65/d617d2bfac973a06f35dd8cc1d458665.jpg' 
where entity_id=1090 
 {executed in 0 msec}
2020-11-25 10:24:43.401 INFO  jdbc.sqltiming Line:373 - select bookfieldf0_.entity_id as entity_i1_6_0_, bookfieldf0_.bundle as bundle2_6_0_, bookfieldf0_.delta 
as delta3_6_0_, bookfieldf0_.field_fenlei_target_id as field_fe4_6_0_, bookfieldf0_.langcode 
as langcode5_6_0_, bookfieldf0_.revision_id as revision6_6_0_ from node__field_fenlei bookfieldf0_ 
where bookfieldf0_.entity_id=1090 
 {executed in 1 msec}
2020-11-25 10:24:43.401 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|-----------------------|---------|------------|
|entity_id |bundle |delta |field_fenlei_target_id |langcode |revision_id |
|----------|-------|------|-----------------------|---------|------------|
|[unread]  |book   |0     |1                      |zh-hans  |1090        |
|----------|-------|------|-----------------------|---------|------------|

2020-11-25 10:24:43.403 INFO  jdbc.sqltiming Line:373 - select nodefieldf0_.entity_id as entity_i1_15_0_, nodefieldf0_.bundle as bundle2_15_0_, nodefieldf0_.delta 
as delta3_15_0_, nodefieldf0_.field_fenlei_target_id as field_fe4_15_0_, nodefieldf0_.langcode 
as langcode5_15_0_, nodefieldf0_.revision_id as revision6_15_0_ from node_revision__field_fenlei 
nodefieldf0_ where nodefieldf0_.entity_id=1090 
 {executed in 0 msec}
2020-11-25 10:24:43.403 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|-----------------------|---------|------------|
|entity_id |bundle |delta |field_fenlei_target_id |langcode |revision_id |
|----------|-------|------|-----------------------|---------|------------|
|[unread]  |book   |0     |1                      |zh-hans  |1090        |
|----------|-------|------|-----------------------|---------|------------|

2020-11-25 10:24:43.405 INFO  jdbc.sqltiming Line:373 - select bookchecke0_.item_id as item_id1_2_, bookchecke0_.fsid as fsid2_2_, bookchecke0_.got 
as got3_2_, bookchecke0_.name as name4_2_, bookchecke0_.parse_fail as parse_fa5_2_, bookchecke0_.parsed 
as parsed6_2_, bookchecke0_.path as path7_2_, bookchecke0_.title as title8_2_, bookchecke0_.vid 
as vid9_2_ from book_check bookchecke0_ where bookchecke0_.got=0 limit 40, 20 
 {executed in 0 msec}
2020-11-25 10:24:43.406 INFO  jdbc.resultsettable Line:610 - 
|--------|-----------------|----|------------|------------------|-------|----------------------------------------------------------------|-------------------------------|-----|
|item_id |fsid             |got |name        |parse_fail        |parsed |path                                                            |title                          |vid  |
|--------|-----------------|----|------------|------------------|-------|----------------------------------------------------------------|-------------------------------|-----|
|1151    |938720136221467  |0   |net_content |                  |0      |123-检索技术核心20讲/02丨基础技术篇 (8讲)/01丨线性结构检索：从数组和链表的原理初窥检索本质.html      |01丨线性结构检索：从数组和链表的原理初窥检索本质      |1151 |
|1152    |1000974306826065 |0   |net_content |                  |0      |123-检索技术核心20讲/02丨基础技术篇 (8讲)/02丨非线性结构检索：数据频繁变化的情况下，如何高效检索？.html  |02丨非线性结构检索：数据频繁变化的情况下，如何高效检索？  |1152 |
|1153    |549182670159463  |0   |net_content |                  |0      |123-检索技术核心20讲/02丨基础技术篇 (8讲)/03丨哈希检索：如何根据用户ID快速查询用户信息？.html      |03丨哈希检索：如何根据用户ID快速查询用户信息？      |1153 |
|1154    |983423512582907  |0   |net_content |con_comment_thumb |0      |123-检索技术核心20讲/02丨基础技术篇 (8讲)/04丨状态检索：如何快速判断一个用户是否存在？.html        |04丨状态检索：如何快速判断一个用户是否存在？        |1154 |
|1174    |72544342599478   |0   |net_content |                  |0      |123-检索技术核心20讲/04丨系统案例篇 (4讲)/20丨推荐引擎：没有搜索词，“头条”怎么找到你感兴趣的文章？.html |20丨推荐引擎：没有搜索词，“头条”怎么找到你感兴趣的文章？ |1174 |
|1175    |18053060793446   |0   |net_content |                  |0      |123-检索技术核心20讲/05丨结束语 (2讲)/结束语丨成长和进化，技术如此，我们亦如此.html             |结束语丨成长和进化，技术如此，我们亦如此           |1175 |
|1176    |897380553874887  |0   |net_content |                  |0      |123-检索技术核心20讲/05丨结束语 (2讲)/结课测试丨这些检索知识，你都掌握了吗？.html              |结课测试丨这些检索知识，你都掌握了吗？            |1176 |
|--------|-----------------|----|------------|------------------|-------|----------------------------------------------------------------|-------------------------------|-----|

2020-11-25 10:24:43.407 INFO  jdbc.sqltiming Line:373 - select bookchecke0_.item_id as item_id1_2_, bookchecke0_.fsid as fsid2_2_, bookchecke0_.got 
as got3_2_, bookchecke0_.name as name4_2_, bookchecke0_.parse_fail as parse_fa5_2_, bookchecke0_.parsed 
as parsed6_2_, bookchecke0_.path as path7_2_, bookchecke0_.title as title8_2_, bookchecke0_.vid 
as vid9_2_ from book_check bookchecke0_ where bookchecke0_.fsid='938720136221467' and bookchecke0_.name='net_content' 
 {executed in 1 msec}
2020-11-25 10:24:43.407 INFO  jdbc.resultsettable Line:610 - 
|--------|---------|---------|---------|-----------|---------|---------|---------|---------|
|item_id |fsid     |got      |name     |parse_fail |parsed   |path     |title    |vid      |
|--------|---------|---------|---------|-----------|---------|---------|---------|---------|
|1151    |[unread] |[unread] |[unread] |[unread]   |[unread] |[unread] |[unread] |[unread] |
|--------|---------|---------|---------|-----------|---------|---------|---------|---------|

2020-11-25 10:26:33.108 INFO  jdbc.sqltiming Line:373 - update book_check set fsid='938720136221467', got=1, name='net_content', parse_fail='', parsed=1, 
path='123-检索技术核心20讲/02丨基础技术篇 (8讲)/01丨线性结构检索：从数组和链表的原理初窥检索本质.html', title='01丨线性结构检索：从数组和链表的原理初窥检索本质', 
vid=1151 where item_id=1151 
 {executed in 0 msec}
2020-11-25 10:26:33.115 INFO  jdbc.sqltiming Line:373 - select nodebodyen0_.entity_id as entity_i1_4_, nodebodyen0_.body_value as body_val2_4_, nodebodyen0_.body_summary 
as body_sum3_4_, nodebodyen0_.bundle as bundle4_4_, nodebodyen0_.delta as delta5_4_, nodebodyen0_.body_format 
as body_for6_4_, nodebodyen0_.langcode as langcode7_4_, nodebodyen0_.revision_id as revision8_4_ 
from node__body nodebodyen0_ where nodebodyen0_.entity_id=1151 
 {executed in 0 msec}
2020-11-25 10:26:33.116 INFO  jdbc.resultsettable Line:610 - 
|----------|-----------|-------------|-------|------|------------|---------|------------|
|entity_id |body_value |body_summary |bundle |delta |body_format |langcode |revision_id |
|----------|-----------|-------------|-------|------|------------|---------|------------|
|1151      |           |             |book   |0     |full_html   |zh-hans  |1151        |
|----------|-----------|-------------|-------|------|------------|---------|------------|

2020-11-25 10:26:33.117 INFO  jdbc.sqltiming Line:373 - select nodebodyre0_.entity_id as entity_i1_13_0_, nodebodyre0_.body_value as body_val2_13_0_, 
nodebodyre0_.body_summary as body_sum3_13_0_, nodebodyre0_.bundle as bundle4_13_0_, nodebodyre0_.delta 
as delta5_13_0_, nodebodyre0_.body_format as body_for6_13_0_, nodebodyre0_.langcode as langcode7_13_0_, 
nodebodyre0_.revision_id as revision8_13_0_ from node_revision__body nodebodyre0_ where nodebodyre0_.entity_id=1151 
 {executed in 1 msec}
2020-11-25 10:26:33.117 INFO  jdbc.resultsettable Line:610 - 
|----------|-----------|-------------|-------|------|------------|---------|------------|
|entity_id |body_value |body_summary |bundle |delta |body_format |langcode |revision_id |
|----------|-----------|-------------|-------|------|------------|---------|------------|
|[unread]  |           |             |book   |0     |full_html   |zh-hans  |1151        |
|----------|-----------|-------------|-------|------|------------|---------|------------|

2020-11-25 10:26:33.120 INFO  jdbc.sqltiming Line:373 - update node__body set body_value='<div data-slate-editor="true" data-key="741" autocorrect="off" 
spellcheck="false" data-gramm="false" style="outline: none; white-space: pre-wrap; overflow-wrap: 
break-word;"> <div class="se-d07f120b " data-slate-type="paragraph" data-slate-object="block" 
data-key="742"> <span data-slate-object="text" data-key="743"><span data-slate-leaf="true" 
data-offset-key="743:0" data-first-offset="true"><span data-slate-string="true">你好，我是陈东。欢迎来到专栏的第一节，今天我们主要探讨的是，对于数组和链表这样的线性结构，我们是怎么检索的。希望通过这个探讨的过程，你能深入理解检索到底是什么。</span></span></span> 
</div> <div class="se-b72a5ab7 " data-slate-type="paragraph" data-slate-object="block" data-key="744"> 
<span data-slate-object="text" data-key="745"><span data-slate-leaf="true" data-offset-key="745:0" 
data-first-offset="true"><span data-slate-string="true">你可以先思考一个问题：什么是检索？从字面上来理解，检索其实就是将我们所需要的信息，从存储数据的地方高效取出的一种技术。所以，检索效率和数据存储的方式是紧密联系的。具体来说，就是不同的存储方式，会导致不同的检索效率。那么，研究数据结构的存储特点对检索效率的影响就很有必要了。</span></span></span> 
</div> <div class="se-d2e72183 " data-slate-type="paragraph" data-slate-object="block" data-key="746"> 
<span data-slate-object="text" data-key="747"><span data-slate-leaf="true" data-offset-key="747:0" 
data-first-offset="true"><span data-slate-string="true">那今天，我们就从数组和链表的存储特点入手，先来看一看它们是如何进行检索的。</span></span></span> 
</div> <h2 class="se-4af0e843" data-slate-type="heading" data-slate-object="block" data-key="748"><span 
data-slate-object="text" data-key="749"><span data-slate-leaf="true" data-offset-key="749:0" 
data-first-offset="true"><span data-slate-string="true">数组和链表有哪些存储特点？</span></span></span></h2> 
<div class="se-7ec466f1 " data-slate-type="paragraph" data-slate-object="block" data-key="750"> 
<span data-slate-object="text" data-key="751"><span data-slate-leaf="true" data-offset-key="751:0" 
data-first-offset="true"><span data-slate-string="true">数组的特点相信你已经很熟悉了，就是用一块连续的内存空间来存储数据。那如果我申请不到连续的内存空间怎么办？这时候链表就可以派上用场了。链表可以申请不连续的空间，通过一个指针按顺序将这些空间串起来，形成一条链，</span></span></span><span 
data-slate-object="text" data-key="752"><span data-slate-leaf="true" data-offset-key="752:0" 
data-first-offset="true"><span class="se-49cad77f" data-slate-type="bold" data-slate-object="mark"><span 
data-slate-string="true">链表</span></span></span></span><span data-slate-object="text" data-key="753"><span 
data-slate-leaf="true" data-offset-key="753:0" data-first-offset="true"><span data-slate-string="true">也正是因此得名。不过，严格意义上来说，这个叫</span></span></span><span 
data-slate-object="text" data-key="754"><span data-slate-leaf="true" data-offset-key="754:0" 
data-first-offset="true"><span class="se-64038bb3" data-slate-type="bold" data-slate-object="mark"><span 
data-slate-string="true">单链表</span></span></span></span><span data-slate-object="text" data-key="755"><span 
data-slate-leaf="true" data-offset-key="755:0" data-first-offset="true"><span data-slate-string="true">。如果没有特别说明，下面我所提到的链表，指的都是只有一个后续指针的单链表。</span></span></span> 
</div> <div class="se-168b2a8a" data-slate-type="image" data-slate-object="block" data-key="756"> 
<img class="se-c882819a" src="https://static001.geekbang.org/resource/image/ff/fc/fffe3e8a77e14f253078727b06e1cafc.jpeg"> 
</div> <div class="se-84518d78 " data-slate-type="paragraph" data-slate-object="block" data-key="757"> 
<span data-slate-object="text" data-key="758"><span data-slate-leaf="true" data-offset-key="758:0" 
data-first-offset="true"><span data-slate-string="true">从图片中我们可以看出，</span></span></span><span 
data-slate-object="text" data-key="759"><span data-slate-leaf="true" data-offset-key="759:0" 
data-first-offset="true"><span class="se-596a3324" data-slate-type="bold" data-slate-object="mark"><span 
data-slate-string="true">数组和链表分别代表了连续空间和不连续空间的最基础的存储方式，它们是线性表（Linear List）的典型代表。其他所有的数据结构，比如栈、队列、二叉树、B+ 
树等，都不外乎是这两者的结合和变化</span></span></span></span><span data-slate-object="text" data-key="760"><span 
data-slate-leaf="true" data-offset-key="760:0" data-first-offset="true"><span data-slate-string="true">。以栈为例，它本质就是一个限制了读写位置的数组，特点是只允许后进先出。</span></span></span> 
</div> <div class="se-d546f9a7 " data-slate-type="paragraph" data-slate-object="block" data-key="761"> 
<span data-slate-object="text" data-key="762"><span data-slate-leaf="true" data-offset-key="762:0" 
data-first-offset="true"><span data-slate-string="true">因此，</span></span></span><span data-slate-object="text" 
data-key="763"><span data-slate-leaf="true" data-offset-key="763:0" data-first-offset="true"><span 
class="se-cf86856d" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">我们只需要从最基础的数组和链表入手，结合实际应用中遇到的问题去思考解决方案，就能逐步地学习和了解更多的数据结构和检索技术。</span></span></span></span> 
</div> <div class="se-a45248e2 " data-slate-type="paragraph" data-slate-object="block" data-key="764"> 
<span data-slate-object="text" data-key="765"><span data-slate-leaf="true" data-offset-key="765:0" 
data-first-offset="true"><span data-slate-string="true">那么，数组和链表这两种线性的数据结构的检索效率究竟如何呢？我们来具体看一下。</span></span></span> 
</div> <h2 class="se-bfdf7658" data-slate-type="heading" data-slate-object="block" data-key="766"><span 
data-slate-object="text" data-key="767"><span data-slate-leaf="true" data-offset-key="767:0" 
data-first-offset="true"><span data-slate-string="true">如何使用二分查找提升数组的检索效率？</span></span></span></h2> 
<div class="se-62ec2a0c " data-slate-type="paragraph" data-slate-object="block" data-key="768"> 
<span data-slate-object="text" data-key="769"><span data-slate-leaf="true" data-offset-key="769:0" 
data-first-offset="true"><span data-slate-string="true">首先，如果数据是无序存储的话，无论是数组还是链表，想要查找一个指定元素是否存在，在缺乏数据分布信息的情况下，我们只能从头到尾遍历一遍，才能知道其是否存在。这样的检索效率就是 
O(n)。当然，如果数据集不大的话，其实直接遍历就可以了。但如果数据集规模较大的话，我们就需要考虑更高效的检索方式。</span></span></span> </div> <div 
class="se-3d59563b " data-slate-type="paragraph" data-slate-object="block" data-key="770"> 
<span data-slate-object="text" data-key="771"><span data-slate-leaf="true" data-offset-key="771:0" 
data-first-offset="true"><span data-slate-string="true">对于规模较大的数据集，我们往往是先将它通过排序算法转为有序的数据集，然后通过一些检索算法，比如</span></span></span><span 
data-slate-object="text" data-key="772"><span data-slate-leaf="true" data-offset-key="772:0" 
data-first-offset="true"><span class="se-3de66d33" data-slate-type="bold" data-slate-object="mark"><span 
data-slate-string="true">二分查找算法</span></span></span></span><span data-slate-object="text" data-key="773"><span 
data-slate-leaf="true" data-offset-key="773:0" data-first-offset="true"><span data-slate-string="true">来完成高效的检索。</span></span></span> 
</div> <div class="se-c481fd67 " data-slate-type="paragraph" data-slate-object="block" data-key="774"> 
<span data-slate-object="text" data-key="775"><span data-slate-leaf="true" data-offset-key="775:0" 
data-first-offset="true"><span data-slate-string="true">二分查找也叫折半查找，它的思路很直观，就是将有序数组二分为左右两个部分，通过只在半边进行查找来提升检索效率。那二分查找具体是怎么实现的呢？让我们一起来看看具体的实现步骤。</span></span></span> 
</div> <div class="se-7a48aaea " data-slate-type="paragraph" data-slate-object="block" data-key="776"> 
<span data-slate-object="text" data-key="777"><span data-slate-leaf="true" data-offset-key="777:0" 
data-first-offset="true"><span data-slate-string="true">我们首先会从中间的元素查起，这就会有三种查询结果。</span></span></span> 
</div> <div class="se-7b3b0eda " data-slate-type="paragraph" data-slate-object="block" data-key="778"> 
<span data-slate-object="text" data-key="779"><span data-slate-leaf="true" data-offset-key="779:0" 
data-first-offset="true"><span data-slate-string="true">第一种，是中间元素的值等于我们要查询的值。也就是，查到了，那直接返回即可。</span></span></span> 
</div> <div class="se-1d1591d6 " data-slate-type="paragraph" data-slate-object="block" data-key="780"> 
<span data-slate-object="text" data-key="781"><span data-slate-leaf="true" data-offset-key="781:0" 
data-first-offset="true"><span data-slate-string="true">如果中间元素的值小于我们想查询的值，那接下来该怎么查呢？这就是第二种情况了。数组是有序的，所以我们以中间元素为分隔，左半边的数组元素一定都小于中间元素，也就是小于我们想查询的值。因此，我们想查询的值只可能存在于右半边的数组中。</span></span></span> 
</div> <div class="se-f41d2f1c " data-slate-type="paragraph" data-slate-object="block" data-key="782"> 
<span data-slate-object="text" data-key="783"><span data-slate-leaf="true" data-offset-key="783:0" 
data-first-offset="true"><span data-slate-string="true">对于右半边的数组，我们还是可以继续使用二分查找的思路，再从它的中间查起，重复上面的过程。这样不停地“二分”下去，每次的检索空间都能减少一半，整体的平均查询效率就是 
O(log n)，远远小于遍历整个数组的代价 O(n)。</span></span></span> </div> <div class="se-e60adc81" data-slate-type="image" 
data-slate-object="block" data-key="784"> <img class="se-28e20c1e" src="https://static001.geekbang.org/resource/image/6b/a5/6bc7fb93746164ab1deccdda35d5d1a5.jpeg"> 
</div> <div class="se-44c5896b se-0a3b0490" data-slate-type="paragraph" data-slate-object="block" 
data-key="785"> <span data-slate-object="text" data-key="786"><span data-slate-leaf="true" 
data-offset-key="786:0" data-first-offset="true"><span class="se-919acb5a" data-slate-type="secondary" 
data-slate-object="mark"><span data-slate-string="true">二分查找图示</span></span></span></span> 
</div> <div class="se-57ac2d79 " data-slate-type="paragraph" data-slate-object="block" data-key="787"> 
<span data-slate-object="text" data-key="788"><span data-slate-leaf="true" data-offset-key="788:0" 
data-first-offset="true"><span data-slate-string="true">同理，对于第三种情况，如果中间元素的值大于我们想查询的值，那么我们就只在左边的数组元素查找即可。</span></span></span> 
</div> <div class="se-eb8c4f57 " data-slate-type="paragraph" data-slate-object="block" data-key="789"> 
<span data-slate-object="text" data-key="790"><span data-slate-leaf="true" data-offset-key="790:0" 
data-first-offset="true"><span data-slate-string="true">由此可见，合理地组织数据的存储可以提高检索效率。</span></span></span><span 
data-slate-object="text" data-key="791"><span data-slate-leaf="true" data-offset-key="791:0" 
data-first-offset="true"><span class="se-a87250d0" data-slate-type="bold" data-slate-object="mark"><span 
data-slate-string="true">检索的核心思路，其实就是通过合理组织数据，尽可能地快速减少查询范围。</span></span></span></span><span 
data-slate-object="text" data-key="792"><span data-slate-leaf="true" data-offset-key="792:0" 
data-first-offset="true"><span data-slate-string="true">在专栏后面的章节中，我们会看到更多的检索算法和技术，其实它们的本质都是通过灵活应用各种数据结构的特点来组织数据，从而达到快速减少查询范围的目的。</span></span></span> 
</div> <h2 class="se-b9ea8fda" data-slate-type="heading" data-slate-object="block" data-key="793"><span 
data-slate-object="text" data-key="794"><span data-slate-leaf="true" data-offset-key="794:0" 
data-first-offset="true"><span data-slate-string="true">链表在检索和动态调整上的优缺点</span></span></span></h2> 
<div class="se-599ab087 " data-slate-type="paragraph" data-slate-object="block" data-key="795"> 
<span data-slate-object="text" data-key="796"><span data-slate-leaf="true" data-offset-key="796:0" 
data-first-offset="true"><span data-slate-string="true">前面我们说了，数据无序存储的话，链表的检索效率很低。那你可能要问了，有序的链表好像也没法儿提高检索效率啊，这是为什么呢？你可以先停下来自己思考一下，然后再看我下面的讲解。</span></span></span> 
</div> <div class="se-59ea95bb " data-slate-type="paragraph" data-slate-object="block" data-key="797"> 
<span data-slate-object="text" data-key="798"><span data-slate-leaf="true" data-offset-key="798:0" 
data-first-offset="true"><span data-slate-string="true">数组的“连续空间存储”带来了可随机访问的特点。在有序数组应用二分查找时，它以 
O(1) 的时间代价就可以直接访问到位于中间的数值，然后以中间的数值为分界线，只选择左边或右边继续查找，从而能快速缩小查询范围。</span></span></span> </div> 
<div class="se-051a6d44 " data-slate-type="paragraph" data-slate-object="block" data-key="799"> 
<span data-slate-object="text" data-key="800"><span data-slate-leaf="true" data-offset-key="800:0" 
data-first-offset="true"><span data-slate-string="true">而链表并不具备“随机访问”的特点。当链表想要访问中间的元素时，我们必须从链表头开始，沿着链一步一步遍历过去，才能访问到期望的数值。如果要访问到中间的节点，我们就需要遍历一半的节点，时间代价已经是 
O(n/2) 了。从这个方面来看，由于少了“随机访问位置”的特性，链表的检索能力是偏弱的。</span></span></span> </div> <div class="se-d854e7df 
" data-slate-type="paragraph" data-slate-object="block" data-key="801"> <span data-slate-object="text" 
data-key="802"><span data-slate-leaf="true" data-offset-key="802:0" data-first-offset="true"><span 
data-slate-string="true">但是，任何事情都有两面性，</span></span></span><span data-slate-object="text" data-key="803"><span 
data-slate-leaf="true" data-offset-key="803:0" data-first-offset="true"><span class="se-1a658d27" 
data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">链表的检索能力偏弱，作为弥补，它在动态调整上会更容易。</span></span></span></span><span 
data-slate-object="text" data-key="804"><span data-slate-leaf="true" data-offset-key="804:0" 
data-first-offset="true"><span data-slate-string="true">我们可以以 O(1) 的时间代价完成节点的插入和删除，这是“连续空间”的数组所难以做到的。毕竟如果我们要在有序的数组中插入一个元素，为了保证“数组有序”，我们就需要将数组中排在这个元素后面的元素，全部顺序后移一位，这其实是一个 
O(n) 的时间代价了。</span></span></span> </div> <div class="se-e453bcd9" data-slate-type="image" data-slate-object="block" 
data-key="805"> <img class="se-97a571f6" src="https://static001.geekbang.org/resource/image/04/22/0491248d8fdbd4ed8c72e44d864b6222.jpeg"> 
</div> <div class="se-9375a0b3 se-451966b7" data-slate-type="paragraph" data-slate-object="block" 
data-key="806"> <span data-slate-object="text" data-key="807"><span data-slate-leaf="true" 
data-offset-key="807:0" data-first-offset="true"><span class="se-919acb5a" data-slate-type="secondary" 
data-slate-object="mark"><span data-slate-string="true">有序数组和链表插入新元素的操作和时间代价对比</span></span></span></span> 
</div> <div class="se-c7604219 " data-slate-type="paragraph" data-slate-object="block" data-key="808"> 
<span data-slate-object="text" data-key="809"><span data-slate-leaf="true" data-offset-key="809:0" 
data-first-offset="true"><span data-slate-string="true">因此，在一些需要频繁插入删除数据的场合，有序数组不见得是最合适的选择。另一方面，在数据量非常大的场合，我们也很难保证能申请到连续空间来构建有序数组。因此，学会合理高效地使用链表，也是非常重要的。</span></span></span> 
</div> <h2 class="se-7ca90880" data-slate-type="heading" data-slate-object="block" data-key="810"><span 
data-slate-object="text" data-key="811"><span data-slate-leaf="true" data-offset-key="811:0" 
data-first-offset="true"><span data-slate-string="true">如何灵活改造链表提升检索效率？</span></span></span></h2> 
<div class="se-b032da73 " data-slate-type="paragraph" data-slate-object="block" data-key="812"> 
<span data-slate-object="text" data-key="813"><span data-slate-leaf="true" data-offset-key="813:0" 
data-first-offset="true"><span class="se-b3300900" data-slate-type="bold" data-slate-object="mark"><span 
data-slate-string="true">本质上，我们学习链表，就是在学习“非连续存储空间”的组织方案。</span></span></span></span><span data-slate-object="text" 
data-key="814"><span data-slate-leaf="true" data-offset-key="814:0" data-first-offset="true"><span 
data-slate-string="true">我们知道，对于“非连续空间”，可以用指针将它串联成一个整体。只要掌握了这个思想，我们就可以在不同的应用场景中，设计出适用的数据结构，而不需要拘泥于链表自身的结构限制。</span></span></span> 
</div> <div class="se-333bafe8 " data-slate-type="paragraph" data-slate-object="block" data-key="815"> 
<span data-slate-object="text" data-key="816"><span data-slate-leaf="true" data-offset-key="816:0" 
data-first-offset="true"><span data-slate-string="true">我们可以来看一个简单的改造例子。</span></span></span> 
</div> <div class="se-d277e2b9 " data-slate-type="paragraph" data-slate-object="block" data-key="817"> 
<span data-slate-object="text" data-key="818"><span data-slate-leaf="true" data-offset-key="818:0" 
data-first-offset="true"><span data-slate-string="true">比如说，如果我们觉得链表一个节点一个节点遍历太慢，那么我们是不是可以对它做一个简单的改造呢？在掌握了链表的核心思想后，我们很容易就能想到一个改进方案，那就是让链表每个节点不再只是存储一个元素，而是存储一个小的数组。这样我们就能大幅减少节点的数量，从而减少依次遍历节点带来的“低寻址效率”。</span></span></span> 
</div> <div class="se-2c4bd006 " data-slate-type="paragraph" data-slate-object="block" data-key="819"> 
<span data-slate-object="text" data-key="820"><span data-slate-leaf="true" data-offset-key="820:0" 
data-first-offset="true"><span data-slate-string="true">比如说，我的链表就只有两个节点，每个节点都存储了一个小的有序数组。这样在检索的时候，我可以用二分查找的思想，先查询第一个节点存储的小数组的末尾元素，看看是否是我们要查询的数字。如果不是，我们要么在第一个节点存储的小数组里，继续二分查找；要么在第二个节点存储的小数组里，继续二分查找。这样的结构就能同时兼顾数组和链表的特点了，而且时间代价也是 
O(log n)。</span></span></span> </div> <div class="se-a38304a1" data-slate-type="image" data-slate-object="block" 
data-key="821"> <img class="se-399fdb20" src="https://static001.geekbang.org/resource/image/36/89/36bea4dfd90c5fa94fa7067b8b193789.jpg"> 
</div> <div class="se-0e489e40 se-faf7df88" data-slate-type="paragraph" data-slate-object="block" 
data-key="822"> <span data-slate-object="text" data-key="823"><span data-slate-leaf="true" 
data-offset-key="823:0" data-first-offset="true"><span class="se-919acb5a" data-slate-type="secondary" 
data-slate-object="mark"><span data-slate-string="true">改造的链表</span></span></span></span> </div> 
<div class="se-a1063030 " data-slate-type="paragraph" data-slate-object="block" data-key="824"> 
<span data-slate-object="text" data-key="825"><span data-slate-leaf="true" data-offset-key="825:0" 
data-first-offset="true"><span data-slate-string="true">可见，尽管常规的链表只能遍历检索，但是只要我们掌握了“非连续存储空间可以灵活调整”的特性，就可以设计更高效的数据结构和检索算法了。</span></span></span> 
</div> <h2 class="se-d512034c" data-slate-type="heading" data-slate-object="block" data-key="826"><span 
data-slate-object="text" data-key="827"><span data-slate-leaf="true" data-offset-key="827:0" 
data-first-offset="true"><span data-slate-string="true">重点回顾</span></span></span></h2> <div 
class="se-ebbc5ed8 " data-slate-type="paragraph" data-slate-object="block" data-key="828"> 
<span data-slate-object="text" data-key="829"><span data-slate-leaf="true" data-offset-key="829:0" 
data-first-offset="true"><span data-slate-string="true">好了，这一讲的内容差不多了，我们一起回顾一下这一讲的主要内容：以数组和链表为代表的线性结构的检索技术和效率分析。</span></span></span> 
</div> <div class="se-d00e2c41 " data-slate-type="paragraph" data-slate-object="block" data-key="830"> 
<span data-slate-object="text" data-key="831"><span data-slate-leaf="true" data-offset-key="831:0" 
data-first-offset="true"><span data-slate-string="true">首先，我们学习了具体的检索方法。对于无序数组，我们可以遍历检索。对于有序数组，我们可以用二分查找。链表具有灵活调整能力，适合用在数据频繁修改的场合。</span></span></span> 
</div> <div class="se-29c244dc " data-slate-type="paragraph" data-slate-object="block" data-key="832"> 
<span data-slate-object="text" data-key="833"><span data-slate-leaf="true" data-offset-key="833:0" 
data-first-offset="true"><span data-slate-string="true">其次，你应该也开始体会到了检索的一些核心思想：合理组织数据，尽可能快速减少查询范围，可以提升检索效率。</span></span></span> 
</div> <div class="se-7b767d11 " data-slate-type="paragraph" data-slate-object="block" data-key="834"> 
<span data-slate-object="text" data-key="835"><span data-slate-leaf="true" data-offset-key="835:0" 
data-first-offset="true"><span data-slate-string="true">今天的内容其实不难，涉及的核心思想看起来也很简单，但是对于我们掌握检索这门技术非常重要，你一定要好好理解。</span></span></span> 
</div> <div class="se-fed9beb9 " data-slate-type="paragraph" data-slate-object="block" data-key="836"> 
<span data-slate-object="text" data-key="837"><span data-slate-leaf="true" data-offset-key="837:0" 
data-first-offset="true"><span data-slate-string="true">随着咱们的课程深入，后面我们会一一解锁更多高级的检索技术和复杂系统，但是核心思路都离不开我们今天所学的内容。</span></span></span> 
</div> <div class="se-0a0411d5 " data-slate-type="paragraph" data-slate-object="block" data-key="838"> 
<span data-slate-object="text" data-key="839"><span data-slate-leaf="true" data-offset-key="839:0" 
data-first-offset="true"><span data-slate-string="true">因此，从最基础的数组和链表入手，之后结合具体的问题去思考解决方案，这样可以帮助你一步一步建立起你的知识体系，从而更好地掌握检索原理，达到提高代码效率，提高系统设计能力的目的。</span></span></span> 
</div> <h2 class="se-69e0e78c" data-slate-type="heading" data-slate-object="block" data-key="840"><span 
data-slate-object="text" data-key="841"><span data-slate-leaf="true" data-offset-key="841:0" 
data-first-offset="true"><span data-slate-string="true">课堂讨论</span></span></span></h2> <div 
class="se-cca56306 " data-slate-type="paragraph" data-slate-object="block" data-key="842"> 
<span data-slate-object="text" data-key="843"><span data-slate-leaf="true" data-offset-key="843:0" 
data-first-offset="true"><span data-slate-string="true">结合今天学习的数组和链表的检索技术和效率分析，你可以思考一下这两个问题。</span></span></span> 
</div> <div class="se-4ea8f92f" data-slate-type="list" data-slate-object="block" data-key="844"> 
<div class="se-44338dfa" data-slate-type="list-line" data-slate-object="block" data-key="845"> 
<div class="se-dc9a8526 se-3e7e173b" data-code-line-number="1"></div> <div class="se-da849f50"> 
<span data-slate-object="text" data-key="846"><span data-slate-leaf="true" data-offset-key="846:0" 
data-first-offset="true"><span data-slate-string="true">对于有序数组的高效检索，我们为什么使用二分查找算法，而不是 3-7 分查找算法，或 
4-6 分查找算法？</span></span></span> </div> </div> <div class="se-6247212a" data-slate-type="list-line" 
data-slate-object="block" data-key="847"> <div class="se-2c7bf18e se-1e6b6d68" data-code-line-number="2"></div> 
<div class="se-7667a657"> <span data-slate-object="text" data-key="848"><span data-slate-leaf="true" 
data-offset-key="848:0" data-first-offset="true"><span data-slate-string="true">对于单个查询值 k，我们已经熟悉了如何使用二分查找。那给出两个查询值 
x 和 y 作为查询范围，如果要在有序数组中查找出大于 x 和小于 y 之间的所有元素，我们应该怎么做呢？</span></span></span> </div> </div> </div> 
<div class="se-75b4f814 " data-slate-type="paragraph" data-slate-object="block" data-key="849"> 
<span data-slate-object="text" data-key="850"><span data-slate-leaf="true" data-offset-key="850:0" 
data-first-offset="true"><span data-slate-string="true">欢迎在留言区畅所欲言，说出你的思考过程和最终答案。如果有收获，也欢迎把这篇文章分享给你的朋友。</span></span></span> 
</div> </div>', body_summary='', bundle='book', delta=0, body_format='full_html', langcode='zh-hans', 
revision_id=1151 where entity_id=1151 
 {executed in 1 msec}
2020-11-25 10:26:33.122 INFO  jdbc.sqltiming Line:373 - update node_revision__body set body_value='<div data-slate-editor="true" data-key="741" autocorrect="off" 
spellcheck="false" data-gramm="false" style="outline: none; white-space: pre-wrap; overflow-wrap: 
break-word;"> <div class="se-d07f120b " data-slate-type="paragraph" data-slate-object="block" 
data-key="742"> <span data-slate-object="text" data-key="743"><span data-slate-leaf="true" 
data-offset-key="743:0" data-first-offset="true"><span data-slate-string="true">你好，我是陈东。欢迎来到专栏的第一节，今天我们主要探讨的是，对于数组和链表这样的线性结构，我们是怎么检索的。希望通过这个探讨的过程，你能深入理解检索到底是什么。</span></span></span> 
</div> <div class="se-b72a5ab7 " data-slate-type="paragraph" data-slate-object="block" data-key="744"> 
<span data-slate-object="text" data-key="745"><span data-slate-leaf="true" data-offset-key="745:0" 
data-first-offset="true"><span data-slate-string="true">你可以先思考一个问题：什么是检索？从字面上来理解，检索其实就是将我们所需要的信息，从存储数据的地方高效取出的一种技术。所以，检索效率和数据存储的方式是紧密联系的。具体来说，就是不同的存储方式，会导致不同的检索效率。那么，研究数据结构的存储特点对检索效率的影响就很有必要了。</span></span></span> 
</div> <div class="se-d2e72183 " data-slate-type="paragraph" data-slate-object="block" data-key="746"> 
<span data-slate-object="text" data-key="747"><span data-slate-leaf="true" data-offset-key="747:0" 
data-first-offset="true"><span data-slate-string="true">那今天，我们就从数组和链表的存储特点入手，先来看一看它们是如何进行检索的。</span></span></span> 
</div> <h2 class="se-4af0e843" data-slate-type="heading" data-slate-object="block" data-key="748"><span 
data-slate-object="text" data-key="749"><span data-slate-leaf="true" data-offset-key="749:0" 
data-first-offset="true"><span data-slate-string="true">数组和链表有哪些存储特点？</span></span></span></h2> 
<div class="se-7ec466f1 " data-slate-type="paragraph" data-slate-object="block" data-key="750"> 
<span data-slate-object="text" data-key="751"><span data-slate-leaf="true" data-offset-key="751:0" 
data-first-offset="true"><span data-slate-string="true">数组的特点相信你已经很熟悉了，就是用一块连续的内存空间来存储数据。那如果我申请不到连续的内存空间怎么办？这时候链表就可以派上用场了。链表可以申请不连续的空间，通过一个指针按顺序将这些空间串起来，形成一条链，</span></span></span><span 
data-slate-object="text" data-key="752"><span data-slate-leaf="true" data-offset-key="752:0" 
data-first-offset="true"><span class="se-49cad77f" data-slate-type="bold" data-slate-object="mark"><span 
data-slate-string="true">链表</span></span></span></span><span data-slate-object="text" data-key="753"><span 
data-slate-leaf="true" data-offset-key="753:0" data-first-offset="true"><span data-slate-string="true">也正是因此得名。不过，严格意义上来说，这个叫</span></span></span><span 
data-slate-object="text" data-key="754"><span data-slate-leaf="true" data-offset-key="754:0" 
data-first-offset="true"><span class="se-64038bb3" data-slate-type="bold" data-slate-object="mark"><span 
data-slate-string="true">单链表</span></span></span></span><span data-slate-object="text" data-key="755"><span 
data-slate-leaf="true" data-offset-key="755:0" data-first-offset="true"><span data-slate-string="true">。如果没有特别说明，下面我所提到的链表，指的都是只有一个后续指针的单链表。</span></span></span> 
</div> <div class="se-168b2a8a" data-slate-type="image" data-slate-object="block" data-key="756"> 
<img class="se-c882819a" src="https://static001.geekbang.org/resource/image/ff/fc/fffe3e8a77e14f253078727b06e1cafc.jpeg"> 
</div> <div class="se-84518d78 " data-slate-type="paragraph" data-slate-object="block" data-key="757"> 
<span data-slate-object="text" data-key="758"><span data-slate-leaf="true" data-offset-key="758:0" 
data-first-offset="true"><span data-slate-string="true">从图片中我们可以看出，</span></span></span><span 
data-slate-object="text" data-key="759"><span data-slate-leaf="true" data-offset-key="759:0" 
data-first-offset="true"><span class="se-596a3324" data-slate-type="bold" data-slate-object="mark"><span 
data-slate-string="true">数组和链表分别代表了连续空间和不连续空间的最基础的存储方式，它们是线性表（Linear List）的典型代表。其他所有的数据结构，比如栈、队列、二叉树、B+ 
树等，都不外乎是这两者的结合和变化</span></span></span></span><span data-slate-object="text" data-key="760"><span 
data-slate-leaf="true" data-offset-key="760:0" data-first-offset="true"><span data-slate-string="true">。以栈为例，它本质就是一个限制了读写位置的数组，特点是只允许后进先出。</span></span></span> 
</div> <div class="se-d546f9a7 " data-slate-type="paragraph" data-slate-object="block" data-key="761"> 
<span data-slate-object="text" data-key="762"><span data-slate-leaf="true" data-offset-key="762:0" 
data-first-offset="true"><span data-slate-string="true">因此，</span></span></span><span data-slate-object="text" 
data-key="763"><span data-slate-leaf="true" data-offset-key="763:0" data-first-offset="true"><span 
class="se-cf86856d" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">我们只需要从最基础的数组和链表入手，结合实际应用中遇到的问题去思考解决方案，就能逐步地学习和了解更多的数据结构和检索技术。</span></span></span></span> 
</div> <div class="se-a45248e2 " data-slate-type="paragraph" data-slate-object="block" data-key="764"> 
<span data-slate-object="text" data-key="765"><span data-slate-leaf="true" data-offset-key="765:0" 
data-first-offset="true"><span data-slate-string="true">那么，数组和链表这两种线性的数据结构的检索效率究竟如何呢？我们来具体看一下。</span></span></span> 
</div> <h2 class="se-bfdf7658" data-slate-type="heading" data-slate-object="block" data-key="766"><span 
data-slate-object="text" data-key="767"><span data-slate-leaf="true" data-offset-key="767:0" 
data-first-offset="true"><span data-slate-string="true">如何使用二分查找提升数组的检索效率？</span></span></span></h2> 
<div class="se-62ec2a0c " data-slate-type="paragraph" data-slate-object="block" data-key="768"> 
<span data-slate-object="text" data-key="769"><span data-slate-leaf="true" data-offset-key="769:0" 
data-first-offset="true"><span data-slate-string="true">首先，如果数据是无序存储的话，无论是数组还是链表，想要查找一个指定元素是否存在，在缺乏数据分布信息的情况下，我们只能从头到尾遍历一遍，才能知道其是否存在。这样的检索效率就是 
O(n)。当然，如果数据集不大的话，其实直接遍历就可以了。但如果数据集规模较大的话，我们就需要考虑更高效的检索方式。</span></span></span> </div> <div 
class="se-3d59563b " data-slate-type="paragraph" data-slate-object="block" data-key="770"> 
<span data-slate-object="text" data-key="771"><span data-slate-leaf="true" data-offset-key="771:0" 
data-first-offset="true"><span data-slate-string="true">对于规模较大的数据集，我们往往是先将它通过排序算法转为有序的数据集，然后通过一些检索算法，比如</span></span></span><span 
data-slate-object="text" data-key="772"><span data-slate-leaf="true" data-offset-key="772:0" 
data-first-offset="true"><span class="se-3de66d33" data-slate-type="bold" data-slate-object="mark"><span 
data-slate-string="true">二分查找算法</span></span></span></span><span data-slate-object="text" data-key="773"><span 
data-slate-leaf="true" data-offset-key="773:0" data-first-offset="true"><span data-slate-string="true">来完成高效的检索。</span></span></span> 
</div> <div class="se-c481fd67 " data-slate-type="paragraph" data-slate-object="block" data-key="774"> 
<span data-slate-object="text" data-key="775"><span data-slate-leaf="true" data-offset-key="775:0" 
data-first-offset="true"><span data-slate-string="true">二分查找也叫折半查找，它的思路很直观，就是将有序数组二分为左右两个部分，通过只在半边进行查找来提升检索效率。那二分查找具体是怎么实现的呢？让我们一起来看看具体的实现步骤。</span></span></span> 
</div> <div class="se-7a48aaea " data-slate-type="paragraph" data-slate-object="block" data-key="776"> 
<span data-slate-object="text" data-key="777"><span data-slate-leaf="true" data-offset-key="777:0" 
data-first-offset="true"><span data-slate-string="true">我们首先会从中间的元素查起，这就会有三种查询结果。</span></span></span> 
</div> <div class="se-7b3b0eda " data-slate-type="paragraph" data-slate-object="block" data-key="778"> 
<span data-slate-object="text" data-key="779"><span data-slate-leaf="true" data-offset-key="779:0" 
data-first-offset="true"><span data-slate-string="true">第一种，是中间元素的值等于我们要查询的值。也就是，查到了，那直接返回即可。</span></span></span> 
</div> <div class="se-1d1591d6 " data-slate-type="paragraph" data-slate-object="block" data-key="780"> 
<span data-slate-object="text" data-key="781"><span data-slate-leaf="true" data-offset-key="781:0" 
data-first-offset="true"><span data-slate-string="true">如果中间元素的值小于我们想查询的值，那接下来该怎么查呢？这就是第二种情况了。数组是有序的，所以我们以中间元素为分隔，左半边的数组元素一定都小于中间元素，也就是小于我们想查询的值。因此，我们想查询的值只可能存在于右半边的数组中。</span></span></span> 
</div> <div class="se-f41d2f1c " data-slate-type="paragraph" data-slate-object="block" data-key="782"> 
<span data-slate-object="text" data-key="783"><span data-slate-leaf="true" data-offset-key="783:0" 
data-first-offset="true"><span data-slate-string="true">对于右半边的数组，我们还是可以继续使用二分查找的思路，再从它的中间查起，重复上面的过程。这样不停地“二分”下去，每次的检索空间都能减少一半，整体的平均查询效率就是 
O(log n)，远远小于遍历整个数组的代价 O(n)。</span></span></span> </div> <div class="se-e60adc81" data-slate-type="image" 
data-slate-object="block" data-key="784"> <img class="se-28e20c1e" src="https://static001.geekbang.org/resource/image/6b/a5/6bc7fb93746164ab1deccdda35d5d1a5.jpeg"> 
</div> <div class="se-44c5896b se-0a3b0490" data-slate-type="paragraph" data-slate-object="block" 
data-key="785"> <span data-slate-object="text" data-key="786"><span data-slate-leaf="true" 
data-offset-key="786:0" data-first-offset="true"><span class="se-919acb5a" data-slate-type="secondary" 
data-slate-object="mark"><span data-slate-string="true">二分查找图示</span></span></span></span> 
</div> <div class="se-57ac2d79 " data-slate-type="paragraph" data-slate-object="block" data-key="787"> 
<span data-slate-object="text" data-key="788"><span data-slate-leaf="true" data-offset-key="788:0" 
data-first-offset="true"><span data-slate-string="true">同理，对于第三种情况，如果中间元素的值大于我们想查询的值，那么我们就只在左边的数组元素查找即可。</span></span></span> 
</div> <div class="se-eb8c4f57 " data-slate-type="paragraph" data-slate-object="block" data-key="789"> 
<span data-slate-object="text" data-key="790"><span data-slate-leaf="true" data-offset-key="790:0" 
data-first-offset="true"><span data-slate-string="true">由此可见，合理地组织数据的存储可以提高检索效率。</span></span></span><span 
data-slate-object="text" data-key="791"><span data-slate-leaf="true" data-offset-key="791:0" 
data-first-offset="true"><span class="se-a87250d0" data-slate-type="bold" data-slate-object="mark"><span 
data-slate-string="true">检索的核心思路，其实就是通过合理组织数据，尽可能地快速减少查询范围。</span></span></span></span><span 
data-slate-object="text" data-key="792"><span data-slate-leaf="true" data-offset-key="792:0" 
data-first-offset="true"><span data-slate-string="true">在专栏后面的章节中，我们会看到更多的检索算法和技术，其实它们的本质都是通过灵活应用各种数据结构的特点来组织数据，从而达到快速减少查询范围的目的。</span></span></span> 
</div> <h2 class="se-b9ea8fda" data-slate-type="heading" data-slate-object="block" data-key="793"><span 
data-slate-object="text" data-key="794"><span data-slate-leaf="true" data-offset-key="794:0" 
data-first-offset="true"><span data-slate-string="true">链表在检索和动态调整上的优缺点</span></span></span></h2> 
<div class="se-599ab087 " data-slate-type="paragraph" data-slate-object="block" data-key="795"> 
<span data-slate-object="text" data-key="796"><span data-slate-leaf="true" data-offset-key="796:0" 
data-first-offset="true"><span data-slate-string="true">前面我们说了，数据无序存储的话，链表的检索效率很低。那你可能要问了，有序的链表好像也没法儿提高检索效率啊，这是为什么呢？你可以先停下来自己思考一下，然后再看我下面的讲解。</span></span></span> 
</div> <div class="se-59ea95bb " data-slate-type="paragraph" data-slate-object="block" data-key="797"> 
<span data-slate-object="text" data-key="798"><span data-slate-leaf="true" data-offset-key="798:0" 
data-first-offset="true"><span data-slate-string="true">数组的“连续空间存储”带来了可随机访问的特点。在有序数组应用二分查找时，它以 
O(1) 的时间代价就可以直接访问到位于中间的数值，然后以中间的数值为分界线，只选择左边或右边继续查找，从而能快速缩小查询范围。</span></span></span> </div> 
<div class="se-051a6d44 " data-slate-type="paragraph" data-slate-object="block" data-key="799"> 
<span data-slate-object="text" data-key="800"><span data-slate-leaf="true" data-offset-key="800:0" 
data-first-offset="true"><span data-slate-string="true">而链表并不具备“随机访问”的特点。当链表想要访问中间的元素时，我们必须从链表头开始，沿着链一步一步遍历过去，才能访问到期望的数值。如果要访问到中间的节点，我们就需要遍历一半的节点，时间代价已经是 
O(n/2) 了。从这个方面来看，由于少了“随机访问位置”的特性，链表的检索能力是偏弱的。</span></span></span> </div> <div class="se-d854e7df 
" data-slate-type="paragraph" data-slate-object="block" data-key="801"> <span data-slate-object="text" 
data-key="802"><span data-slate-leaf="true" data-offset-key="802:0" data-first-offset="true"><span 
data-slate-string="true">但是，任何事情都有两面性，</span></span></span><span data-slate-object="text" data-key="803"><span 
data-slate-leaf="true" data-offset-key="803:0" data-first-offset="true"><span class="se-1a658d27" 
data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">链表的检索能力偏弱，作为弥补，它在动态调整上会更容易。</span></span></span></span><span 
data-slate-object="text" data-key="804"><span data-slate-leaf="true" data-offset-key="804:0" 
data-first-offset="true"><span data-slate-string="true">我们可以以 O(1) 的时间代价完成节点的插入和删除，这是“连续空间”的数组所难以做到的。毕竟如果我们要在有序的数组中插入一个元素，为了保证“数组有序”，我们就需要将数组中排在这个元素后面的元素，全部顺序后移一位，这其实是一个 
O(n) 的时间代价了。</span></span></span> </div> <div class="se-e453bcd9" data-slate-type="image" data-slate-object="block" 
data-key="805"> <img class="se-97a571f6" src="https://static001.geekbang.org/resource/image/04/22/0491248d8fdbd4ed8c72e44d864b6222.jpeg"> 
</div> <div class="se-9375a0b3 se-451966b7" data-slate-type="paragraph" data-slate-object="block" 
data-key="806"> <span data-slate-object="text" data-key="807"><span data-slate-leaf="true" 
data-offset-key="807:0" data-first-offset="true"><span class="se-919acb5a" data-slate-type="secondary" 
data-slate-object="mark"><span data-slate-string="true">有序数组和链表插入新元素的操作和时间代价对比</span></span></span></span> 
</div> <div class="se-c7604219 " data-slate-type="paragraph" data-slate-object="block" data-key="808"> 
<span data-slate-object="text" data-key="809"><span data-slate-leaf="true" data-offset-key="809:0" 
data-first-offset="true"><span data-slate-string="true">因此，在一些需要频繁插入删除数据的场合，有序数组不见得是最合适的选择。另一方面，在数据量非常大的场合，我们也很难保证能申请到连续空间来构建有序数组。因此，学会合理高效地使用链表，也是非常重要的。</span></span></span> 
</div> <h2 class="se-7ca90880" data-slate-type="heading" data-slate-object="block" data-key="810"><span 
data-slate-object="text" data-key="811"><span data-slate-leaf="true" data-offset-key="811:0" 
data-first-offset="true"><span data-slate-string="true">如何灵活改造链表提升检索效率？</span></span></span></h2> 
<div class="se-b032da73 " data-slate-type="paragraph" data-slate-object="block" data-key="812"> 
<span data-slate-object="text" data-key="813"><span data-slate-leaf="true" data-offset-key="813:0" 
data-first-offset="true"><span class="se-b3300900" data-slate-type="bold" data-slate-object="mark"><span 
data-slate-string="true">本质上，我们学习链表，就是在学习“非连续存储空间”的组织方案。</span></span></span></span><span data-slate-object="text" 
data-key="814"><span data-slate-leaf="true" data-offset-key="814:0" data-first-offset="true"><span 
data-slate-string="true">我们知道，对于“非连续空间”，可以用指针将它串联成一个整体。只要掌握了这个思想，我们就可以在不同的应用场景中，设计出适用的数据结构，而不需要拘泥于链表自身的结构限制。</span></span></span> 
</div> <div class="se-333bafe8 " data-slate-type="paragraph" data-slate-object="block" data-key="815"> 
<span data-slate-object="text" data-key="816"><span data-slate-leaf="true" data-offset-key="816:0" 
data-first-offset="true"><span data-slate-string="true">我们可以来看一个简单的改造例子。</span></span></span> 
</div> <div class="se-d277e2b9 " data-slate-type="paragraph" data-slate-object="block" data-key="817"> 
<span data-slate-object="text" data-key="818"><span data-slate-leaf="true" data-offset-key="818:0" 
data-first-offset="true"><span data-slate-string="true">比如说，如果我们觉得链表一个节点一个节点遍历太慢，那么我们是不是可以对它做一个简单的改造呢？在掌握了链表的核心思想后，我们很容易就能想到一个改进方案，那就是让链表每个节点不再只是存储一个元素，而是存储一个小的数组。这样我们就能大幅减少节点的数量，从而减少依次遍历节点带来的“低寻址效率”。</span></span></span> 
</div> <div class="se-2c4bd006 " data-slate-type="paragraph" data-slate-object="block" data-key="819"> 
<span data-slate-object="text" data-key="820"><span data-slate-leaf="true" data-offset-key="820:0" 
data-first-offset="true"><span data-slate-string="true">比如说，我的链表就只有两个节点，每个节点都存储了一个小的有序数组。这样在检索的时候，我可以用二分查找的思想，先查询第一个节点存储的小数组的末尾元素，看看是否是我们要查询的数字。如果不是，我们要么在第一个节点存储的小数组里，继续二分查找；要么在第二个节点存储的小数组里，继续二分查找。这样的结构就能同时兼顾数组和链表的特点了，而且时间代价也是 
O(log n)。</span></span></span> </div> <div class="se-a38304a1" data-slate-type="image" data-slate-object="block" 
data-key="821"> <img class="se-399fdb20" src="https://static001.geekbang.org/resource/image/36/89/36bea4dfd90c5fa94fa7067b8b193789.jpg"> 
</div> <div class="se-0e489e40 se-faf7df88" data-slate-type="paragraph" data-slate-object="block" 
data-key="822"> <span data-slate-object="text" data-key="823"><span data-slate-leaf="true" 
data-offset-key="823:0" data-first-offset="true"><span class="se-919acb5a" data-slate-type="secondary" 
data-slate-object="mark"><span data-slate-string="true">改造的链表</span></span></span></span> </div> 
<div class="se-a1063030 " data-slate-type="paragraph" data-slate-object="block" data-key="824"> 
<span data-slate-object="text" data-key="825"><span data-slate-leaf="true" data-offset-key="825:0" 
data-first-offset="true"><span data-slate-string="true">可见，尽管常规的链表只能遍历检索，但是只要我们掌握了“非连续存储空间可以灵活调整”的特性，就可以设计更高效的数据结构和检索算法了。</span></span></span> 
</div> <h2 class="se-d512034c" data-slate-type="heading" data-slate-object="block" data-key="826"><span 
data-slate-object="text" data-key="827"><span data-slate-leaf="true" data-offset-key="827:0" 
data-first-offset="true"><span data-slate-string="true">重点回顾</span></span></span></h2> <div 
class="se-ebbc5ed8 " data-slate-type="paragraph" data-slate-object="block" data-key="828"> 
<span data-slate-object="text" data-key="829"><span data-slate-leaf="true" data-offset-key="829:0" 
data-first-offset="true"><span data-slate-string="true">好了，这一讲的内容差不多了，我们一起回顾一下这一讲的主要内容：以数组和链表为代表的线性结构的检索技术和效率分析。</span></span></span> 
</div> <div class="se-d00e2c41 " data-slate-type="paragraph" data-slate-object="block" data-key="830"> 
<span data-slate-object="text" data-key="831"><span data-slate-leaf="true" data-offset-key="831:0" 
data-first-offset="true"><span data-slate-string="true">首先，我们学习了具体的检索方法。对于无序数组，我们可以遍历检索。对于有序数组，我们可以用二分查找。链表具有灵活调整能力，适合用在数据频繁修改的场合。</span></span></span> 
</div> <div class="se-29c244dc " data-slate-type="paragraph" data-slate-object="block" data-key="832"> 
<span data-slate-object="text" data-key="833"><span data-slate-leaf="true" data-offset-key="833:0" 
data-first-offset="true"><span data-slate-string="true">其次，你应该也开始体会到了检索的一些核心思想：合理组织数据，尽可能快速减少查询范围，可以提升检索效率。</span></span></span> 
</div> <div class="se-7b767d11 " data-slate-type="paragraph" data-slate-object="block" data-key="834"> 
<span data-slate-object="text" data-key="835"><span data-slate-leaf="true" data-offset-key="835:0" 
data-first-offset="true"><span data-slate-string="true">今天的内容其实不难，涉及的核心思想看起来也很简单，但是对于我们掌握检索这门技术非常重要，你一定要好好理解。</span></span></span> 
</div> <div class="se-fed9beb9 " data-slate-type="paragraph" data-slate-object="block" data-key="836"> 
<span data-slate-object="text" data-key="837"><span data-slate-leaf="true" data-offset-key="837:0" 
data-first-offset="true"><span data-slate-string="true">随着咱们的课程深入，后面我们会一一解锁更多高级的检索技术和复杂系统，但是核心思路都离不开我们今天所学的内容。</span></span></span> 
</div> <div class="se-0a0411d5 " data-slate-type="paragraph" data-slate-object="block" data-key="838"> 
<span data-slate-object="text" data-key="839"><span data-slate-leaf="true" data-offset-key="839:0" 
data-first-offset="true"><span data-slate-string="true">因此，从最基础的数组和链表入手，之后结合具体的问题去思考解决方案，这样可以帮助你一步一步建立起你的知识体系，从而更好地掌握检索原理，达到提高代码效率，提高系统设计能力的目的。</span></span></span> 
</div> <h2 class="se-69e0e78c" data-slate-type="heading" data-slate-object="block" data-key="840"><span 
data-slate-object="text" data-key="841"><span data-slate-leaf="true" data-offset-key="841:0" 
data-first-offset="true"><span data-slate-string="true">课堂讨论</span></span></span></h2> <div 
class="se-cca56306 " data-slate-type="paragraph" data-slate-object="block" data-key="842"> 
<span data-slate-object="text" data-key="843"><span data-slate-leaf="true" data-offset-key="843:0" 
data-first-offset="true"><span data-slate-string="true">结合今天学习的数组和链表的检索技术和效率分析，你可以思考一下这两个问题。</span></span></span> 
</div> <div class="se-4ea8f92f" data-slate-type="list" data-slate-object="block" data-key="844"> 
<div class="se-44338dfa" data-slate-type="list-line" data-slate-object="block" data-key="845"> 
<div class="se-dc9a8526 se-3e7e173b" data-code-line-number="1"></div> <div class="se-da849f50"> 
<span data-slate-object="text" data-key="846"><span data-slate-leaf="true" data-offset-key="846:0" 
data-first-offset="true"><span data-slate-string="true">对于有序数组的高效检索，我们为什么使用二分查找算法，而不是 3-7 分查找算法，或 
4-6 分查找算法？</span></span></span> </div> </div> <div class="se-6247212a" data-slate-type="list-line" 
data-slate-object="block" data-key="847"> <div class="se-2c7bf18e se-1e6b6d68" data-code-line-number="2"></div> 
<div class="se-7667a657"> <span data-slate-object="text" data-key="848"><span data-slate-leaf="true" 
data-offset-key="848:0" data-first-offset="true"><span data-slate-string="true">对于单个查询值 k，我们已经熟悉了如何使用二分查找。那给出两个查询值 
x 和 y 作为查询范围，如果要在有序数组中查找出大于 x 和小于 y 之间的所有元素，我们应该怎么做呢？</span></span></span> </div> </div> </div> 
<div class="se-75b4f814 " data-slate-type="paragraph" data-slate-object="block" data-key="849"> 
<span data-slate-object="text" data-key="850"><span data-slate-leaf="true" data-offset-key="850:0" 
data-first-offset="true"><span data-slate-string="true">欢迎在留言区畅所欲言，说出你的思考过程和最终答案。如果有收获，也欢迎把这篇文章分享给你的朋友。</span></span></span> 
</div> </div>', body_summary='', bundle='book', delta=0, body_format='full_html', langcode='zh-hans', 
revision_id=1151 where entity_id=1151 
 {executed in 0 msec}
2020-11-25 10:26:33.126 INFO  jdbc.sqltiming Line:373 - select nodefiledd0_.nid as nid1_10_, nodefiledd0_.changed as changed2_10_, nodefiledd0_.created 
as created3_10_, nodefiledd0_.default_langcode as default_4_10_, nodefiledd0_.langcode as langcode5_10_, 
nodefiledd0_.promote as promote6_10_, nodefiledd0_.revision_translation_affected as revision7_10_, 
nodefiledd0_.status as status8_10_, nodefiledd0_.sticky as sticky9_10_, nodefiledd0_.title 
as title10_10_, nodefiledd0_.type as type11_10_, nodefiledd0_.uid as uid12_10_, nodefiledd0_.vid 
as vid13_10_ from node_field_data nodefiledd0_ where nodefiledd0_.nid=1151 
 {executed in 0 msec}
2020-11-25 10:26:33.127 INFO  jdbc.resultsettable Line:610 - 
|-----|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|--------------------------|-----|----|-----|
|nid  |changed    |created    |default_langcode |langcode |promote |revision_translation_affected |status |sticky |title                     |type |uid |vid  |
|-----|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|--------------------------|-----|----|-----|
|1151 |1606115337 |1606115337 |1                |zh-hans  |0       |1                             |1      |0      |01丨线性结构检索：从数组和链表的原理初窥检索本质 |book |1   |1151 |
|-----|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|--------------------------|-----|----|-----|

2020-11-25 10:26:33.127 INFO  jdbc.sqltiming Line:373 - select nodefieldr0_.nid as nid1_11_0_, nodefieldr0_.changed as changed2_11_0_, nodefieldr0_.created 
as created3_11_0_, nodefieldr0_.default_langcode as default_4_11_0_, nodefieldr0_.langcode 
as langcode5_11_0_, nodefieldr0_.promote as promote6_11_0_, nodefieldr0_.revision_translation_affected 
as revision7_11_0_, nodefieldr0_.status as status8_11_0_, nodefieldr0_.sticky as sticky9_11_0_, 
nodefieldr0_.title as title10_11_0_, nodefieldr0_.uid as uid11_11_0_, nodefieldr0_.vid as vid12_11_0_ 
from node_field_revision nodefieldr0_ where nodefieldr0_.nid=1151 
 {executed in 0 msec}
2020-11-25 10:26:33.128 INFO  jdbc.resultsettable Line:610 - 
|---------|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|--------------------------|----|-----|
|nid      |changed    |created    |default_langcode |langcode |promote |revision_translation_affected |status |sticky |title                     |uid |vid  |
|---------|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|--------------------------|----|-----|
|[unread] |1606115337 |1606115337 |1                |zh-hans  |0       |1                             |1      |0      |01丨线性结构检索：从数组和链表的原理初窥检索本质 |1   |1151 |
|---------|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|--------------------------|----|-----|

2020-11-25 10:26:33.129 INFO  jdbc.sqltiming Line:373 - update node_field_data set changed=1606271193, created=1606271193, default_langcode=1, langcode='zh-hans', 
promote=0, revision_translation_affected=1, status=1, sticky=0, title='01丨线性结构检索：从数组和链表的原理初窥检索本质', 
type='book', uid=1, vid=1151 where nid=1151 
 {executed in 0 msec}
2020-11-25 10:26:33.130 INFO  jdbc.sqltiming Line:373 - update node_field_revision set changed=1606271193, created=1606271193, default_langcode=1, 
langcode='zh-hans', promote=0, revision_translation_affected=1, status=1, sticky=0, title='01丨线性结构检索：从数组和链表的原理初窥检索本质', 
uid=1, vid=1151 where nid=1151 
 {executed in 0 msec}
2020-11-25 10:26:33.133 INFO  jdbc.sqltiming Line:373 - select bookfieldm0_.entity_id as entity_i1_8_, bookfieldm0_.bundle as bundle2_8_, bookfieldm0_.delta 
as delta3_8_, bookfieldm0_.langcode as langcode4_8_, bookfieldm0_.field_media_value as field_me5_8_, 
bookfieldm0_.revision_id as revision6_8_ from node__field_media bookfieldm0_ where bookfieldm0_.entity_id=1151 
 {executed in 0 msec}
2020-11-25 10:26:33.134 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------------|------------|
|entity_id |bundle |delta |langcode |field_media_value |revision_id |
|----------|-------|------|---------|------------------|------------|
|1151      |book   |0     |zh-hans  |                  |1151        |
|----------|-------|------|---------|------------------|------------|

2020-11-25 10:26:33.136 INFO  jdbc.sqltiming Line:373 - select nodefieldm0_.entity_id as entity_i1_17_0_, nodefieldm0_.bundle as bundle2_17_0_, nodefieldm0_.delta 
as delta3_17_0_, nodefieldm0_.langcode as langcode4_17_0_, nodefieldm0_.field_media_value as 
field_me5_17_0_, nodefieldm0_.revision_id as revision6_17_0_ from node_revision__field_media 
nodefieldm0_ where nodefieldm0_.entity_id=1151 
 {executed in 1 msec}
2020-11-25 10:26:33.136 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------------|------------|
|entity_id |bundle |delta |langcode |field_media_value |revision_id |
|----------|-------|------|---------|------------------|------------|
|[unread]  |book   |0     |zh-hans  |                  |1151        |
|----------|-------|------|---------|------------------|------------|

2020-11-25 10:26:33.138 INFO  jdbc.sqltiming Line:373 - select bookfieldc0_.entity_id as entity_i1_5_, bookfieldc0_.bundle as bundle2_5_, bookfieldc0_.field_comment_value 
as field_co3_5_, bookfieldc0_.delta as delta4_5_, bookfieldc0_.field_comment_format as field_co5_5_, 
bookfieldc0_.langcode as langcode6_5_, bookfieldc0_.revision_id as revision7_5_ from node__field_comment 
bookfieldc0_ where bookfieldc0_.entity_id=1151 
 {executed in 0 msec}
2020-11-25 10:26:33.139 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|--------------------|------|---------------------|---------|------------|
|entity_id |bundle |field_comment_value |delta |field_comment_format |langcode |revision_id |
|----------|-------|--------------------|------|---------------------|---------|------------|
|1151      |book   |                    |0     |full_html            |zh-hans  |1151        |
|----------|-------|--------------------|------|---------------------|---------|------------|

2020-11-25 10:26:33.141 INFO  jdbc.sqltiming Line:373 - update node__field_comment set bundle='book', field_comment_value='<li class="reJj6Thl_0"><img 
src="" class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div 
class="_18Dng5rT_0"> <a>TIGEREI</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-23 </div> 
</div> <!----> </div> <div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 按概率算，二分肯定所需信息量最小阿，log1/2+log1/2小于log0.4+log0.6 
</div> <!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 用信息论的知识来分析很棒！不过如果是46分的话，出现在6那边的概率是高的，信息量就变小了。可以类比抛硬币，如果硬币出现一面的概率很高，甚至总是出现正面，那么抛硬币的信息量就很小甚至为0。<br>不过，对于不熟悉信息论的小伙伴也不用担心，该专栏所有的内容都会以直观能理解的语言进行讲解。不会使用大量公式或理论，做到深入浅出，可以放心学习。</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">2</span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Xeo83bVRZgql985iaPL7vaXQoN6VdBgbS0VYRgu69d5MdfLM4lpp5GXTNMSnnNEuvdYhBdib5KrnicmdrbDoicnBtQ/132" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>pedro</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-23 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0"> 第一个问题，二分查找概率更加均匀，没有偏向任何一端，性能波动小，速度平稳。第二个问题一次性先用二分先找到x再二分找到y，中间的都是区间内的元素 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 没错！很清晰👍</p> </div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div 
class="_2jsFl-X0_0"> <i class="iconfont"></i> <span>1</span> </div> <div class="_2P4B1Hdm_0"> 
<i class="iconfont"></i> <span class="">2</span> </div> <!----> </div> </div> </div></li> 
<li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/0f/54/9a/76c0af70.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>每天晒白牙</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-24 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0"> 1.二分查找概率均匀 <br>2.分别用二分查找 x 和 y 对应的下标，然后取中间的数据 </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 
简明扼要👍</p> </div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>aoe</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-24 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0"> 问题1：难道是和太极的“阴阳”有关？所以一分为二。 <br>问题2： <br>&nbsp;&nbsp;1. 二分法查找出x、y； 
<br>&nbsp;&nbsp;2. x与y之间的所有元素就是的x到y索引的区间[x索引, y索引]包含的数据。 </div> <div class="_2r3UB1GX_0"> <span>展开</span><i 
class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: “太极生两仪，两仪生四象，四象生八卦”。你会发现，这就是一个不断二分的过程。可见，二分的思想在许多地方都有体现。<br>二分的好处是平衡。不会出现最差情况。如果是3－7分，那如果总是要在多数元素的这一半进行查找，那么查找次数就会变多。</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span>1</span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/14/1c/71/2f52da16.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>与你一起学算法</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-23 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0"> 对于第二题，有点疑惑想问下老师，对于正常的情况(x&lt;=y)，我想到的可以有两种方法去实现，第一种方法是先二分查找x,然后二分查找y,x和y之间的元素就是答案了。第二种方法就是只二分查找x或者y，然后去顺序遍历，和另一个去比较。但是我觉得这两种方法对于不同x和y效率应该是不一样的，有些情况第一种方法较快，有些情况第二种方法较快，想问下老师工业界中的产品(redis)是如何实现区间查询的呢？ 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">编辑回复: 非常好！你很好地实践了导读中的学习方法:“多问为什么，多对比不同的方法寻找优缺点”。<br>1.对于数组怎么范围的问题:<br>对x和y分别做两次二分查找，时间代价为log（n）+log（n）。<br>而对x做二分查找，再遍历到y，时间代价为log（n）+（y－x）。<br>发现没有，我们完全可以根据log（n）和（y－x）的大小进行预判，哪个更快就选哪个！<br>当然，除非y－x非常小，否则一般情况下log（n）会更小。<br><br>2.对于Redis是怎么实现的问题:<br>在下一课中，你会学习到，Redis是使用跳表实现的。而跳表是“非连续存储空间”。因此，它不能像数组一样，直接将x到y之间的元素快速复制出来到结果集合中，因此，它只能通过遍历的方式将范围查找的结果写入结果集合中。</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span>2</span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/15/63/6d/fba85466.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>念念碎的碎碎念</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-23 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0"> 个人觉得二分更方便，三七分和四六分都会让一边大一边小越来越难分 <br> <br>对有序数组，先查询最小值的索引，在查询最大值的索引，两者之间的所有值就是这个区间的所有元素 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 二分的确更方便，但不仅仅是代码方便，而是它更加平衡，整体性能稳定，能避免出现最坏情况，否则如果是一直在大的一边查找，那么查找次数就会变多</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/14/0f/53/92a50f01.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>徐洲更</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-23 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0"> 第一个思考题是不是二分更容易计算编写代码 <br>第二个思考题 先找第一个大于x 然后在找最后一个小于y 这样子就确定了区间。 
<br> </div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div 
class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 二分不不仅仅是容易写代码，更重要的是能均匀划分查询空间。避免出现最坏情况。否则如果一边大一边小，那么最坏情况下，会一直在大的一边进行查找，使得查找次数变多。</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/13/57/6e/dd0eee5f.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>夜空中最亮的星（华仔...</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-24 </div> </div> <!----> 
</div> <div> <div class="_3M6kV3zb_0"> 高手很多啊 </div> <div class="_2r3UB1GX_0"> <span>展开</span><i 
class="iconfont"></i> </div> <!----> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> 
<i class="iconfont"></i> <span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> 
<span class=""></span> </div> <!----> </div> </div> </div></li>', delta=0, field_comment_format='full_html', 
langcode='zh-hans', revision_id=1151 where entity_id=1151 
 {executed in 1 msec}
2020-11-25 10:26:33.144 INFO  jdbc.sqltiming Line:373 - select nodefieldc0_.entity_id as entity_i1_14_0_, nodefieldc0_.bundle as bundle2_14_0_, nodefieldc0_.field_comment_value 
as field_co3_14_0_, nodefieldc0_.delta as delta4_14_0_, nodefieldc0_.field_comment_format as 
field_co5_14_0_, nodefieldc0_.langcode as langcode6_14_0_, nodefieldc0_.revision_id as revision7_14_0_ 
from node_revision__field_comment nodefieldc0_ where nodefieldc0_.entity_id=1151 
 {executed in 0 msec}
2020-11-25 10:26:33.145 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|--------------------|------|---------------------|---------|------------|
|entity_id |bundle |field_comment_value |delta |field_comment_format |langcode |revision_id |
|----------|-------|--------------------|------|---------------------|---------|------------|
|[unread]  |book   |                    |0     |full_html            |zh-hans  |1151        |
|----------|-------|--------------------|------|---------------------|---------|------------|

2020-11-25 10:26:33.147 INFO  jdbc.sqltiming Line:373 - update node_revision__field_comment set bundle='book', field_comment_value='<li class="reJj6Thl_0"><img 
src="" class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div 
class="_18Dng5rT_0"> <a>TIGEREI</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-23 </div> 
</div> <!----> </div> <div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 按概率算，二分肯定所需信息量最小阿，log1/2+log1/2小于log0.4+log0.6 
</div> <!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 用信息论的知识来分析很棒！不过如果是46分的话，出现在6那边的概率是高的，信息量就变小了。可以类比抛硬币，如果硬币出现一面的概率很高，甚至总是出现正面，那么抛硬币的信息量就很小甚至为0。<br>不过，对于不熟悉信息论的小伙伴也不用担心，该专栏所有的内容都会以直观能理解的语言进行讲解。不会使用大量公式或理论，做到深入浅出，可以放心学习。</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">2</span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Xeo83bVRZgql985iaPL7vaXQoN6VdBgbS0VYRgu69d5MdfLM4lpp5GXTNMSnnNEuvdYhBdib5KrnicmdrbDoicnBtQ/132" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>pedro</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-23 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0"> 第一个问题，二分查找概率更加均匀，没有偏向任何一端，性能波动小，速度平稳。第二个问题一次性先用二分先找到x再二分找到y，中间的都是区间内的元素 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 没错！很清晰👍</p> </div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div 
class="_2jsFl-X0_0"> <i class="iconfont"></i> <span>1</span> </div> <div class="_2P4B1Hdm_0"> 
<i class="iconfont"></i> <span class="">2</span> </div> <!----> </div> </div> </div></li> 
<li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/0f/54/9a/76c0af70.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>每天晒白牙</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-24 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0"> 1.二分查找概率均匀 <br>2.分别用二分查找 x 和 y 对应的下标，然后取中间的数据 </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 
简明扼要👍</p> </div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>aoe</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-24 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0"> 问题1：难道是和太极的“阴阳”有关？所以一分为二。 <br>问题2： <br>&nbsp;&nbsp;1. 二分法查找出x、y； 
<br>&nbsp;&nbsp;2. x与y之间的所有元素就是的x到y索引的区间[x索引, y索引]包含的数据。 </div> <div class="_2r3UB1GX_0"> <span>展开</span><i 
class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: “太极生两仪，两仪生四象，四象生八卦”。你会发现，这就是一个不断二分的过程。可见，二分的思想在许多地方都有体现。<br>二分的好处是平衡。不会出现最差情况。如果是3－7分，那如果总是要在多数元素的这一半进行查找，那么查找次数就会变多。</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span>1</span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/14/1c/71/2f52da16.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>与你一起学算法</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-23 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0"> 对于第二题，有点疑惑想问下老师，对于正常的情况(x&lt;=y)，我想到的可以有两种方法去实现，第一种方法是先二分查找x,然后二分查找y,x和y之间的元素就是答案了。第二种方法就是只二分查找x或者y，然后去顺序遍历，和另一个去比较。但是我觉得这两种方法对于不同x和y效率应该是不一样的，有些情况第一种方法较快，有些情况第二种方法较快，想问下老师工业界中的产品(redis)是如何实现区间查询的呢？ 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">编辑回复: 非常好！你很好地实践了导读中的学习方法:“多问为什么，多对比不同的方法寻找优缺点”。<br>1.对于数组怎么范围的问题:<br>对x和y分别做两次二分查找，时间代价为log（n）+log（n）。<br>而对x做二分查找，再遍历到y，时间代价为log（n）+（y－x）。<br>发现没有，我们完全可以根据log（n）和（y－x）的大小进行预判，哪个更快就选哪个！<br>当然，除非y－x非常小，否则一般情况下log（n）会更小。<br><br>2.对于Redis是怎么实现的问题:<br>在下一课中，你会学习到，Redis是使用跳表实现的。而跳表是“非连续存储空间”。因此，它不能像数组一样，直接将x到y之间的元素快速复制出来到结果集合中，因此，它只能通过遍历的方式将范围查找的结果写入结果集合中。</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span>2</span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/15/63/6d/fba85466.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>念念碎的碎碎念</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-23 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0"> 个人觉得二分更方便，三七分和四六分都会让一边大一边小越来越难分 <br> <br>对有序数组，先查询最小值的索引，在查询最大值的索引，两者之间的所有值就是这个区间的所有元素 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 二分的确更方便，但不仅仅是代码方便，而是它更加平衡，整体性能稳定，能避免出现最坏情况，否则如果是一直在大的一边查找，那么查找次数就会变多</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/14/0f/53/92a50f01.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>徐洲更</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-23 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0"> 第一个思考题是不是二分更容易计算编写代码 <br>第二个思考题 先找第一个大于x 然后在找最后一个小于y 这样子就确定了区间。 
<br> </div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div 
class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 二分不不仅仅是容易写代码，更重要的是能均匀划分查询空间。避免出现最坏情况。否则如果一边大一边小，那么最坏情况下，会一直在大的一边进行查找，使得查找次数变多。</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/13/57/6e/dd0eee5f.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>夜空中最亮的星（华仔...</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-24 </div> </div> <!----> 
</div> <div> <div class="_3M6kV3zb_0"> 高手很多啊 </div> <div class="_2r3UB1GX_0"> <span>展开</span><i 
class="iconfont"></i> </div> <!----> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> 
<i class="iconfont"></i> <span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> 
<span class=""></span> </div> <!----> </div> </div> </div></li>', delta=0, field_comment_format='full_html', 
langcode='zh-hans', revision_id=1151 where entity_id=1151 
 {executed in 1 msec}
2020-11-25 10:26:33.150 INFO  jdbc.sqltiming Line:373 - select bookfieldt0_.entity_id as entity_i1_9_, bookfieldt0_.bundle as bundle2_9_, bookfieldt0_.delta 
as delta3_9_, bookfieldt0_.langcode as langcode4_9_, bookfieldt0_.revision_id as revision5_9_, 
bookfieldt0_.field_thumb_value as field_th6_9_ from node__field_thumb bookfieldt0_ where bookfieldt0_.entity_id=1151 
 {executed in 0 msec}
2020-11-25 10:26:33.150 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------|------------------|
|entity_id |bundle |delta |langcode |revision_id |field_thumb_value |
|----------|-------|------|---------|------------|------------------|
|1151      |book   |0     |zh-hans  |1151        |                  |
|----------|-------|------|---------|------------|------------------|

2020-11-25 10:26:33.152 INFO  jdbc.sqltiming Line:373 - update node__field_thumb set bundle='book', delta=0, langcode='zh-hans', revision_id=1151, 
field_thumb_value='https://static001.geekbang.org/resource/image/e7/3e/e7869128fe4551cacb9ee89fe75e583e.jpg' 
where entity_id=1151 
 {executed in 0 msec}
2020-11-25 10:26:33.155 INFO  jdbc.sqltiming Line:373 - select nodefieldt0_.entity_id as entity_i1_18_0_, nodefieldt0_.bundle as bundle2_18_0_, nodefieldt0_.delta 
as delta3_18_0_, nodefieldt0_.langcode as langcode4_18_0_, nodefieldt0_.revision_id as revision5_18_0_, 
nodefieldt0_.field_thumb_value as field_th6_18_0_ from node_revision__field_thumb nodefieldt0_ 
where nodefieldt0_.entity_id=1151 
 {executed in 0 msec}
2020-11-25 10:26:33.155 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------|------------------|
|entity_id |bundle |delta |langcode |revision_id |field_thumb_value |
|----------|-------|------|---------|------------|------------------|
|[unread]  |book   |0     |zh-hans  |1151        |                  |
|----------|-------|------|---------|------------|------------------|

2020-11-25 10:26:33.157 INFO  jdbc.sqltiming Line:373 - update node_revision__field_thumb set bundle='book', delta=0, langcode='zh-hans', revision_id=1151, 
field_thumb_value='https://static001.geekbang.org/resource/image/e7/3e/e7869128fe4551cacb9ee89fe75e583e.jpg' 
where entity_id=1151 
 {executed in 0 msec}
2020-11-25 10:26:33.160 INFO  jdbc.sqltiming Line:373 - select bookfieldf0_.entity_id as entity_i1_6_0_, bookfieldf0_.bundle as bundle2_6_0_, bookfieldf0_.delta 
as delta3_6_0_, bookfieldf0_.field_fenlei_target_id as field_fe4_6_0_, bookfieldf0_.langcode 
as langcode5_6_0_, bookfieldf0_.revision_id as revision6_6_0_ from node__field_fenlei bookfieldf0_ 
where bookfieldf0_.entity_id=1151 
 {executed in 0 msec}
2020-11-25 10:26:33.160 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|-----------------------|---------|------------|
|entity_id |bundle |delta |field_fenlei_target_id |langcode |revision_id |
|----------|-------|------|-----------------------|---------|------------|
|[unread]  |book   |0     |1                      |zh-hans  |1151        |
|----------|-------|------|-----------------------|---------|------------|

2020-11-25 10:26:33.162 INFO  jdbc.sqltiming Line:373 - select nodefieldf0_.entity_id as entity_i1_15_0_, nodefieldf0_.bundle as bundle2_15_0_, nodefieldf0_.delta 
as delta3_15_0_, nodefieldf0_.field_fenlei_target_id as field_fe4_15_0_, nodefieldf0_.langcode 
as langcode5_15_0_, nodefieldf0_.revision_id as revision6_15_0_ from node_revision__field_fenlei 
nodefieldf0_ where nodefieldf0_.entity_id=1151 
 {executed in 0 msec}
2020-11-25 10:26:33.163 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|-----------------------|---------|------------|
|entity_id |bundle |delta |field_fenlei_target_id |langcode |revision_id |
|----------|-------|------|-----------------------|---------|------------|
|[unread]  |book   |0     |1                      |zh-hans  |1151        |
|----------|-------|------|-----------------------|---------|------------|

2020-11-25 10:26:33.164 INFO  jdbc.sqltiming Line:373 - select bookchecke0_.item_id as item_id1_2_, bookchecke0_.fsid as fsid2_2_, bookchecke0_.got 
as got3_2_, bookchecke0_.name as name4_2_, bookchecke0_.parse_fail as parse_fa5_2_, bookchecke0_.parsed 
as parsed6_2_, bookchecke0_.path as path7_2_, bookchecke0_.title as title8_2_, bookchecke0_.vid 
as vid9_2_ from book_check bookchecke0_ where bookchecke0_.fsid='1000974306826065' and bookchecke0_.name='net_content' 
 {executed in 0 msec}
2020-11-25 10:26:33.165 INFO  jdbc.resultsettable Line:610 - 
|--------|---------|---------|---------|-----------|---------|---------|---------|---------|
|item_id |fsid     |got      |name     |parse_fail |parsed   |path     |title    |vid      |
|--------|---------|---------|---------|-----------|---------|---------|---------|---------|
|1152    |[unread] |[unread] |[unread] |[unread]   |[unread] |[unread] |[unread] |[unread] |
|--------|---------|---------|---------|-----------|---------|---------|---------|---------|

2020-11-25 10:29:05.645 INFO  jdbc.sqltiming Line:373 - update book_check set fsid='1000974306826065', got=1, name='net_content', parse_fail='', parsed=1, 
path='123-检索技术核心20讲/02丨基础技术篇 (8讲)/02丨非线性结构检索：数据频繁变化的情况下，如何高效检索？.html', title='02丨非线性结构检索：数据频繁变化的情况下，如何高效检索？', 
vid=1152 where item_id=1152 
 {executed in 0 msec}
2020-11-25 10:29:05.650 INFO  jdbc.sqltiming Line:373 - select nodebodyen0_.entity_id as entity_i1_4_, nodebodyen0_.body_value as body_val2_4_, nodebodyen0_.body_summary 
as body_sum3_4_, nodebodyen0_.bundle as bundle4_4_, nodebodyen0_.delta as delta5_4_, nodebodyen0_.body_format 
as body_for6_4_, nodebodyen0_.langcode as langcode7_4_, nodebodyen0_.revision_id as revision8_4_ 
from node__body nodebodyen0_ where nodebodyen0_.entity_id=1152 
 {executed in 0 msec}
2020-11-25 10:29:05.650 INFO  jdbc.resultsettable Line:610 - 
|----------|-----------|-------------|-------|------|------------|---------|------------|
|entity_id |body_value |body_summary |bundle |delta |body_format |langcode |revision_id |
|----------|-----------|-------------|-------|------|------------|---------|------------|
|1152      |           |             |book   |0     |full_html   |zh-hans  |1152        |
|----------|-----------|-------------|-------|------|------------|---------|------------|

2020-11-25 10:29:05.651 INFO  jdbc.sqltiming Line:373 - select nodebodyre0_.entity_id as entity_i1_13_0_, nodebodyre0_.body_value as body_val2_13_0_, 
nodebodyre0_.body_summary as body_sum3_13_0_, nodebodyre0_.bundle as bundle4_13_0_, nodebodyre0_.delta 
as delta5_13_0_, nodebodyre0_.body_format as body_for6_13_0_, nodebodyre0_.langcode as langcode7_13_0_, 
nodebodyre0_.revision_id as revision8_13_0_ from node_revision__body nodebodyre0_ where nodebodyre0_.entity_id=1152 
 {executed in 0 msec}
2020-11-25 10:29:05.651 INFO  jdbc.resultsettable Line:610 - 
|----------|-----------|-------------|-------|------|------------|---------|------------|
|entity_id |body_value |body_summary |bundle |delta |body_format |langcode |revision_id |
|----------|-----------|-------------|-------|------|------------|---------|------------|
|[unread]  |           |             |book   |0     |full_html   |zh-hans  |1152        |
|----------|-----------|-------------|-------|------|------------|---------|------------|

2020-11-25 10:29:05.654 INFO  jdbc.sqltiming Line:373 - update node__body set body_value='<div data-slate-editor="true" data-key="315" autocorrect="off" 
spellcheck="false" data-gramm="false" style="outline: none; white-space: pre-wrap; overflow-wrap: 
break-word;"> <div class="se-e93540ba " data-slate-type="paragraph" data-slate-object="block" 
data-key="316"> <span data-slate-object="text" data-key="317"><span data-slate-leaf="true" 
data-offset-key="317:0" data-first-offset="true"><span data-slate-string="true">你好，我是陈东。</span></span></span> 
</div> <div class="se-591508b6 " data-slate-type="paragraph" data-slate-object="block" data-key="318"> 
<span data-slate-object="text" data-key="319"><span data-slate-leaf="true" data-offset-key="319:0" 
data-first-offset="true"><span data-slate-string="true">当我们在电脑中查找文件的时候，我们一般习惯先打开相应的磁盘，再打开文件夹以及子文件夹，最后找到我们需要的文件。这其实就是一个检索路径。如果把所有的文件展开，这个查找路径其实是一个树状结构，也就是一个非线性结构，而不是一个所有文件平铺排列的线性结构。</span></span></span> 
</div> <div class="se-1b1c396d" data-slate-type="image" data-slate-object="block" data-key="320"> 
<img class="se-d084d69a" src="https://static001.geekbang.org/resource/image/18/46/1859310bd112d5479eac9c097db8b946.jpeg"> 
</div> <div class="se-6a26dfd7 se-44d1bf6d" data-slate-type="paragraph" data-slate-object="block" 
data-key="321"> <span data-slate-object="text" data-key="322"><span data-slate-leaf="true" 
data-offset-key="322:0" data-first-offset="true"><span class="se-76c2338e" data-slate-type="secondary" 
data-slate-object="mark"><span data-slate-string="true">树状结构：文件组织例子</span></span></span></span> 
</div> <div class="se-8d20b1a3 " data-slate-type="paragraph" data-slate-object="block" data-key="323"> 
<span data-slate-object="text" data-key="324"><span data-slate-leaf="true" data-offset-key="324:0" 
data-first-offset="true"><span data-slate-string="true">我们都知道，有层次的文件组织肯定比散乱平铺的文件更容易找到。这样熟悉的一个场景，是不是会给你一个启发：对于零散的数据，非线性的树状结构是否可以帮我们提高检索效率呢？</span></span></span> 
</div> <div class="se-f89f0233 " data-slate-type="paragraph" data-slate-object="block" data-key="325"> 
<span data-slate-object="text" data-key="326"><span data-slate-leaf="true" data-offset-key="326:0" 
data-first-offset="true"><span data-slate-string="true">另一方面，我们也知道，在数据频繁更新的场景中，连续存储的有序数组并不是最合适的存储方案。因为数组为了保持有序必须不停地重建和排序，系统检索性能就会急剧下降。但是，非连续存储的有序链表倒是具有高效插入新数据的能力。因此，我们能否结合上面的例子，使用非线性的树状结构来改造有序链表，让链表也具有二分查找的能力呢？今天，我们就来讨论一下这个问题。</span></span></span> 
</div> <h2 class="se-b9c9f9f8" data-slate-type="heading" data-slate-object="block" data-key="327"><span 
data-slate-object="text" data-key="328"><span data-slate-leaf="true" data-offset-key="328:0" 
data-first-offset="true"><span data-slate-string="true">树结构是如何进行二分查找的？</span></span></span></h2> 
<div class="se-f817cd14 " data-slate-type="paragraph" data-slate-object="block" data-key="329"> 
<span data-slate-object="text" data-key="330"><span data-slate-leaf="true" data-offset-key="330:0" 
data-first-offset="true"><span data-slate-string="true">上一讲我们讲了，因为链表并不具备“随机访问”的特点，所以二分查找无法生效。当链表想要访问中间的元素时，我们必须从链表头开始，沿着指针一步一步遍历，需要遍历一半的节点才能到达中间节点，时间代价是 
O(n/2)。而有序数组由于可以“随机访问”，因此只需要 O(1) 的时间代价就可以访问到中间节点了。</span></span></span> </div> <div class="se-8214f3a0 
" data-slate-type="paragraph" data-slate-object="block" data-key="331"> <span data-slate-object="text" 
data-key="332"><span data-slate-leaf="true" data-offset-key="332:0" data-first-offset="true"><span 
data-slate-string="true">那如果我们能在链表中以 O(1) 的时间代价快速访问到中间节点，是不是就可以和有序数组一样使用二分查找了？你先想想看该怎么做，然后我们一起来试着改造一下。</span></span></span> 
</div> <div class="se-17f8494e" data-slate-type="image" data-slate-object="block" data-key="333"> 
<img class="se-54b59566" src="https://static001.geekbang.org/resource/image/2c/ca/2c61d26ed919411dd9be1a94cefb30ca.jpg"> 
</div> <div class="se-6fcce1aa se-69e0dbf7" data-slate-type="paragraph" data-slate-object="block" 
data-key="334"> <span data-slate-object="text" data-key="335"><span data-slate-leaf="true" 
data-offset-key="335:0" data-first-offset="true"><span class="se-76c2338e" data-slate-type="secondary" 
data-slate-object="mark"><span data-slate-string="true">直接记录和访问中间节点</span></span></span></span> 
</div> <div class="se-b0b9267e " data-slate-type="paragraph" data-slate-object="block" data-key="336"> 
<span data-slate-object="text" data-key="337"><span data-slate-leaf="true" data-offset-key="337:0" 
data-first-offset="true"><span data-slate-string="true">既然我们希望能以 O(1) 的时间代价访问中间节点，那将这个节点直接记录下来是不是就可以了？因此，如果我们把中间节点 
M 拎出来单独记录，那我们的第一步操作就是直接访问这个中间节点，然后判断这个节点和要查找的元素是否相等。如果相等，则返回查询结果。如果节点元素大于要查找的元素，那我们就到左边的部分继续查找；反之，则在右边部分继续查找。</span></span></span> 
</div> <div class="se-c9adf328 " data-slate-type="paragraph" data-slate-object="block" data-key="338"> 
<span data-slate-object="text" data-key="339"><span data-slate-leaf="true" data-offset-key="339:0" 
data-first-offset="true"><span data-slate-string="true">对于左边或者右边的部分，我们可以将它们视为两个独立的子链表，依然沿用这个逻辑。如果想用 
O(1) 的时间代价就能访问这两个子链表的中间节点，我们就应该把左边的中间节点 L 和右边的中间节点 R，单独拎出来记录。</span></span></span> </div> <div 
class="se-9277a033 " data-slate-type="paragraph" data-slate-object="block" data-key="340"> 
<span data-slate-object="text" data-key="341"><span data-slate-leaf="true" data-offset-key="341:0" 
data-first-offset="true"><span data-slate-string="true">并且，由于我们是在访问完了 M 节点以后，才决定接下来该去访问左边的 
L 还是右边的 R。因此，我们需要将 L 和 M，R 和 M 连接起来。我们可以让 M 带有两个指针，一个左指针指向 L，一个右指针指向 R。这样，在访问 M 以后，一旦发现 M 不是我们要查找的节点，那么，我们接下来就可以通过指针快速访问到 
L 或者 R 了。</span></span></span> </div> <div class="se-dfd9e5cb" data-slate-type="image" data-slate-object="block" 
data-key="342"> <img class="se-28307b27" src="https://static001.geekbang.org/resource/image/d2/f4/d274bfacd98b00d82746cfeb838ec1f4.jpeg"> 
</div> <div class="se-58bc9406 se-23dac7f1" data-slate-type="paragraph" data-slate-object="block" 
data-key="343"> <span data-slate-object="text" data-key="344"><span data-slate-leaf="true" 
data-offset-key="344:0" data-first-offset="true"><span class="se-76c2338e" data-slate-type="secondary" 
data-slate-object="mark"><span data-slate-string="true">将 M 节点改为带两个指针，指向 L 节点和 R 节点</span></span></span></span> 
</div> <div class="se-d284c625 " data-slate-type="paragraph" data-slate-object="block" data-key="345"> 
<span data-slate-object="text" data-key="346"><span data-slate-leaf="true" data-offset-key="346:0" 
data-first-offset="true"><span data-slate-string="true">对于其余的节点，我们也可以进行同样的处理。下面这个结构，你是不是很熟悉？没错，这就是我们常见的二叉树。你可以再观察一下，这个二叉树和普通的二叉树有什么不一样？</span></span></span> 
</div> <div class="se-edfd3989" data-slate-type="image" data-slate-object="block" data-key="347"> 
<img class="se-4874e347" src="https://static001.geekbang.org/resource/image/bf/bb/bf8df69285c21e28b493bd2f7a0c1abb.jpeg"> 
</div> <div class="se-98f50542 se-856e8530" data-slate-type="paragraph" data-slate-object="block" 
data-key="348"> <span data-slate-object="text" data-key="349"><span data-slate-leaf="true" 
data-offset-key="349:0" data-first-offset="true"><span class="se-76c2338e" data-slate-type="secondary" 
data-slate-object="mark"><span data-slate-string="true">二叉检索树结构</span></span></span></span> 
</div> <div class="se-971577e6 " data-slate-type="paragraph" data-slate-object="block" data-key="350"> 
<span data-slate-object="text" data-key="351"><span data-slate-leaf="true" data-offset-key="351:0" 
data-first-offset="true"><span data-slate-string="true">没错，这个二叉树是有序的。它的左子树的所有节点的值都小于根节点，同时右子树所有节点的值都大于等于根节点。这样的有序结构，使得它能使用二分查找算法，快速地过滤掉一半的数据。具备了这样特点的二叉树，就是二叉检索树（Binary 
Search Tree），或者叫二叉排序树（Binary Sorted Tree）。</span></span></span> </div> <div class="se-8caefb77 
" data-slate-type="paragraph" data-slate-object="block" data-key="352"> <span data-slate-object="text" 
data-key="353"><span data-slate-leaf="true" data-offset-key="353:0" data-first-offset="true"><span 
data-slate-string="true">讲到这里，不知道你有没有发现，</span></span></span><span data-slate-object="text" 
data-key="354"><span data-slate-leaf="true" data-offset-key="354:0" data-first-offset="true"><span 
class="se-4ce93d93" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">尽管有序数组和二叉检索树，在数据结构形态上看起来差异很大，但是在提高检索效率上，它们的核心原理都是一致的。</span></span></span></span><span 
data-slate-object="text" data-key="355"><span data-slate-leaf="true" data-offset-key="355:0" 
data-first-offset="true"><span data-slate-string="true">那么，它们是如何提高检索效率的呢？核心原理又一致在哪里呢？接下来，我们就从两个主要方面来看。</span></span></span> 
</div> <div class="se-a0636e20" data-slate-type="list" data-slate-object="block" data-key="356"> 
<div class="se-eefcf1c8 se-a0726065" data-slate-type="list-line" data-slate-object="block" 
data-key="357"> <span data-slate-object="text" data-key="358"><span data-slate-leaf="true" 
data-offset-key="358:0" data-first-offset="true"><span data-slate-string="true">将数据有序化，并且根据数据存储的特点进行不同的组织。对于连续存储空间的数组而言，由于它具有“随机访问”的特性，因此直接存储即可；对于非连续存储空间的有序链表而言，由于它不具备“随机访问”的特性，因此，需要将它改造为可以快速访问到中间节点的树状结构。</span></span></span> 
</div> <div class="se-c7b737f7 se-526d58d7" data-slate-type="list-line" data-slate-object="block" 
data-key="359"> <span data-slate-object="text" data-key="360"><span data-slate-leaf="true" 
data-offset-key="360:0" data-first-offset="true"><span data-slate-string="true">在进行检索的时候，它们都是通过二分查找的思想从中间节点开始查起。如果不命中，会快速缩小一半的查询空间。这样不停迭代的查询方式，让检索的时间代价能达到 
O(log n) 这个级别。</span></span></span> </div> </div> <div class="se-e910ddbb " data-slate-type="paragraph" 
data-slate-object="block" data-key="361"> <span data-slate-object="text" data-key="362"><span 
data-slate-leaf="true" data-offset-key="362:0" data-first-offset="true"><span data-slate-string="true">说到这里，你可能会问，二叉检索树的检索时间代价一定是 
O(log n) 吗？其实不一定。</span></span></span> </div> <h2 class="se-93706f46" data-slate-type="heading" 
data-slate-object="block" data-key="363"><span data-slate-object="text" data-key="364"><span 
data-slate-leaf="true" data-offset-key="364:0" data-first-offset="true"><span data-slate-string="true">二叉检索树的检索空间平衡方案</span></span></span></h2> 
<div class="se-a31f81d1 " data-slate-type="paragraph" data-slate-object="block" data-key="365"> 
<span data-slate-object="text" data-key="366"><span data-slate-leaf="true" data-offset-key="366:0" 
data-first-offset="true"><span data-slate-string="true">我们先来看一个例子。假设，一个二叉树的每一个节点的左指针都是空的，右子树的值都大于根节点。那么它满足二叉检索树的特性，是一颗二叉检索树。但是，如果我们把左边的空指针忽略，你会发现它其实就是一个单链表！单链表的检索效率如何呢？其实是 
O(n)，而不是 O(log n)。</span></span></span> </div> <div class="se-17e81035" data-slate-type="image" 
data-slate-object="block" data-key="367"> <img class="se-e13e8b0d" src="https://static001.geekbang.org/resource/image/a9/eb/a9f61debcc5a5502f810b1c84ca682eb.jpeg"> 
</div> <div class="se-b5e057e7 se-50e1de4c" data-slate-type="paragraph" data-slate-object="block" 
data-key="368"> <span data-slate-object="text" data-key="369"><span data-slate-leaf="true" 
data-offset-key="369:0" data-first-offset="true"><span class="se-76c2338e" data-slate-type="secondary" 
data-slate-object="mark"><span data-slate-string="true">退化成链表的二叉检索树</span></span></span></span> 
</div> <div class="se-472f2c89 " data-slate-type="paragraph" data-slate-object="block" data-key="370"> 
<span data-slate-object="text" data-key="371"><span data-slate-leaf="true" data-offset-key="371:0" 
data-first-offset="true"><span data-slate-string="true">为什么会出现这样的情况呢？</span></span></span> 
</div> <div class="se-5a204baf " data-slate-type="paragraph" data-slate-object="block" data-key="372"> 
<span data-slate-object="text" data-key="373"><span data-slate-leaf="true" data-offset-key="373:0" 
data-first-offset="true"><span class="se-69789ed4" data-slate-type="bold" data-slate-object="mark"><span 
data-slate-string="true">最根本的原因是，这样的结构造成了检索空间不平衡。在当前节点不满足查询条件的时候，它无法把“一半的数据”过滤掉，而是只能过滤掉当前检索的这个节点。因此无法达到“快速减小查询范围”的目的。</span></span></span></span> 
</div> <div class="se-4f574001 " data-slate-type="paragraph" data-slate-object="block" data-key="374"> 
<span data-slate-object="text" data-key="375"><span data-slate-leaf="true" data-offset-key="375:0" 
data-first-offset="true"><span data-slate-string="true">因此，为了提升检索效率，我们应该尽可能地保证二叉检索树的平衡性，让左右子树尽可能差距不要太大。这样无论我们是继续往左边还是右边检索，都可以过滤掉一半左右的数据。</span></span></span> 
</div> <div class="se-8f423353 " data-slate-type="paragraph" data-slate-object="block" data-key="376"> 
<span data-slate-object="text" data-key="377"><span data-slate-leaf="true" data-offset-key="377:0" 
data-first-offset="true"><span data-slate-string="true">也正是为了解决这个问题，有更多的数据结构被发明了出来。比如：AVL 树（平衡二叉树）和红黑树，其实它们本质上都是二叉检索树，但它们都在保证左右子树差距不要太大上做了特殊的处理，保证了检索效率，让二叉检索树可以被广泛地使用。比如，我们常见的 
C++ 中的 Set 和 Map 等数据结构，底层就是用红黑树实现的。</span></span></span> </div> <div class="se-6a232cfe " data-slate-type="paragraph" 
data-slate-object="block" data-key="378"> <span data-slate-object="text" data-key="379"><span 
data-slate-leaf="true" data-offset-key="379:0" data-first-offset="true"><span data-slate-string="true">这里，我就不再详细介绍 
AVL 树和红黑树的具体实现了。为了保证检索效率，我们其实只需要在数据的组织上考虑检索空间的平衡划分就好了，这一点都是一样的。</span></span></span> </div> 
<h2 class="se-2285f453" data-slate-type="heading" data-slate-object="block" data-key="380"><span 
data-slate-object="text" data-key="381"><span data-slate-leaf="true" data-offset-key="381:0" 
data-first-offset="true"><span data-slate-string="true">跳表是如何进行二分查找的？</span></span></span></h2> 
<div class="se-d082b04d " data-slate-type="paragraph" data-slate-object="block" data-key="382"> 
<span data-slate-object="text" data-key="383"><span data-slate-leaf="true" data-offset-key="383:0" 
data-first-offset="true"><span data-slate-string="true">除了二叉检索树，有序链表还有其他快速访问中间节点的改造方案吗？我们知道，链表之所以访问中间节点的效率低，就是因为每个节点只存储了下一个节点的指针，要沿着这个指针遍历每个后续节点才能到达中间节点。那如果我们在节点上增加一个指针，指向更远的节点，比如说跳过后一个节点，直接指向后面第二个节点，那么沿着这个指针遍历，是不是遍历速度就翻倍了呢？</span></span></span> 
</div> <div class="se-928b2e4f " data-slate-type="paragraph" data-slate-object="block" data-key="384"> 
<span data-slate-object="text" data-key="385"><span data-slate-leaf="true" data-offset-key="385:0" 
data-first-offset="true"><span data-slate-string="true">同理，如果我们能增加更多的指针，提供不同步长的遍历能力，比如一次跳过 
4 个节点，甚至一半的节点，那我们是不是就可以更快速地访问到中间节点了呢？</span></span></span> </div> <div class="se-67567530 " 
data-slate-type="paragraph" data-slate-object="block" data-key="386"> <span data-slate-object="text" 
data-key="387"><span data-slate-leaf="true" data-offset-key="387:0" data-first-offset="true"><span 
data-slate-string="true">这当然是可以实现的。我们可以为链表的某些节点增加更多的指针。这些指针都指向不同距离的后续节点。这样一来，链表就具备了更高效的检索能力。这样的数据结构就是</span></span></span><span 
data-slate-object="text" data-key="388"><span data-slate-leaf="true" data-offset-key="388:0" 
data-first-offset="true"><span class="se-a0b405bc" data-slate-type="bold" data-slate-object="mark"><span 
data-slate-string="true">跳表</span></span></span></span><span data-slate-object="text" data-key="389"><span 
data-slate-leaf="true" data-offset-key="389:0" data-first-offset="true"><span data-slate-string="true">（Skip 
List）。</span></span></span> </div> <div class="se-4553fc1a " data-slate-type="paragraph" data-slate-object="block" 
data-key="390"> <span data-slate-object="text" data-key="391"><span data-slate-leaf="true" 
data-offset-key="391:0" data-first-offset="true"><span data-slate-string="true">一个理想的跳表，就是从链表头开始，用多个不同的步长，每隔 
2^n 个节点做一次直接链接（n 取值为 0，1，2……）。跳表中的每个节点都拥有多个不同步长的指针，我们可以在每个节点里，用一个数组 next 来记录这些指针。next 数组的大小就是这个节点的层数，next[0]就是第 
0 层的步长为 1 的指针，next[1]就是第 1 层的步长为 2 的指针，next[2]就是第 2 层的步长为 4 的指针，依此类推。你会发现，不同步长的指针，在链表中的分布是非常均匀的，这使得整个链表具有非常平衡的检索结构。</span></span></span> 
</div> <div class="se-e65cd2e1" data-slate-type="image" data-slate-object="block" data-key="392"> 
<img class="se-0a8502a5" src="https://static001.geekbang.org/resource/image/bb/77/bbae24216d975a014b6112dbce45ae77.jpg"> 
</div> <div class="se-c2c1a9ee se-bee9aec7" data-slate-type="paragraph" data-slate-object="block" 
data-key="393"> <span data-slate-object="text" data-key="394"><span data-slate-leaf="true" 
data-offset-key="394:0" data-first-offset="true"><span class="se-76c2338e" data-slate-type="secondary" 
data-slate-object="mark"><span data-slate-string="true">理想的跳表</span></span></span></span> </div> 
<div class="se-cfc3a07e " data-slate-type="paragraph" data-slate-object="block" data-key="395"> 
<span data-slate-object="text" data-key="396"><span data-slate-leaf="true" data-offset-key="396:0" 
data-first-offset="true"><span data-slate-string="true">举个例子，当我们要检索 k=a</span></span></span><span 
data-slate-type="sub" data-slate-object="inline" data-key="397" class="se-fb22f369"><span data-slate-object="text" 
data-key="398"><span data-slate-leaf="true" data-offset-key="398:0" data-first-offset="true"><span 
data-slate-string="true">6</span></span></span></span><span data-slate-object="text" data-key="399"><span 
data-slate-leaf="true" data-offset-key="399:0" data-first-offset="true"><span data-slate-string="true">时，从第一个节点 
a</span></span></span><span data-slate-type="sub" data-slate-object="inline" data-key="400" 
class="se-fb22f369"><span data-slate-object="text" data-key="401"><span data-slate-leaf="true" 
data-offset-key="401:0" data-first-offset="true"><span data-slate-string="true">1</span></span></span></span><span 
data-slate-object="text" data-key="402"><span data-slate-leaf="true" data-offset-key="402:0" 
data-first-offset="true"><span data-slate-string="true">开始，用最大步长的指针开始遍历，直接就可以访问到中间节点 a</span></span></span><span 
data-slate-type="sub" data-slate-object="inline" data-key="403" class="se-fb22f369"><span data-slate-object="text" 
data-key="404"><span data-slate-leaf="true" data-offset-key="404:0" data-first-offset="true"><span 
data-slate-string="true">5</span></span></span></span><span data-slate-object="text" data-key="405"><span 
data-slate-leaf="true" data-offset-key="405:0" data-first-offset="true"><span data-slate-string="true">。但是，如果沿着这个最大步长指针继续访问下去，下一个节点是大于 
k 的 a</span></span></span><span data-slate-type="sub" data-slate-object="inline" data-key="406" 
class="se-fb22f369"><span data-slate-object="text" data-key="407"><span data-slate-leaf="true" 
data-offset-key="407:0" data-first-offset="true"><span data-slate-string="true">9</span></span></span></span><span 
data-slate-object="text" data-key="408"><span data-slate-leaf="true" data-offset-key="408:0" 
data-first-offset="true"><span data-slate-string="true">，这说明 k 在 a</span></span></span><span 
data-slate-type="sub" data-slate-object="inline" data-key="409" class="se-fb22f369"><span data-slate-object="text" 
data-key="410"><span data-slate-leaf="true" data-offset-key="410:0" data-first-offset="true"><span 
data-slate-string="true">5</span></span></span></span><span data-slate-object="text" data-key="411"><span 
data-slate-leaf="true" data-offset-key="411:0" data-first-offset="true"><span data-slate-string="true">和 
a</span></span></span><span data-slate-type="sub" data-slate-object="inline" data-key="412" 
class="se-fb22f369"><span data-slate-object="text" data-key="413"><span data-slate-leaf="true" 
data-offset-key="413:0" data-first-offset="true"><span data-slate-string="true">9</span></span></span></span><span 
data-slate-object="text" data-key="414"><span data-slate-leaf="true" data-offset-key="414:0" 
data-first-offset="true"><span data-slate-string="true">之间。那么，我们就在 a</span></span></span><span 
data-slate-type="sub" data-slate-object="inline" data-key="415" class="se-fb22f369"><span data-slate-object="text" 
data-key="416"><span data-slate-leaf="true" data-offset-key="416:0" data-first-offset="true"><span 
data-slate-string="true">5</span></span></span></span><span data-slate-object="text" data-key="417"><span 
data-slate-leaf="true" data-offset-key="417:0" data-first-offset="true"><span data-slate-string="true">和 
a</span></span></span><span data-slate-type="sub" data-slate-object="inline" data-key="418" 
class="se-fb22f369"><span data-slate-object="text" data-key="419"><span data-slate-leaf="true" 
data-offset-key="419:0" data-first-offset="true"><span data-slate-string="true">9</span></span></span></span><span 
data-slate-object="text" data-key="420"><span data-slate-leaf="true" data-offset-key="420:0" 
data-first-offset="true"><span data-slate-string="true">之间，用小一个级别的步长继续查询。这时候，a</span></span></span><span 
data-slate-type="sub" data-slate-object="inline" data-key="421" class="se-fb22f369"><span data-slate-object="text" 
data-key="422"><span data-slate-leaf="true" data-offset-key="422:0" data-first-offset="true"><span 
data-slate-string="true">5</span></span></span></span><span data-slate-object="text" data-key="423"><span 
data-slate-leaf="true" data-offset-key="423:0" data-first-offset="true"><span data-slate-string="true">的下一个元素是 
a</span></span></span><span data-slate-type="sub" data-slate-object="inline" data-key="424" 
class="se-fb22f369"><span data-slate-object="text" data-key="425"><span data-slate-leaf="true" 
data-offset-key="425:0" data-first-offset="true"><span data-slate-string="true">7</span></span></span></span><span 
data-slate-object="text" data-key="426"><span data-slate-leaf="true" data-offset-key="426:0" 
data-first-offset="true"><span data-slate-string="true">，a</span></span></span><span data-slate-type="sub" 
data-slate-object="inline" data-key="427" class="se-fb22f369"><span data-slate-object="text" 
data-key="428"><span data-slate-leaf="true" data-offset-key="428:0" data-first-offset="true"><span 
data-slate-string="true">7</span></span></span></span><span data-slate-object="text" data-key="429"><span 
data-slate-leaf="true" data-offset-key="429:0" data-first-offset="true"><span data-slate-string="true">依然大于 
k 的值，因此，我们会继续在 a</span></span></span><span data-slate-type="sub" data-slate-object="inline" 
data-key="430" class="se-fb22f369"><span data-slate-object="text" data-key="431"><span data-slate-leaf="true" 
data-offset-key="431:0" data-first-offset="true"><span data-slate-string="true">5</span></span></span></span><span 
data-slate-object="text" data-key="432"><span data-slate-leaf="true" data-offset-key="432:0" 
data-first-offset="true"><span data-slate-string="true">和 a</span></span></span><span data-slate-type="sub" 
data-slate-object="inline" data-key="433" class="se-fb22f369"><span data-slate-object="text" 
data-key="434"><span data-slate-leaf="true" data-offset-key="434:0" data-first-offset="true"><span 
data-slate-string="true">7</span></span></span></span><span data-slate-object="text" data-key="435"><span 
data-slate-leaf="true" data-offset-key="435:0" data-first-offset="true"><span data-slate-string="true">之间，用再小一个级别的步长查找，这样就找到 
a</span></span></span><span data-slate-type="sub" data-slate-object="inline" data-key="436" 
class="se-fb22f369"><span data-slate-object="text" data-key="437"><span data-slate-leaf="true" 
data-offset-key="437:0" data-first-offset="true"><span data-slate-string="true">6</span></span></span></span><span 
data-slate-object="text" data-key="438"><span data-slate-leaf="true" data-offset-key="438:0" 
data-first-offset="true"><span data-slate-string="true">了。这个过程其实就是二分查找。时间代价是 O(log n)。</span></span></span> 
</div> <h2 class="se-d9d1298f" data-slate-type="heading" data-slate-object="block" data-key="439"><span 
data-slate-object="text" data-key="440"><span data-slate-leaf="true" data-offset-key="440:0" 
data-first-offset="true"><span data-slate-string="true">跳表的检索空间平衡方案</span></span></span></h2> 
<div class="se-6b90cfba " data-slate-type="paragraph" data-slate-object="block" data-key="441"> 
<span data-slate-object="text" data-key="442"><span data-slate-leaf="true" data-offset-key="442:0" 
data-first-offset="true"><span data-slate-string="true">不知道你有没有注意到，我在前面强调了一个词，那就是“理想的跳表”。为什么要叫它“理想”的跳表呢？难道在实际情况下，跳表不是这样实现的吗？的确不是。当我们要在跳表中插入元素时，节点之间的间隔距离就被改变了。如果要保证理想链表的每隔 
2^n 个节点做一次链接的特性，我们就需要重新修改许多节点的后续指针，这会带来很大的开销。</span></span></span> </div> <div class="se-af5ba176 
" data-slate-type="paragraph" data-slate-object="block" data-key="443"> <span data-slate-object="text" 
data-key="444"><span data-slate-leaf="true" data-offset-key="444:0" data-first-offset="true"><span 
data-slate-string="true">所以，在实际情况下，我们会在检索性能和修改指针代价之间做一个权衡。为了保证检索性能，我们不需要保证跳表是一个“理想”的平衡状态，只需要保证它在大概率上是平衡的就可以了。因此，当新节点插入时，我们不去修改已有的全部指针，而是仅针对新加入的节点为它建立相应的各级别的跳表指针。具体的操作过程，我们一起来看看。</span></span></span> 
</div> <div class="se-23033e0c " data-slate-type="paragraph" data-slate-object="block" data-key="445"> 
<span data-slate-object="text" data-key="446"><span data-slate-leaf="true" data-offset-key="446:0" 
data-first-offset="true"><span data-slate-string="true">首先，我们需要确认新加入的节点需要具有几层的指针。我们通过随机函数来生成层数，比如说，我们可以写一个函数 
RandomLevel()，以 (1/2)^n 的概率决定是否生成第 n 层。这样，通过简单的随机生成指针层数的方式，我们就可以保证指针的分布，在大概率上是平衡的。</span></span></span> 
</div> <div class="se-2b6d3fbb " data-slate-type="paragraph" data-slate-object="block" data-key="447"> 
<span data-slate-object="text" data-key="448"><span data-slate-leaf="true" data-offset-key="448:0" 
data-first-offset="true"><span data-slate-string="true">在确认了新节点的层数 n 以后，接下来，我们需要将新节点和前后的节点连接起来，也就是为每一层的指针建立前后连接关系。其实每一层的指针链接，你都可以看作是一个独立的单链表的修改，因此我们只需要用单链表插入节点的方式完成指针连接即可。</span></span></span> 
</div> <div class="se-5c858c1a " data-slate-type="paragraph" data-slate-object="block" data-key="449"> 
<span data-slate-object="text" data-key="450"><span data-slate-leaf="true" data-offset-key="450:0" 
data-first-offset="true"><span data-slate-string="true">这么说，可能你理解起来不是很直观，接下来，我通过一个具体的例子进一步给你解释一下。</span></span></span> 
</div> <div class="se-be4bc439 " data-slate-type="paragraph" data-slate-object="block" data-key="451"> 
<span data-slate-object="text" data-key="452"><span data-slate-leaf="true" data-offset-key="452:0" 
data-first-offset="true"><span data-slate-string="true">我们要在一个最高有 3 层指针的跳表中插入一个新元素 k，这个跳表的结构如下图所示。</span></span></span> 
</div> <div class="se-68c4ec26" data-slate-type="image" data-slate-object="block" data-key="453"> 
<img class="se-84d3261b" src="https://static001.geekbang.org/resource/image/dd/42/dd4a8d2cfc40d4825dc5951ddcce2442.jpg"> 
</div> <div class="se-d2dc68e3 " data-slate-type="paragraph" data-slate-object="block" data-key="454"> 
<span data-slate-object="text" data-key="455"><span data-slate-leaf="true" data-offset-key="455:0" 
data-first-offset="true"><span data-slate-string="true">假设我们通过跳表的检索已经确认了，k 应该插入到 a</span></span></span><span 
data-slate-type="sub" data-slate-object="inline" data-key="456" class="se-fb22f369"><span data-slate-object="text" 
data-key="457"><span data-slate-leaf="true" data-offset-key="457:0" data-first-offset="true"><span 
data-slate-string="true">6</span></span></span></span><span data-slate-object="text" data-key="458"><span 
data-slate-leaf="true" data-offset-key="458:0" data-first-offset="true"><span data-slate-string="true">和 
a</span></span></span><span data-slate-type="sub" data-slate-object="inline" data-key="459" 
class="se-fb22f369"><span data-slate-object="text" data-key="460"><span data-slate-leaf="true" 
data-offset-key="460:0" data-first-offset="true"><span data-slate-string="true">7</span></span></span></span><span 
data-slate-object="text" data-key="461"><span data-slate-leaf="true" data-offset-key="461:0" 
data-first-offset="true"><span data-slate-string="true">两个节点之间。那接下来，我们要先为新节点随机生成一个层数。假设生成的层数为 
2，那我们就要修改第 0 层和第 1 层的指针关系。对于第 0 层的链表，k 需要插入到 a</span></span></span><span data-slate-type="sub" 
data-slate-object="inline" data-key="462" class="se-fb22f369"><span data-slate-object="text" 
data-key="463"><span data-slate-leaf="true" data-offset-key="463:0" data-first-offset="true"><span 
data-slate-string="true">6</span></span></span></span><span data-slate-object="text" data-key="464"><span 
data-slate-leaf="true" data-offset-key="464:0" data-first-offset="true"><span data-slate-string="true">和 
a</span></span></span><span data-slate-type="sub" data-slate-object="inline" data-key="465" 
class="se-fb22f369"><span data-slate-object="text" data-key="466"><span data-slate-leaf="true" 
data-offset-key="466:0" data-first-offset="true"><span data-slate-string="true">7</span></span></span></span><span 
data-slate-object="text" data-key="467"><span data-slate-leaf="true" data-offset-key="467:0" 
data-first-offset="true"><span data-slate-string="true">之间，我们只需要修改 a</span></span></span><span 
data-slate-type="sub" data-slate-object="inline" data-key="468" class="se-fb22f369"><span data-slate-object="text" 
data-key="469"><span data-slate-leaf="true" data-offset-key="469:0" data-first-offset="true"><span 
data-slate-string="true">6</span></span></span></span><span data-slate-object="text" data-key="470"><span 
data-slate-leaf="true" data-offset-key="470:0" data-first-offset="true"><span data-slate-string="true">和 
a</span></span></span><span data-slate-type="sub" data-slate-object="inline" data-key="471" 
class="se-fb22f369"><span data-slate-object="text" data-key="472"><span data-slate-leaf="true" 
data-offset-key="472:0" data-first-offset="true"><span data-slate-string="true">7</span></span></span></span><span 
data-slate-object="text" data-key="473"><span data-slate-leaf="true" data-offset-key="473:0" 
data-first-offset="true"><span data-slate-string="true">的第 0 层指针；对于第 1 层的链表，k 需要插入到 a</span></span></span><span 
data-slate-type="sub" data-slate-object="inline" data-key="474" class="se-fb22f369"><span data-slate-object="text" 
data-key="475"><span data-slate-leaf="true" data-offset-key="475:0" data-first-offset="true"><span 
data-slate-string="true">5</span></span></span></span><span data-slate-object="text" data-key="476"><span 
data-slate-leaf="true" data-offset-key="476:0" data-first-offset="true"><span data-slate-string="true">和 
a</span></span></span><span data-slate-type="sub" data-slate-object="inline" data-key="477" 
class="se-fb22f369"><span data-slate-object="text" data-key="478"><span data-slate-leaf="true" 
data-offset-key="478:0" data-first-offset="true"><span data-slate-string="true">7</span></span></span></span><span 
data-slate-object="text" data-key="479"><span data-slate-leaf="true" data-offset-key="479:0" 
data-first-offset="true"><span data-slate-string="true">之间，我们只需要修改 a</span></span></span><span 
data-slate-type="sub" data-slate-object="inline" data-key="480" class="se-fb22f369"><span data-slate-object="text" 
data-key="481"><span data-slate-leaf="true" data-offset-key="481:0" data-first-offset="true"><span 
data-slate-string="true">5</span></span></span></span><span data-slate-object="text" data-key="482"><span 
data-slate-leaf="true" data-offset-key="482:0" data-first-offset="true"><span data-slate-string="true">和 
a</span></span></span><span data-slate-type="sub" data-slate-object="inline" data-key="483" 
class="se-fb22f369"><span data-slate-object="text" data-key="484"><span data-slate-leaf="true" 
data-offset-key="484:0" data-first-offset="true"><span data-slate-string="true">7</span></span></span></span><span 
data-slate-object="text" data-key="485"><span data-slate-leaf="true" data-offset-key="485:0" 
data-first-offset="true"><span data-slate-string="true">的第 1 层指针。这样，我们就完成了将 k 插入到跳表中的动作。</span></span></span> 
</div> <div class="se-36cbc7bb " data-slate-type="paragraph" data-slate-object="block" data-key="486"> 
<span data-slate-object="text" data-key="487"><span data-slate-leaf="true" data-offset-key="487:0" 
data-first-offset="true"><span data-slate-string="true">通过这样一种方式，我们可以大大减少修改指针的代价。当然，由于新加入节点的层数是随机生成的，因此在节点数目较少的情况下，如果指针分布的不合理，检索性能依然可能不高。但是当节点数较多的时候，指针会趋向均匀分布，查找空间会比较平衡，检索性能会趋向于理想跳表的检索效率，接近 
O(log n)。</span></span></span> </div> <div class="se-81e53879 " data-slate-type="paragraph" 
data-slate-object="block" data-key="488"> <span data-slate-object="text" data-key="489"><span 
data-slate-leaf="true" data-offset-key="489:0" data-first-offset="true"><span data-slate-string="true">因此，相比于复杂的平衡二叉检索树，如红黑树，跳表用一种更简单的方式实现了检索空间的平衡。并且，由于跳表保持了链表顺序遍历的能力，在需要遍历功能的场景中，跳表会比红黑树用起来更方便。这也就是为什么，在 
Redis 这样的系统中，我们经常会利用跳表来代替红黑树作为底层的数据结构。</span></span></span> </div> <h2 class="se-c0f8b013" 
data-slate-type="heading" data-slate-object="block" data-key="490"><span data-slate-object="text" 
data-key="491"><span data-slate-leaf="true" data-offset-key="491:0" data-first-offset="true"><span 
data-slate-string="true">重点回顾</span></span></span></h2> <div class="se-8b380896 " data-slate-type="paragraph" 
data-slate-object="block" data-key="492"> <span data-slate-object="text" data-key="493"><span 
data-slate-leaf="true" data-offset-key="493:0" data-first-offset="true"><span data-slate-string="true">好了，关于非线性结构的检索技术，我们就先讲到这里。我们一起回顾一下今天的重点内容。</span></span></span> 
</div> <div class="se-4c2a3a91 " data-slate-type="paragraph" data-slate-object="block" data-key="494"> 
<span data-slate-object="text" data-key="495"><span data-slate-leaf="true" data-offset-key="495:0" 
data-first-offset="true"><span data-slate-string="true">首先，对于数据频繁变化的应用场景，有序数组并不是最适合的解决方案。我们一般要考虑采用非连续存储的数据结构来灵活调整。同时，为了提高检索效率，我们还要采取合理的组织方式，让这些非连续存储的数据结构能够使用二分查找算法。</span></span></span> 
</div> <div class="se-8d0001b8 " data-slate-type="paragraph" data-slate-object="block" data-key="496"> 
<span data-slate-object="text" data-key="497"><span data-slate-leaf="true" data-offset-key="497:0" 
data-first-offset="true"><span data-slate-string="true">数据组织的方式有两种，一种是二叉检索树。一个平衡的二叉检索树使用二分查找的检索效率是 
O(log n)，但如果我们不做额外的平衡控制的话，二叉检索树的检索性能最差会退化到 O(n)，也就和单链表一样了。所以，AVL 树和红黑树这样平衡性更强的二叉检索树，在实际工作中应用更多。</span></span></span> 
</div> <div class="se-e5361bc3 " data-slate-type="paragraph" data-slate-object="block" data-key="498"> 
<span data-slate-object="text" data-key="499"><span data-slate-leaf="true" data-offset-key="499:0" 
data-first-offset="true"><span data-slate-string="true">除了树结构以外，另一种数据组织方式是跳表。跳表也具备二分查找的能力，理想跳表的检索效率是 
O(log n)。为了保证跳表的检索空间平衡，跳表为每个节点随机生成层级，这样的实现方式比 AVL 树和红黑树更简单。</span></span></span> </div> <div 
class="se-e2bf1a6f " data-slate-type="paragraph" data-slate-object="block" data-key="500"> 
<span data-slate-object="text" data-key="501"><span data-slate-leaf="true" data-offset-key="501:0" 
data-first-offset="true"><span data-slate-string="true">无论是二叉检索树还是跳表，它们都是通过将数据进行合理组织，然后尽可能地平衡划分检索空间，使得我们能采用二分查找的思路快速地缩减查找范围，达到 
O(log n) 的检索效率。</span></span></span> </div> <div class="se-204ef563 " data-slate-type="paragraph" 
data-slate-object="block" data-key="502"> <span data-slate-object="text" data-key="503"><span 
data-slate-leaf="true" data-offset-key="503:0" data-first-offset="true"><span data-slate-string="true">除此之外，我们还能发现，当我们从实际问题出发，去思考每个数据结构的特点以及解决方案时，我们就会更好地理解一些高级数据结构和算法的来龙去脉，从而达到更深入地理解和吸收知识的目的。并且，这种思考方式，会在不知不觉中提升你的设计能力以及解决问题的能力。</span></span></span> 
</div> <h2 class="se-44b73035" data-slate-type="heading" data-slate-object="block" data-key="504"><span 
data-slate-object="text" data-key="505"><span data-slate-leaf="true" data-offset-key="505:0" 
data-first-offset="true"><span data-slate-string="true">课堂讨论</span></span></span></h2> <div 
class="se-7c20e01a " data-slate-type="paragraph" data-slate-object="block" data-key="506"> 
<span data-slate-object="text" data-key="507"><span data-slate-leaf="true" data-offset-key="507:0" 
data-first-offset="true"><span data-slate-string="true">今天的内容比较多，你可以结合我留的课堂讨论题，加深理解。</span></span></span> 
</div> <div class="se-8b2204cf " data-slate-type="paragraph" data-slate-object="block" data-key="508"> 
<span data-slate-object="text" data-key="509"><span data-slate-leaf="true" data-offset-key="509:0" 
data-first-offset="true"><span data-slate-string="true">二叉检索树和跳表都能做到 O(log n) 的查询时间代价，还拥有灵活的调整能力，并且调整代价也是 
O(log n)（包括了寻找插入位置的时间代价）。而有序数组的查询时间代价也是 O(log n)，调整代价是 O(n)，那这是不是意味着二叉检索树或者跳表可以用来替代有序数组呢？有序数组自己的优势又是什么呢？</span></span></span> 
</div> <div class="se-45a41fd2 " data-slate-type="paragraph" data-slate-object="block" data-key="510"> 
<span data-slate-object="text" data-key="511"><span data-slate-leaf="true" data-offset-key="511:0" 
data-first-offset="true"><span data-slate-string="true">欢迎在留言区畅所欲言，说出你的思考过程和最终答案。如果有收获，也欢迎把这篇文章分享给你的朋友。</span></span></span> 
</div> </div>', body_summary='', bundle='book', delta=0, body_format='full_html', langcode='zh-hans', 
revision_id=1152 where entity_id=1152 
 {executed in 1 msec}
2020-11-25 10:29:05.657 INFO  jdbc.sqltiming Line:373 - update node_revision__body set body_value='<div data-slate-editor="true" data-key="315" autocorrect="off" 
spellcheck="false" data-gramm="false" style="outline: none; white-space: pre-wrap; overflow-wrap: 
break-word;"> <div class="se-e93540ba " data-slate-type="paragraph" data-slate-object="block" 
data-key="316"> <span data-slate-object="text" data-key="317"><span data-slate-leaf="true" 
data-offset-key="317:0" data-first-offset="true"><span data-slate-string="true">你好，我是陈东。</span></span></span> 
</div> <div class="se-591508b6 " data-slate-type="paragraph" data-slate-object="block" data-key="318"> 
<span data-slate-object="text" data-key="319"><span data-slate-leaf="true" data-offset-key="319:0" 
data-first-offset="true"><span data-slate-string="true">当我们在电脑中查找文件的时候，我们一般习惯先打开相应的磁盘，再打开文件夹以及子文件夹，最后找到我们需要的文件。这其实就是一个检索路径。如果把所有的文件展开，这个查找路径其实是一个树状结构，也就是一个非线性结构，而不是一个所有文件平铺排列的线性结构。</span></span></span> 
</div> <div class="se-1b1c396d" data-slate-type="image" data-slate-object="block" data-key="320"> 
<img class="se-d084d69a" src="https://static001.geekbang.org/resource/image/18/46/1859310bd112d5479eac9c097db8b946.jpeg"> 
</div> <div class="se-6a26dfd7 se-44d1bf6d" data-slate-type="paragraph" data-slate-object="block" 
data-key="321"> <span data-slate-object="text" data-key="322"><span data-slate-leaf="true" 
data-offset-key="322:0" data-first-offset="true"><span class="se-76c2338e" data-slate-type="secondary" 
data-slate-object="mark"><span data-slate-string="true">树状结构：文件组织例子</span></span></span></span> 
</div> <div class="se-8d20b1a3 " data-slate-type="paragraph" data-slate-object="block" data-key="323"> 
<span data-slate-object="text" data-key="324"><span data-slate-leaf="true" data-offset-key="324:0" 
data-first-offset="true"><span data-slate-string="true">我们都知道，有层次的文件组织肯定比散乱平铺的文件更容易找到。这样熟悉的一个场景，是不是会给你一个启发：对于零散的数据，非线性的树状结构是否可以帮我们提高检索效率呢？</span></span></span> 
</div> <div class="se-f89f0233 " data-slate-type="paragraph" data-slate-object="block" data-key="325"> 
<span data-slate-object="text" data-key="326"><span data-slate-leaf="true" data-offset-key="326:0" 
data-first-offset="true"><span data-slate-string="true">另一方面，我们也知道，在数据频繁更新的场景中，连续存储的有序数组并不是最合适的存储方案。因为数组为了保持有序必须不停地重建和排序，系统检索性能就会急剧下降。但是，非连续存储的有序链表倒是具有高效插入新数据的能力。因此，我们能否结合上面的例子，使用非线性的树状结构来改造有序链表，让链表也具有二分查找的能力呢？今天，我们就来讨论一下这个问题。</span></span></span> 
</div> <h2 class="se-b9c9f9f8" data-slate-type="heading" data-slate-object="block" data-key="327"><span 
data-slate-object="text" data-key="328"><span data-slate-leaf="true" data-offset-key="328:0" 
data-first-offset="true"><span data-slate-string="true">树结构是如何进行二分查找的？</span></span></span></h2> 
<div class="se-f817cd14 " data-slate-type="paragraph" data-slate-object="block" data-key="329"> 
<span data-slate-object="text" data-key="330"><span data-slate-leaf="true" data-offset-key="330:0" 
data-first-offset="true"><span data-slate-string="true">上一讲我们讲了，因为链表并不具备“随机访问”的特点，所以二分查找无法生效。当链表想要访问中间的元素时，我们必须从链表头开始，沿着指针一步一步遍历，需要遍历一半的节点才能到达中间节点，时间代价是 
O(n/2)。而有序数组由于可以“随机访问”，因此只需要 O(1) 的时间代价就可以访问到中间节点了。</span></span></span> </div> <div class="se-8214f3a0 
" data-slate-type="paragraph" data-slate-object="block" data-key="331"> <span data-slate-object="text" 
data-key="332"><span data-slate-leaf="true" data-offset-key="332:0" data-first-offset="true"><span 
data-slate-string="true">那如果我们能在链表中以 O(1) 的时间代价快速访问到中间节点，是不是就可以和有序数组一样使用二分查找了？你先想想看该怎么做，然后我们一起来试着改造一下。</span></span></span> 
</div> <div class="se-17f8494e" data-slate-type="image" data-slate-object="block" data-key="333"> 
<img class="se-54b59566" src="https://static001.geekbang.org/resource/image/2c/ca/2c61d26ed919411dd9be1a94cefb30ca.jpg"> 
</div> <div class="se-6fcce1aa se-69e0dbf7" data-slate-type="paragraph" data-slate-object="block" 
data-key="334"> <span data-slate-object="text" data-key="335"><span data-slate-leaf="true" 
data-offset-key="335:0" data-first-offset="true"><span class="se-76c2338e" data-slate-type="secondary" 
data-slate-object="mark"><span data-slate-string="true">直接记录和访问中间节点</span></span></span></span> 
</div> <div class="se-b0b9267e " data-slate-type="paragraph" data-slate-object="block" data-key="336"> 
<span data-slate-object="text" data-key="337"><span data-slate-leaf="true" data-offset-key="337:0" 
data-first-offset="true"><span data-slate-string="true">既然我们希望能以 O(1) 的时间代价访问中间节点，那将这个节点直接记录下来是不是就可以了？因此，如果我们把中间节点 
M 拎出来单独记录，那我们的第一步操作就是直接访问这个中间节点，然后判断这个节点和要查找的元素是否相等。如果相等，则返回查询结果。如果节点元素大于要查找的元素，那我们就到左边的部分继续查找；反之，则在右边部分继续查找。</span></span></span> 
</div> <div class="se-c9adf328 " data-slate-type="paragraph" data-slate-object="block" data-key="338"> 
<span data-slate-object="text" data-key="339"><span data-slate-leaf="true" data-offset-key="339:0" 
data-first-offset="true"><span data-slate-string="true">对于左边或者右边的部分，我们可以将它们视为两个独立的子链表，依然沿用这个逻辑。如果想用 
O(1) 的时间代价就能访问这两个子链表的中间节点，我们就应该把左边的中间节点 L 和右边的中间节点 R，单独拎出来记录。</span></span></span> </div> <div 
class="se-9277a033 " data-slate-type="paragraph" data-slate-object="block" data-key="340"> 
<span data-slate-object="text" data-key="341"><span data-slate-leaf="true" data-offset-key="341:0" 
data-first-offset="true"><span data-slate-string="true">并且，由于我们是在访问完了 M 节点以后，才决定接下来该去访问左边的 
L 还是右边的 R。因此，我们需要将 L 和 M，R 和 M 连接起来。我们可以让 M 带有两个指针，一个左指针指向 L，一个右指针指向 R。这样，在访问 M 以后，一旦发现 M 不是我们要查找的节点，那么，我们接下来就可以通过指针快速访问到 
L 或者 R 了。</span></span></span> </div> <div class="se-dfd9e5cb" data-slate-type="image" data-slate-object="block" 
data-key="342"> <img class="se-28307b27" src="https://static001.geekbang.org/resource/image/d2/f4/d274bfacd98b00d82746cfeb838ec1f4.jpeg"> 
</div> <div class="se-58bc9406 se-23dac7f1" data-slate-type="paragraph" data-slate-object="block" 
data-key="343"> <span data-slate-object="text" data-key="344"><span data-slate-leaf="true" 
data-offset-key="344:0" data-first-offset="true"><span class="se-76c2338e" data-slate-type="secondary" 
data-slate-object="mark"><span data-slate-string="true">将 M 节点改为带两个指针，指向 L 节点和 R 节点</span></span></span></span> 
</div> <div class="se-d284c625 " data-slate-type="paragraph" data-slate-object="block" data-key="345"> 
<span data-slate-object="text" data-key="346"><span data-slate-leaf="true" data-offset-key="346:0" 
data-first-offset="true"><span data-slate-string="true">对于其余的节点，我们也可以进行同样的处理。下面这个结构，你是不是很熟悉？没错，这就是我们常见的二叉树。你可以再观察一下，这个二叉树和普通的二叉树有什么不一样？</span></span></span> 
</div> <div class="se-edfd3989" data-slate-type="image" data-slate-object="block" data-key="347"> 
<img class="se-4874e347" src="https://static001.geekbang.org/resource/image/bf/bb/bf8df69285c21e28b493bd2f7a0c1abb.jpeg"> 
</div> <div class="se-98f50542 se-856e8530" data-slate-type="paragraph" data-slate-object="block" 
data-key="348"> <span data-slate-object="text" data-key="349"><span data-slate-leaf="true" 
data-offset-key="349:0" data-first-offset="true"><span class="se-76c2338e" data-slate-type="secondary" 
data-slate-object="mark"><span data-slate-string="true">二叉检索树结构</span></span></span></span> 
</div> <div class="se-971577e6 " data-slate-type="paragraph" data-slate-object="block" data-key="350"> 
<span data-slate-object="text" data-key="351"><span data-slate-leaf="true" data-offset-key="351:0" 
data-first-offset="true"><span data-slate-string="true">没错，这个二叉树是有序的。它的左子树的所有节点的值都小于根节点，同时右子树所有节点的值都大于等于根节点。这样的有序结构，使得它能使用二分查找算法，快速地过滤掉一半的数据。具备了这样特点的二叉树，就是二叉检索树（Binary 
Search Tree），或者叫二叉排序树（Binary Sorted Tree）。</span></span></span> </div> <div class="se-8caefb77 
" data-slate-type="paragraph" data-slate-object="block" data-key="352"> <span data-slate-object="text" 
data-key="353"><span data-slate-leaf="true" data-offset-key="353:0" data-first-offset="true"><span 
data-slate-string="true">讲到这里，不知道你有没有发现，</span></span></span><span data-slate-object="text" 
data-key="354"><span data-slate-leaf="true" data-offset-key="354:0" data-first-offset="true"><span 
class="se-4ce93d93" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">尽管有序数组和二叉检索树，在数据结构形态上看起来差异很大，但是在提高检索效率上，它们的核心原理都是一致的。</span></span></span></span><span 
data-slate-object="text" data-key="355"><span data-slate-leaf="true" data-offset-key="355:0" 
data-first-offset="true"><span data-slate-string="true">那么，它们是如何提高检索效率的呢？核心原理又一致在哪里呢？接下来，我们就从两个主要方面来看。</span></span></span> 
</div> <div class="se-a0636e20" data-slate-type="list" data-slate-object="block" data-key="356"> 
<div class="se-eefcf1c8 se-a0726065" data-slate-type="list-line" data-slate-object="block" 
data-key="357"> <span data-slate-object="text" data-key="358"><span data-slate-leaf="true" 
data-offset-key="358:0" data-first-offset="true"><span data-slate-string="true">将数据有序化，并且根据数据存储的特点进行不同的组织。对于连续存储空间的数组而言，由于它具有“随机访问”的特性，因此直接存储即可；对于非连续存储空间的有序链表而言，由于它不具备“随机访问”的特性，因此，需要将它改造为可以快速访问到中间节点的树状结构。</span></span></span> 
</div> <div class="se-c7b737f7 se-526d58d7" data-slate-type="list-line" data-slate-object="block" 
data-key="359"> <span data-slate-object="text" data-key="360"><span data-slate-leaf="true" 
data-offset-key="360:0" data-first-offset="true"><span data-slate-string="true">在进行检索的时候，它们都是通过二分查找的思想从中间节点开始查起。如果不命中，会快速缩小一半的查询空间。这样不停迭代的查询方式，让检索的时间代价能达到 
O(log n) 这个级别。</span></span></span> </div> </div> <div class="se-e910ddbb " data-slate-type="paragraph" 
data-slate-object="block" data-key="361"> <span data-slate-object="text" data-key="362"><span 
data-slate-leaf="true" data-offset-key="362:0" data-first-offset="true"><span data-slate-string="true">说到这里，你可能会问，二叉检索树的检索时间代价一定是 
O(log n) 吗？其实不一定。</span></span></span> </div> <h2 class="se-93706f46" data-slate-type="heading" 
data-slate-object="block" data-key="363"><span data-slate-object="text" data-key="364"><span 
data-slate-leaf="true" data-offset-key="364:0" data-first-offset="true"><span data-slate-string="true">二叉检索树的检索空间平衡方案</span></span></span></h2> 
<div class="se-a31f81d1 " data-slate-type="paragraph" data-slate-object="block" data-key="365"> 
<span data-slate-object="text" data-key="366"><span data-slate-leaf="true" data-offset-key="366:0" 
data-first-offset="true"><span data-slate-string="true">我们先来看一个例子。假设，一个二叉树的每一个节点的左指针都是空的，右子树的值都大于根节点。那么它满足二叉检索树的特性，是一颗二叉检索树。但是，如果我们把左边的空指针忽略，你会发现它其实就是一个单链表！单链表的检索效率如何呢？其实是 
O(n)，而不是 O(log n)。</span></span></span> </div> <div class="se-17e81035" data-slate-type="image" 
data-slate-object="block" data-key="367"> <img class="se-e13e8b0d" src="https://static001.geekbang.org/resource/image/a9/eb/a9f61debcc5a5502f810b1c84ca682eb.jpeg"> 
</div> <div class="se-b5e057e7 se-50e1de4c" data-slate-type="paragraph" data-slate-object="block" 
data-key="368"> <span data-slate-object="text" data-key="369"><span data-slate-leaf="true" 
data-offset-key="369:0" data-first-offset="true"><span class="se-76c2338e" data-slate-type="secondary" 
data-slate-object="mark"><span data-slate-string="true">退化成链表的二叉检索树</span></span></span></span> 
</div> <div class="se-472f2c89 " data-slate-type="paragraph" data-slate-object="block" data-key="370"> 
<span data-slate-object="text" data-key="371"><span data-slate-leaf="true" data-offset-key="371:0" 
data-first-offset="true"><span data-slate-string="true">为什么会出现这样的情况呢？</span></span></span> 
</div> <div class="se-5a204baf " data-slate-type="paragraph" data-slate-object="block" data-key="372"> 
<span data-slate-object="text" data-key="373"><span data-slate-leaf="true" data-offset-key="373:0" 
data-first-offset="true"><span class="se-69789ed4" data-slate-type="bold" data-slate-object="mark"><span 
data-slate-string="true">最根本的原因是，这样的结构造成了检索空间不平衡。在当前节点不满足查询条件的时候，它无法把“一半的数据”过滤掉，而是只能过滤掉当前检索的这个节点。因此无法达到“快速减小查询范围”的目的。</span></span></span></span> 
</div> <div class="se-4f574001 " data-slate-type="paragraph" data-slate-object="block" data-key="374"> 
<span data-slate-object="text" data-key="375"><span data-slate-leaf="true" data-offset-key="375:0" 
data-first-offset="true"><span data-slate-string="true">因此，为了提升检索效率，我们应该尽可能地保证二叉检索树的平衡性，让左右子树尽可能差距不要太大。这样无论我们是继续往左边还是右边检索，都可以过滤掉一半左右的数据。</span></span></span> 
</div> <div class="se-8f423353 " data-slate-type="paragraph" data-slate-object="block" data-key="376"> 
<span data-slate-object="text" data-key="377"><span data-slate-leaf="true" data-offset-key="377:0" 
data-first-offset="true"><span data-slate-string="true">也正是为了解决这个问题，有更多的数据结构被发明了出来。比如：AVL 树（平衡二叉树）和红黑树，其实它们本质上都是二叉检索树，但它们都在保证左右子树差距不要太大上做了特殊的处理，保证了检索效率，让二叉检索树可以被广泛地使用。比如，我们常见的 
C++ 中的 Set 和 Map 等数据结构，底层就是用红黑树实现的。</span></span></span> </div> <div class="se-6a232cfe " data-slate-type="paragraph" 
data-slate-object="block" data-key="378"> <span data-slate-object="text" data-key="379"><span 
data-slate-leaf="true" data-offset-key="379:0" data-first-offset="true"><span data-slate-string="true">这里，我就不再详细介绍 
AVL 树和红黑树的具体实现了。为了保证检索效率，我们其实只需要在数据的组织上考虑检索空间的平衡划分就好了，这一点都是一样的。</span></span></span> </div> 
<h2 class="se-2285f453" data-slate-type="heading" data-slate-object="block" data-key="380"><span 
data-slate-object="text" data-key="381"><span data-slate-leaf="true" data-offset-key="381:0" 
data-first-offset="true"><span data-slate-string="true">跳表是如何进行二分查找的？</span></span></span></h2> 
<div class="se-d082b04d " data-slate-type="paragraph" data-slate-object="block" data-key="382"> 
<span data-slate-object="text" data-key="383"><span data-slate-leaf="true" data-offset-key="383:0" 
data-first-offset="true"><span data-slate-string="true">除了二叉检索树，有序链表还有其他快速访问中间节点的改造方案吗？我们知道，链表之所以访问中间节点的效率低，就是因为每个节点只存储了下一个节点的指针，要沿着这个指针遍历每个后续节点才能到达中间节点。那如果我们在节点上增加一个指针，指向更远的节点，比如说跳过后一个节点，直接指向后面第二个节点，那么沿着这个指针遍历，是不是遍历速度就翻倍了呢？</span></span></span> 
</div> <div class="se-928b2e4f " data-slate-type="paragraph" data-slate-object="block" data-key="384"> 
<span data-slate-object="text" data-key="385"><span data-slate-leaf="true" data-offset-key="385:0" 
data-first-offset="true"><span data-slate-string="true">同理，如果我们能增加更多的指针，提供不同步长的遍历能力，比如一次跳过 
4 个节点，甚至一半的节点，那我们是不是就可以更快速地访问到中间节点了呢？</span></span></span> </div> <div class="se-67567530 " 
data-slate-type="paragraph" data-slate-object="block" data-key="386"> <span data-slate-object="text" 
data-key="387"><span data-slate-leaf="true" data-offset-key="387:0" data-first-offset="true"><span 
data-slate-string="true">这当然是可以实现的。我们可以为链表的某些节点增加更多的指针。这些指针都指向不同距离的后续节点。这样一来，链表就具备了更高效的检索能力。这样的数据结构就是</span></span></span><span 
data-slate-object="text" data-key="388"><span data-slate-leaf="true" data-offset-key="388:0" 
data-first-offset="true"><span class="se-a0b405bc" data-slate-type="bold" data-slate-object="mark"><span 
data-slate-string="true">跳表</span></span></span></span><span data-slate-object="text" data-key="389"><span 
data-slate-leaf="true" data-offset-key="389:0" data-first-offset="true"><span data-slate-string="true">（Skip 
List）。</span></span></span> </div> <div class="se-4553fc1a " data-slate-type="paragraph" data-slate-object="block" 
data-key="390"> <span data-slate-object="text" data-key="391"><span data-slate-leaf="true" 
data-offset-key="391:0" data-first-offset="true"><span data-slate-string="true">一个理想的跳表，就是从链表头开始，用多个不同的步长，每隔 
2^n 个节点做一次直接链接（n 取值为 0，1，2……）。跳表中的每个节点都拥有多个不同步长的指针，我们可以在每个节点里，用一个数组 next 来记录这些指针。next 数组的大小就是这个节点的层数，next[0]就是第 
0 层的步长为 1 的指针，next[1]就是第 1 层的步长为 2 的指针，next[2]就是第 2 层的步长为 4 的指针，依此类推。你会发现，不同步长的指针，在链表中的分布是非常均匀的，这使得整个链表具有非常平衡的检索结构。</span></span></span> 
</div> <div class="se-e65cd2e1" data-slate-type="image" data-slate-object="block" data-key="392"> 
<img class="se-0a8502a5" src="https://static001.geekbang.org/resource/image/bb/77/bbae24216d975a014b6112dbce45ae77.jpg"> 
</div> <div class="se-c2c1a9ee se-bee9aec7" data-slate-type="paragraph" data-slate-object="block" 
data-key="393"> <span data-slate-object="text" data-key="394"><span data-slate-leaf="true" 
data-offset-key="394:0" data-first-offset="true"><span class="se-76c2338e" data-slate-type="secondary" 
data-slate-object="mark"><span data-slate-string="true">理想的跳表</span></span></span></span> </div> 
<div class="se-cfc3a07e " data-slate-type="paragraph" data-slate-object="block" data-key="395"> 
<span data-slate-object="text" data-key="396"><span data-slate-leaf="true" data-offset-key="396:0" 
data-first-offset="true"><span data-slate-string="true">举个例子，当我们要检索 k=a</span></span></span><span 
data-slate-type="sub" data-slate-object="inline" data-key="397" class="se-fb22f369"><span data-slate-object="text" 
data-key="398"><span data-slate-leaf="true" data-offset-key="398:0" data-first-offset="true"><span 
data-slate-string="true">6</span></span></span></span><span data-slate-object="text" data-key="399"><span 
data-slate-leaf="true" data-offset-key="399:0" data-first-offset="true"><span data-slate-string="true">时，从第一个节点 
a</span></span></span><span data-slate-type="sub" data-slate-object="inline" data-key="400" 
class="se-fb22f369"><span data-slate-object="text" data-key="401"><span data-slate-leaf="true" 
data-offset-key="401:0" data-first-offset="true"><span data-slate-string="true">1</span></span></span></span><span 
data-slate-object="text" data-key="402"><span data-slate-leaf="true" data-offset-key="402:0" 
data-first-offset="true"><span data-slate-string="true">开始，用最大步长的指针开始遍历，直接就可以访问到中间节点 a</span></span></span><span 
data-slate-type="sub" data-slate-object="inline" data-key="403" class="se-fb22f369"><span data-slate-object="text" 
data-key="404"><span data-slate-leaf="true" data-offset-key="404:0" data-first-offset="true"><span 
data-slate-string="true">5</span></span></span></span><span data-slate-object="text" data-key="405"><span 
data-slate-leaf="true" data-offset-key="405:0" data-first-offset="true"><span data-slate-string="true">。但是，如果沿着这个最大步长指针继续访问下去，下一个节点是大于 
k 的 a</span></span></span><span data-slate-type="sub" data-slate-object="inline" data-key="406" 
class="se-fb22f369"><span data-slate-object="text" data-key="407"><span data-slate-leaf="true" 
data-offset-key="407:0" data-first-offset="true"><span data-slate-string="true">9</span></span></span></span><span 
data-slate-object="text" data-key="408"><span data-slate-leaf="true" data-offset-key="408:0" 
data-first-offset="true"><span data-slate-string="true">，这说明 k 在 a</span></span></span><span 
data-slate-type="sub" data-slate-object="inline" data-key="409" class="se-fb22f369"><span data-slate-object="text" 
data-key="410"><span data-slate-leaf="true" data-offset-key="410:0" data-first-offset="true"><span 
data-slate-string="true">5</span></span></span></span><span data-slate-object="text" data-key="411"><span 
data-slate-leaf="true" data-offset-key="411:0" data-first-offset="true"><span data-slate-string="true">和 
a</span></span></span><span data-slate-type="sub" data-slate-object="inline" data-key="412" 
class="se-fb22f369"><span data-slate-object="text" data-key="413"><span data-slate-leaf="true" 
data-offset-key="413:0" data-first-offset="true"><span data-slate-string="true">9</span></span></span></span><span 
data-slate-object="text" data-key="414"><span data-slate-leaf="true" data-offset-key="414:0" 
data-first-offset="true"><span data-slate-string="true">之间。那么，我们就在 a</span></span></span><span 
data-slate-type="sub" data-slate-object="inline" data-key="415" class="se-fb22f369"><span data-slate-object="text" 
data-key="416"><span data-slate-leaf="true" data-offset-key="416:0" data-first-offset="true"><span 
data-slate-string="true">5</span></span></span></span><span data-slate-object="text" data-key="417"><span 
data-slate-leaf="true" data-offset-key="417:0" data-first-offset="true"><span data-slate-string="true">和 
a</span></span></span><span data-slate-type="sub" data-slate-object="inline" data-key="418" 
class="se-fb22f369"><span data-slate-object="text" data-key="419"><span data-slate-leaf="true" 
data-offset-key="419:0" data-first-offset="true"><span data-slate-string="true">9</span></span></span></span><span 
data-slate-object="text" data-key="420"><span data-slate-leaf="true" data-offset-key="420:0" 
data-first-offset="true"><span data-slate-string="true">之间，用小一个级别的步长继续查询。这时候，a</span></span></span><span 
data-slate-type="sub" data-slate-object="inline" data-key="421" class="se-fb22f369"><span data-slate-object="text" 
data-key="422"><span data-slate-leaf="true" data-offset-key="422:0" data-first-offset="true"><span 
data-slate-string="true">5</span></span></span></span><span data-slate-object="text" data-key="423"><span 
data-slate-leaf="true" data-offset-key="423:0" data-first-offset="true"><span data-slate-string="true">的下一个元素是 
a</span></span></span><span data-slate-type="sub" data-slate-object="inline" data-key="424" 
class="se-fb22f369"><span data-slate-object="text" data-key="425"><span data-slate-leaf="true" 
data-offset-key="425:0" data-first-offset="true"><span data-slate-string="true">7</span></span></span></span><span 
data-slate-object="text" data-key="426"><span data-slate-leaf="true" data-offset-key="426:0" 
data-first-offset="true"><span data-slate-string="true">，a</span></span></span><span data-slate-type="sub" 
data-slate-object="inline" data-key="427" class="se-fb22f369"><span data-slate-object="text" 
data-key="428"><span data-slate-leaf="true" data-offset-key="428:0" data-first-offset="true"><span 
data-slate-string="true">7</span></span></span></span><span data-slate-object="text" data-key="429"><span 
data-slate-leaf="true" data-offset-key="429:0" data-first-offset="true"><span data-slate-string="true">依然大于 
k 的值，因此，我们会继续在 a</span></span></span><span data-slate-type="sub" data-slate-object="inline" 
data-key="430" class="se-fb22f369"><span data-slate-object="text" data-key="431"><span data-slate-leaf="true" 
data-offset-key="431:0" data-first-offset="true"><span data-slate-string="true">5</span></span></span></span><span 
data-slate-object="text" data-key="432"><span data-slate-leaf="true" data-offset-key="432:0" 
data-first-offset="true"><span data-slate-string="true">和 a</span></span></span><span data-slate-type="sub" 
data-slate-object="inline" data-key="433" class="se-fb22f369"><span data-slate-object="text" 
data-key="434"><span data-slate-leaf="true" data-offset-key="434:0" data-first-offset="true"><span 
data-slate-string="true">7</span></span></span></span><span data-slate-object="text" data-key="435"><span 
data-slate-leaf="true" data-offset-key="435:0" data-first-offset="true"><span data-slate-string="true">之间，用再小一个级别的步长查找，这样就找到 
a</span></span></span><span data-slate-type="sub" data-slate-object="inline" data-key="436" 
class="se-fb22f369"><span data-slate-object="text" data-key="437"><span data-slate-leaf="true" 
data-offset-key="437:0" data-first-offset="true"><span data-slate-string="true">6</span></span></span></span><span 
data-slate-object="text" data-key="438"><span data-slate-leaf="true" data-offset-key="438:0" 
data-first-offset="true"><span data-slate-string="true">了。这个过程其实就是二分查找。时间代价是 O(log n)。</span></span></span> 
</div> <h2 class="se-d9d1298f" data-slate-type="heading" data-slate-object="block" data-key="439"><span 
data-slate-object="text" data-key="440"><span data-slate-leaf="true" data-offset-key="440:0" 
data-first-offset="true"><span data-slate-string="true">跳表的检索空间平衡方案</span></span></span></h2> 
<div class="se-6b90cfba " data-slate-type="paragraph" data-slate-object="block" data-key="441"> 
<span data-slate-object="text" data-key="442"><span data-slate-leaf="true" data-offset-key="442:0" 
data-first-offset="true"><span data-slate-string="true">不知道你有没有注意到，我在前面强调了一个词，那就是“理想的跳表”。为什么要叫它“理想”的跳表呢？难道在实际情况下，跳表不是这样实现的吗？的确不是。当我们要在跳表中插入元素时，节点之间的间隔距离就被改变了。如果要保证理想链表的每隔 
2^n 个节点做一次链接的特性，我们就需要重新修改许多节点的后续指针，这会带来很大的开销。</span></span></span> </div> <div class="se-af5ba176 
" data-slate-type="paragraph" data-slate-object="block" data-key="443"> <span data-slate-object="text" 
data-key="444"><span data-slate-leaf="true" data-offset-key="444:0" data-first-offset="true"><span 
data-slate-string="true">所以，在实际情况下，我们会在检索性能和修改指针代价之间做一个权衡。为了保证检索性能，我们不需要保证跳表是一个“理想”的平衡状态，只需要保证它在大概率上是平衡的就可以了。因此，当新节点插入时，我们不去修改已有的全部指针，而是仅针对新加入的节点为它建立相应的各级别的跳表指针。具体的操作过程，我们一起来看看。</span></span></span> 
</div> <div class="se-23033e0c " data-slate-type="paragraph" data-slate-object="block" data-key="445"> 
<span data-slate-object="text" data-key="446"><span data-slate-leaf="true" data-offset-key="446:0" 
data-first-offset="true"><span data-slate-string="true">首先，我们需要确认新加入的节点需要具有几层的指针。我们通过随机函数来生成层数，比如说，我们可以写一个函数 
RandomLevel()，以 (1/2)^n 的概率决定是否生成第 n 层。这样，通过简单的随机生成指针层数的方式，我们就可以保证指针的分布，在大概率上是平衡的。</span></span></span> 
</div> <div class="se-2b6d3fbb " data-slate-type="paragraph" data-slate-object="block" data-key="447"> 
<span data-slate-object="text" data-key="448"><span data-slate-leaf="true" data-offset-key="448:0" 
data-first-offset="true"><span data-slate-string="true">在确认了新节点的层数 n 以后，接下来，我们需要将新节点和前后的节点连接起来，也就是为每一层的指针建立前后连接关系。其实每一层的指针链接，你都可以看作是一个独立的单链表的修改，因此我们只需要用单链表插入节点的方式完成指针连接即可。</span></span></span> 
</div> <div class="se-5c858c1a " data-slate-type="paragraph" data-slate-object="block" data-key="449"> 
<span data-slate-object="text" data-key="450"><span data-slate-leaf="true" data-offset-key="450:0" 
data-first-offset="true"><span data-slate-string="true">这么说，可能你理解起来不是很直观，接下来，我通过一个具体的例子进一步给你解释一下。</span></span></span> 
</div> <div class="se-be4bc439 " data-slate-type="paragraph" data-slate-object="block" data-key="451"> 
<span data-slate-object="text" data-key="452"><span data-slate-leaf="true" data-offset-key="452:0" 
data-first-offset="true"><span data-slate-string="true">我们要在一个最高有 3 层指针的跳表中插入一个新元素 k，这个跳表的结构如下图所示。</span></span></span> 
</div> <div class="se-68c4ec26" data-slate-type="image" data-slate-object="block" data-key="453"> 
<img class="se-84d3261b" src="https://static001.geekbang.org/resource/image/dd/42/dd4a8d2cfc40d4825dc5951ddcce2442.jpg"> 
</div> <div class="se-d2dc68e3 " data-slate-type="paragraph" data-slate-object="block" data-key="454"> 
<span data-slate-object="text" data-key="455"><span data-slate-leaf="true" data-offset-key="455:0" 
data-first-offset="true"><span data-slate-string="true">假设我们通过跳表的检索已经确认了，k 应该插入到 a</span></span></span><span 
data-slate-type="sub" data-slate-object="inline" data-key="456" class="se-fb22f369"><span data-slate-object="text" 
data-key="457"><span data-slate-leaf="true" data-offset-key="457:0" data-first-offset="true"><span 
data-slate-string="true">6</span></span></span></span><span data-slate-object="text" data-key="458"><span 
data-slate-leaf="true" data-offset-key="458:0" data-first-offset="true"><span data-slate-string="true">和 
a</span></span></span><span data-slate-type="sub" data-slate-object="inline" data-key="459" 
class="se-fb22f369"><span data-slate-object="text" data-key="460"><span data-slate-leaf="true" 
data-offset-key="460:0" data-first-offset="true"><span data-slate-string="true">7</span></span></span></span><span 
data-slate-object="text" data-key="461"><span data-slate-leaf="true" data-offset-key="461:0" 
data-first-offset="true"><span data-slate-string="true">两个节点之间。那接下来，我们要先为新节点随机生成一个层数。假设生成的层数为 
2，那我们就要修改第 0 层和第 1 层的指针关系。对于第 0 层的链表，k 需要插入到 a</span></span></span><span data-slate-type="sub" 
data-slate-object="inline" data-key="462" class="se-fb22f369"><span data-slate-object="text" 
data-key="463"><span data-slate-leaf="true" data-offset-key="463:0" data-first-offset="true"><span 
data-slate-string="true">6</span></span></span></span><span data-slate-object="text" data-key="464"><span 
data-slate-leaf="true" data-offset-key="464:0" data-first-offset="true"><span data-slate-string="true">和 
a</span></span></span><span data-slate-type="sub" data-slate-object="inline" data-key="465" 
class="se-fb22f369"><span data-slate-object="text" data-key="466"><span data-slate-leaf="true" 
data-offset-key="466:0" data-first-offset="true"><span data-slate-string="true">7</span></span></span></span><span 
data-slate-object="text" data-key="467"><span data-slate-leaf="true" data-offset-key="467:0" 
data-first-offset="true"><span data-slate-string="true">之间，我们只需要修改 a</span></span></span><span 
data-slate-type="sub" data-slate-object="inline" data-key="468" class="se-fb22f369"><span data-slate-object="text" 
data-key="469"><span data-slate-leaf="true" data-offset-key="469:0" data-first-offset="true"><span 
data-slate-string="true">6</span></span></span></span><span data-slate-object="text" data-key="470"><span 
data-slate-leaf="true" data-offset-key="470:0" data-first-offset="true"><span data-slate-string="true">和 
a</span></span></span><span data-slate-type="sub" data-slate-object="inline" data-key="471" 
class="se-fb22f369"><span data-slate-object="text" data-key="472"><span data-slate-leaf="true" 
data-offset-key="472:0" data-first-offset="true"><span data-slate-string="true">7</span></span></span></span><span 
data-slate-object="text" data-key="473"><span data-slate-leaf="true" data-offset-key="473:0" 
data-first-offset="true"><span data-slate-string="true">的第 0 层指针；对于第 1 层的链表，k 需要插入到 a</span></span></span><span 
data-slate-type="sub" data-slate-object="inline" data-key="474" class="se-fb22f369"><span data-slate-object="text" 
data-key="475"><span data-slate-leaf="true" data-offset-key="475:0" data-first-offset="true"><span 
data-slate-string="true">5</span></span></span></span><span data-slate-object="text" data-key="476"><span 
data-slate-leaf="true" data-offset-key="476:0" data-first-offset="true"><span data-slate-string="true">和 
a</span></span></span><span data-slate-type="sub" data-slate-object="inline" data-key="477" 
class="se-fb22f369"><span data-slate-object="text" data-key="478"><span data-slate-leaf="true" 
data-offset-key="478:0" data-first-offset="true"><span data-slate-string="true">7</span></span></span></span><span 
data-slate-object="text" data-key="479"><span data-slate-leaf="true" data-offset-key="479:0" 
data-first-offset="true"><span data-slate-string="true">之间，我们只需要修改 a</span></span></span><span 
data-slate-type="sub" data-slate-object="inline" data-key="480" class="se-fb22f369"><span data-slate-object="text" 
data-key="481"><span data-slate-leaf="true" data-offset-key="481:0" data-first-offset="true"><span 
data-slate-string="true">5</span></span></span></span><span data-slate-object="text" data-key="482"><span 
data-slate-leaf="true" data-offset-key="482:0" data-first-offset="true"><span data-slate-string="true">和 
a</span></span></span><span data-slate-type="sub" data-slate-object="inline" data-key="483" 
class="se-fb22f369"><span data-slate-object="text" data-key="484"><span data-slate-leaf="true" 
data-offset-key="484:0" data-first-offset="true"><span data-slate-string="true">7</span></span></span></span><span 
data-slate-object="text" data-key="485"><span data-slate-leaf="true" data-offset-key="485:0" 
data-first-offset="true"><span data-slate-string="true">的第 1 层指针。这样，我们就完成了将 k 插入到跳表中的动作。</span></span></span> 
</div> <div class="se-36cbc7bb " data-slate-type="paragraph" data-slate-object="block" data-key="486"> 
<span data-slate-object="text" data-key="487"><span data-slate-leaf="true" data-offset-key="487:0" 
data-first-offset="true"><span data-slate-string="true">通过这样一种方式，我们可以大大减少修改指针的代价。当然，由于新加入节点的层数是随机生成的，因此在节点数目较少的情况下，如果指针分布的不合理，检索性能依然可能不高。但是当节点数较多的时候，指针会趋向均匀分布，查找空间会比较平衡，检索性能会趋向于理想跳表的检索效率，接近 
O(log n)。</span></span></span> </div> <div class="se-81e53879 " data-slate-type="paragraph" 
data-slate-object="block" data-key="488"> <span data-slate-object="text" data-key="489"><span 
data-slate-leaf="true" data-offset-key="489:0" data-first-offset="true"><span data-slate-string="true">因此，相比于复杂的平衡二叉检索树，如红黑树，跳表用一种更简单的方式实现了检索空间的平衡。并且，由于跳表保持了链表顺序遍历的能力，在需要遍历功能的场景中，跳表会比红黑树用起来更方便。这也就是为什么，在 
Redis 这样的系统中，我们经常会利用跳表来代替红黑树作为底层的数据结构。</span></span></span> </div> <h2 class="se-c0f8b013" 
data-slate-type="heading" data-slate-object="block" data-key="490"><span data-slate-object="text" 
data-key="491"><span data-slate-leaf="true" data-offset-key="491:0" data-first-offset="true"><span 
data-slate-string="true">重点回顾</span></span></span></h2> <div class="se-8b380896 " data-slate-type="paragraph" 
data-slate-object="block" data-key="492"> <span data-slate-object="text" data-key="493"><span 
data-slate-leaf="true" data-offset-key="493:0" data-first-offset="true"><span data-slate-string="true">好了，关于非线性结构的检索技术，我们就先讲到这里。我们一起回顾一下今天的重点内容。</span></span></span> 
</div> <div class="se-4c2a3a91 " data-slate-type="paragraph" data-slate-object="block" data-key="494"> 
<span data-slate-object="text" data-key="495"><span data-slate-leaf="true" data-offset-key="495:0" 
data-first-offset="true"><span data-slate-string="true">首先，对于数据频繁变化的应用场景，有序数组并不是最适合的解决方案。我们一般要考虑采用非连续存储的数据结构来灵活调整。同时，为了提高检索效率，我们还要采取合理的组织方式，让这些非连续存储的数据结构能够使用二分查找算法。</span></span></span> 
</div> <div class="se-8d0001b8 " data-slate-type="paragraph" data-slate-object="block" data-key="496"> 
<span data-slate-object="text" data-key="497"><span data-slate-leaf="true" data-offset-key="497:0" 
data-first-offset="true"><span data-slate-string="true">数据组织的方式有两种，一种是二叉检索树。一个平衡的二叉检索树使用二分查找的检索效率是 
O(log n)，但如果我们不做额外的平衡控制的话，二叉检索树的检索性能最差会退化到 O(n)，也就和单链表一样了。所以，AVL 树和红黑树这样平衡性更强的二叉检索树，在实际工作中应用更多。</span></span></span> 
</div> <div class="se-e5361bc3 " data-slate-type="paragraph" data-slate-object="block" data-key="498"> 
<span data-slate-object="text" data-key="499"><span data-slate-leaf="true" data-offset-key="499:0" 
data-first-offset="true"><span data-slate-string="true">除了树结构以外，另一种数据组织方式是跳表。跳表也具备二分查找的能力，理想跳表的检索效率是 
O(log n)。为了保证跳表的检索空间平衡，跳表为每个节点随机生成层级，这样的实现方式比 AVL 树和红黑树更简单。</span></span></span> </div> <div 
class="se-e2bf1a6f " data-slate-type="paragraph" data-slate-object="block" data-key="500"> 
<span data-slate-object="text" data-key="501"><span data-slate-leaf="true" data-offset-key="501:0" 
data-first-offset="true"><span data-slate-string="true">无论是二叉检索树还是跳表，它们都是通过将数据进行合理组织，然后尽可能地平衡划分检索空间，使得我们能采用二分查找的思路快速地缩减查找范围，达到 
O(log n) 的检索效率。</span></span></span> </div> <div class="se-204ef563 " data-slate-type="paragraph" 
data-slate-object="block" data-key="502"> <span data-slate-object="text" data-key="503"><span 
data-slate-leaf="true" data-offset-key="503:0" data-first-offset="true"><span data-slate-string="true">除此之外，我们还能发现，当我们从实际问题出发，去思考每个数据结构的特点以及解决方案时，我们就会更好地理解一些高级数据结构和算法的来龙去脉，从而达到更深入地理解和吸收知识的目的。并且，这种思考方式，会在不知不觉中提升你的设计能力以及解决问题的能力。</span></span></span> 
</div> <h2 class="se-44b73035" data-slate-type="heading" data-slate-object="block" data-key="504"><span 
data-slate-object="text" data-key="505"><span data-slate-leaf="true" data-offset-key="505:0" 
data-first-offset="true"><span data-slate-string="true">课堂讨论</span></span></span></h2> <div 
class="se-7c20e01a " data-slate-type="paragraph" data-slate-object="block" data-key="506"> 
<span data-slate-object="text" data-key="507"><span data-slate-leaf="true" data-offset-key="507:0" 
data-first-offset="true"><span data-slate-string="true">今天的内容比较多，你可以结合我留的课堂讨论题，加深理解。</span></span></span> 
</div> <div class="se-8b2204cf " data-slate-type="paragraph" data-slate-object="block" data-key="508"> 
<span data-slate-object="text" data-key="509"><span data-slate-leaf="true" data-offset-key="509:0" 
data-first-offset="true"><span data-slate-string="true">二叉检索树和跳表都能做到 O(log n) 的查询时间代价，还拥有灵活的调整能力，并且调整代价也是 
O(log n)（包括了寻找插入位置的时间代价）。而有序数组的查询时间代价也是 O(log n)，调整代价是 O(n)，那这是不是意味着二叉检索树或者跳表可以用来替代有序数组呢？有序数组自己的优势又是什么呢？</span></span></span> 
</div> <div class="se-45a41fd2 " data-slate-type="paragraph" data-slate-object="block" data-key="510"> 
<span data-slate-object="text" data-key="511"><span data-slate-leaf="true" data-offset-key="511:0" 
data-first-offset="true"><span data-slate-string="true">欢迎在留言区畅所欲言，说出你的思考过程和最终答案。如果有收获，也欢迎把这篇文章分享给你的朋友。</span></span></span> 
</div> </div>', body_summary='', bundle='book', delta=0, body_format='full_html', langcode='zh-hans', 
revision_id=1152 where entity_id=1152 
 {executed in 1 msec}
2020-11-25 10:29:05.664 INFO  jdbc.sqltiming Line:373 - select nodefiledd0_.nid as nid1_10_, nodefiledd0_.changed as changed2_10_, nodefiledd0_.created 
as created3_10_, nodefiledd0_.default_langcode as default_4_10_, nodefiledd0_.langcode as langcode5_10_, 
nodefiledd0_.promote as promote6_10_, nodefiledd0_.revision_translation_affected as revision7_10_, 
nodefiledd0_.status as status8_10_, nodefiledd0_.sticky as sticky9_10_, nodefiledd0_.title 
as title10_10_, nodefiledd0_.type as type11_10_, nodefiledd0_.uid as uid12_10_, nodefiledd0_.vid 
as vid13_10_ from node_field_data nodefiledd0_ where nodefiledd0_.nid=1152 
 {executed in 1 msec}
2020-11-25 10:29:05.664 INFO  jdbc.resultsettable Line:610 - 
|-----|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|------------------------------|-----|----|-----|
|nid  |changed    |created    |default_langcode |langcode |promote |revision_translation_affected |status |sticky |title                         |type |uid |vid  |
|-----|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|------------------------------|-----|----|-----|
|1152 |1606115342 |1606115342 |1                |zh-hans  |0       |1                             |1      |0      |02丨非线性结构检索：数据频繁变化的情况下，如何高效检索？ |book |1   |1152 |
|-----|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|------------------------------|-----|----|-----|

2020-11-25 10:29:05.665 INFO  jdbc.sqltiming Line:373 - select nodefieldr0_.nid as nid1_11_0_, nodefieldr0_.changed as changed2_11_0_, nodefieldr0_.created 
as created3_11_0_, nodefieldr0_.default_langcode as default_4_11_0_, nodefieldr0_.langcode 
as langcode5_11_0_, nodefieldr0_.promote as promote6_11_0_, nodefieldr0_.revision_translation_affected 
as revision7_11_0_, nodefieldr0_.status as status8_11_0_, nodefieldr0_.sticky as sticky9_11_0_, 
nodefieldr0_.title as title10_11_0_, nodefieldr0_.uid as uid11_11_0_, nodefieldr0_.vid as vid12_11_0_ 
from node_field_revision nodefieldr0_ where nodefieldr0_.nid=1152 
 {executed in 0 msec}
2020-11-25 10:29:05.665 INFO  jdbc.resultsettable Line:610 - 
|---------|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|------------------------------|----|-----|
|nid      |changed    |created    |default_langcode |langcode |promote |revision_translation_affected |status |sticky |title                         |uid |vid  |
|---------|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|------------------------------|----|-----|
|[unread] |1606115342 |1606115342 |1                |zh-hans  |0       |1                             |1      |0      |02丨非线性结构检索：数据频繁变化的情况下，如何高效检索？ |1   |1152 |
|---------|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|------------------------------|----|-----|

2020-11-25 10:29:05.667 INFO  jdbc.sqltiming Line:373 - update node_field_data set changed=1606271345, created=1606271345, default_langcode=1, langcode='zh-hans', 
promote=0, revision_translation_affected=1, status=1, sticky=0, title='02丨非线性结构检索：数据频繁变化的情况下，如何高效检索？', 
type='book', uid=1, vid=1152 where nid=1152 
 {executed in 0 msec}
2020-11-25 10:29:05.667 INFO  jdbc.sqltiming Line:373 - update node_field_revision set changed=1606271345, created=1606271345, default_langcode=1, 
langcode='zh-hans', promote=0, revision_translation_affected=1, status=1, sticky=0, title='02丨非线性结构检索：数据频繁变化的情况下，如何高效检索？', 
uid=1, vid=1152 where nid=1152 
 {executed in 0 msec}
2020-11-25 10:29:05.672 INFO  jdbc.sqltiming Line:373 - select bookfieldm0_.entity_id as entity_i1_8_, bookfieldm0_.bundle as bundle2_8_, bookfieldm0_.delta 
as delta3_8_, bookfieldm0_.langcode as langcode4_8_, bookfieldm0_.field_media_value as field_me5_8_, 
bookfieldm0_.revision_id as revision6_8_ from node__field_media bookfieldm0_ where bookfieldm0_.entity_id=1152 
 {executed in 0 msec}
2020-11-25 10:29:05.672 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------------|------------|
|entity_id |bundle |delta |langcode |field_media_value |revision_id |
|----------|-------|------|---------|------------------|------------|
|1152      |book   |0     |zh-hans  |                  |1152        |
|----------|-------|------|---------|------------------|------------|

2020-11-25 10:29:05.674 INFO  jdbc.sqltiming Line:373 - select nodefieldm0_.entity_id as entity_i1_17_0_, nodefieldm0_.bundle as bundle2_17_0_, nodefieldm0_.delta 
as delta3_17_0_, nodefieldm0_.langcode as langcode4_17_0_, nodefieldm0_.field_media_value as 
field_me5_17_0_, nodefieldm0_.revision_id as revision6_17_0_ from node_revision__field_media 
nodefieldm0_ where nodefieldm0_.entity_id=1152 
 {executed in 0 msec}
2020-11-25 10:29:05.675 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------------|------------|
|entity_id |bundle |delta |langcode |field_media_value |revision_id |
|----------|-------|------|---------|------------------|------------|
|[unread]  |book   |0     |zh-hans  |                  |1152        |
|----------|-------|------|---------|------------------|------------|

2020-11-25 10:29:05.677 INFO  jdbc.sqltiming Line:373 - select bookfieldc0_.entity_id as entity_i1_5_, bookfieldc0_.bundle as bundle2_5_, bookfieldc0_.field_comment_value 
as field_co3_5_, bookfieldc0_.delta as delta4_5_, bookfieldc0_.field_comment_format as field_co5_5_, 
bookfieldc0_.langcode as langcode6_5_, bookfieldc0_.revision_id as revision7_5_ from node__field_comment 
bookfieldc0_ where bookfieldc0_.entity_id=1152 
 {executed in 1 msec}
2020-11-25 10:29:05.677 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|--------------------|------|---------------------|---------|------------|
|entity_id |bundle |field_comment_value |delta |field_comment_format |langcode |revision_id |
|----------|-------|--------------------|------|---------------------|---------|------------|
|1152      |book   |                    |0     |full_html            |zh-hans  |1152        |
|----------|-------|--------------------|------|---------------------|---------|------------|

2020-11-25 10:29:05.680 INFO  jdbc.sqltiming Line:373 - update node__field_comment set bundle='book', field_comment_value='<li class="reJj6Thl_0"><img 
src="https://static001.geekbang.org/account/avatar/00/10/1d/13/31ea1b0b.jpg" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <a>峰</a> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-25 </div> </div> <!----> </div> <div> <div 
class="_3M6kV3zb_0"> 1，虽然时间复杂度一致，但并不代表真实的时间一致，时间复杂度只是量级，所以数据量小的情况下，数组能甩其他结构几条街。2，就是存储空间的节省。 
<br> <br>这篇文章让我有很多延伸想法，1，检索操作映射到底层核心就是cpu对存储的寻址方式，而这上层的抽象就是指针和数组，老师向我们展示了添加指针构建二叉树的过程，反过来思考，每个数据项都有对其他数据项的指针，检索问题就变成了留下那些对检索有帮助的指针，可以是比自身大的，可以是和自身相等的。而数组我把它抽象成这样一种结构，即我有一个中心节点知道指向所有数据的指针，而且还知道哪个指针指向的是第几个元素，只不过这里的指针是隐含的。 
<br>2 最近一直在想 计算机工程是tradeoff 的艺术，但我感觉大部分人很容易就变成了定性的说这个是时间换空间，这个是低延时是靠降低吞吐来换取的，但这个完全就是纸上的意淫，没有定量的思考就是耍流氓，就好像数组虽然我们说加个元素会导致大量元素迁移，你知道这个迁移的代价是多少吗，就是迁移的数据的个数吗，单位是多少呢？ 
当然定量又是何其艰难，业务何其复杂，计算机层次又何其多。 </div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> 
</div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 你的思考有两点非常好！<br>一个是从实际实现出发，而不是停留在纸面分析。由于有内存局部性原理，数组的查询效率是高于树和跳表的。甚至在小数据的情况下，都有可能数组的移动代价也不高（可用内存拷贝）。还有，数组还有范围查找能力更强的特点。<br>而另一点，你很好地去开始思考和抽象事情的核心，这是构建自己知识体系的很好的实践。<br><br><br></p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">10</span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/0f/54/9a/76c0af70.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>每天晒白牙</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-25 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0"> 跳表并不能完全替代有序数组 <br>1.有序数据占用的内存空间小于调表 <br>2.有序数组的读取操作能保持在很稳定的时间复杂度，而调表并不能 
<br>3.因为数组存储空间是连续的，可以利用内存的局部性原理加快查询 <br> <br>Redis 为何采用跳表而不是红黑树？ <br>1.跳表比红黑树更简单的实现了检索空间的平衡 
<br>2.跳表保持了链表顺序遍历的能力，需要遍历的场景，跳表比红黑树用起来方便 </div> <div class="_2r3UB1GX_0"> <span>展开</span><i 
class="iconfont"></i> </div> <!----> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> 
<i class="iconfont"></i> <span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> 
<span class="">5</span> </div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img 
src="https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <a>一步</a> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-25 </div> </div> <!----> </div> <div> <div 
class="_3M6kV3zb_0 _3D2NkqD6_0"> 有序数组 使用的是一段连续的内存可以支持随机访问，而且由于使用的是连续的内存的 可以高效使用 CPU 的局部性原理，可以缓存要访问数据之后的数据，进而范围查询更高效 
</div> <!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 总结得很好</p> </div> <div 
class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> <span></span> 
</div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">4</span> </div> <!----> 
</div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/0f/8f/bb/c1b69f95.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>老姜</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-25 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0"> 随机访问，充分利用CPU缓存，节省内存 </div> <div class="_2r3UB1GX_0"> <span>展开</span><i 
class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 回答很简明扼要！<br>除此之外，还有范围查找效率更高（CPU缓存 
+ 内存拷贝）</p> </div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">4</span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/0f/a1/e6/50da1b2d.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>旭东</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-29 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0"> 这个算法层层引入挺好，学习方法 </div> <div class="_2r3UB1GX_0"> <span>展开</span><i 
class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 这个也是我专栏设计的目标之一。用前面的知识引出后面的知识。后面的知识是前面的知识的灵活应用。<br>课程用到的知识基本都是自成体系，这样大家在学习的时候就不用再去其他地方补基础知识了。</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">2</span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/0f/56/ea/a88d4a46.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>Harry</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-25 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0"> 为了将 k 插入到跳表中，需要检索跳表以确定其插入位置，同时还要为其生成一个随机的层级。 <br> <br>如何确定插入位置？为何使用一个随机的层级？目前还没有头绪… 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 1.确认k的插入位置 : 其实就是在跳表中查询“k”，如果不存在，那么最后的查询位置，就是k应该插入的位置；如果k已经存在（假设允许重复元素），那么就在找到的k的后面插入。<br><br>2.随机的层级，是用概率的思路来解决跳表指针平衡分布的问题。我可以换一种角度再描述一下。你可以按我的描述，在纸上将图画出来，看看是否会好理解:<br>假设我们有m个节点，由于随机函数是（1/2）^n，因此，每个节点有第0层的概率是1，也就是说，所有的节点都有一个指向下一个节点的指针。（试着画出来）<br>而节点拥有第1层的概率，变成了1/2，也就是只有一半的随机节点会有第1层，那么这一半的节点就会连起来。（试着画出来）<br>在这一半的节点中，拥有第3层的节点数，又是随机的一半。（试着画出来）<br>你会看到，通过一个简单的随机函数，就能完成跳表的平衡分布指针的目的。</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">2</span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/1a/9d/7a/fb762fea.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>SkillIP</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-25 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0"> 最主要还是以空间换时间吧！ <br>还有就是要考虑业务场景，如果存储的对象本身没有多大，却存了一大堆地址，是得不偿失的。 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 是的。合理的空间利用率也是很重要的事情。<br>此外，由于有内存局部性原理，因此，连续空间上的查询性能实际上会比树和跳表好</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">2</span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLEGtB7lUzH66b3nibVu3Xat4C0Wfp0umU3slsN32TF3icBwDOpShgdzMhaLW9z5LDFg3TTh0H62qAA/132" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>千里之行</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-25 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0"> 在小数据量、修改不频繁的场景下，有序数组可以获得稳定的且较短的查询时间，但调表由于新插入元素的指针间隔并不均匀，所以查询时间就得不到很好的保证 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 是的，小数据量下，数组会有更稳定的性能。<br>但不仅如此，由于内存局部性原理，大数据量下，数组的查询效率依然很高。<br>此外，对于范围查找，数组也有更高的效率（内存局部性原理+内存拷贝）</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">2</span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/0f/54/9a/76c0af70.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>每天晒白牙</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-25 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0"> 跳表并不能完全替代有序数组 <br>1.有序数据占用的内存空间小于调表 <br>2.有序数组的读取操作能保持在很稳定的时间复杂度，而调表并不能 
<br>3.因为数组存储空间是连续的，可以利用内存的局部性原理加快查询 </div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> 
</div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 在内存空间之外，你说到了很重要的两点:<br>1.小数据范围下，跳表性能没有数组稳定。<br>2.考虑内存局部性原理，数组实际查询效率更高。<br><br>此外还有一点，考虑到范围查找需求，数据的处理效率会更高（内存拷贝+内存局部性原理）</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">2</span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/10/46/ce/a1871469.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>一单成名</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-25 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0"> 只想到一个节约内存空间 </div> <div class="_2r3UB1GX_0"> <span>展开</span><i 
class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 节约空间的确是最大的一个优点。很多时候，内存空间是紧张的，甚至需要我们做数据压缩处理。在这种场景下，如果适合用数组，就不应该用树或者跳表。<br>此外，尽管理论上时间代价级别相同，但由于有内存局部性原理，连续空间的数据被处理的效率会更高。因此数组的实际查询效率会更高。<br>并且，如果考虑范围查找，数组能快速处理大段区域（比如使用内存拷贝技术），再叠加局部性原理，范围查找数组效率会远高于跳表和树。</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span>1</span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">2</span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>aoe</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-30 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 对数组、链表、跳表、树的搜索有了进一步认识。谢谢老师！ </div> <!----> <div 
class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 继续加油！</p> </div> <div class="_1w8H0ktn_0 
_2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> <span></span> </div> <div 
class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> </div> <!----> </div> 
</div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/14/1c/71/2f52da16.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>努力努力再努力Xmn</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-29 </div> </div> <!----> 
</div> <div> <div class="_3M6kV3zb_0"> 老师说RandonLevel的结果是随机的，如果说RandomLevel的结果没有范围的话，那next数组的大小不就没法确定了吗？ 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 其实可以使用可变长数组来处理。一种简单的可变长数组实现方案就是:先给数组一个固定的初始长度，如果数组写满了，就生成一个原数组两倍大小的新数组，然后将原数组的元素都导入新数组中。<br>关于可变长数组，你可以参考一下c++中vector的实现方案。</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/10/8d/3c/9025c2ca.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>张珮磊想静静</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-28 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 在读少写多的场景下，需要频繁变更以使得数据有序，是不是就不会考虑用数组，而是优先考虑二叉树和跳表 
</div> <!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 如果频繁修改的代价很大，影响到了整体性能，那么的确二叉树和跳表表现会更好。<br>当然，如果数据规模不大的情况下，数组性能有内存局部性原理的加持，即使是频繁插入和删除，也不一定性能很差。因此要合理评估。</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/10/4d/49/28e73b9c.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>明翼</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-27 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0"> 数组有自己的独特优势，比如数据集中存放的，程序在从内存到缓存取数据的时候，一次性搬一块数据，临近的数据都搬进来了，而二叉树和调表，用指针连接，无法利用缓存局部性原理的优势；虽然数组插入和删除性能差，当时有的场景并不需要这些，有的只需要构建好就不变了，这种比较适合用数组。 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 是的。数组的内存局部性优势是很重要的一点。甚至对于小规模数据集来说，插入删除时大块移动数据的性能也不见得差。</p> </div> 
<div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> <span></span> 
</div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> </div> <!----> 
</div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/14/1c/71/2f52da16.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>努力努力再努力Xmn</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-26 </div> </div> <!----> 
</div> <div> <div class="_3M6kV3zb_0"> 对于图中的插入节点k，听了老师的讲解也明白了，但是在思考具体的实现的时候，不知道如何下手，对于图中的单链表而言，插入节点k需要修改两层的指针连接，那它不就需要两个pre指针，分别指向a5, 
a6;那如果要插入的节点位于a4和a5之间而且RandomLevel的结果为3的话，岂不是需要3个pre指针；昨晚想了好久也没想出来应该如何实现插入，今天我在总结向老师提问的时候突然想到是不是跳表在设计的时候每一层都有一个指针呢？ 
<br>还有一个问题就是对于二叉搜索树而言，如果插入的节点重复了怎么办呢？因为我觉得这个问题虽然在例子中很好解决，如果重复的话，直接放弃插入就是了，但是对于真实的场景又该如何解决呢？希望老师解答。 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 动手实践是非常棒的！尤其是我的专栏重点是在检索原理和分析上，因此如果你能自己去学习细节，这就是非常好的补充。接下来，我来给你补充一下细节:<br>1.跳表本身已经有了许多指针，因此如果用双链表的方式实现的话，指针数会翻倍。不合适。因此，跳表是单向的，没有pre指针。<br>2.对于单链表的插入，我们的具体实现是给单链表加上一个头节点，然后寻找插入位置的“pre节点”来完成操作。跳表也是一样，有一个头节点。头节点的level，是所以节点中level的最大值。从头节点开始，每个level的指针链接，可以看做多个独立的单链表。（你可以画出来看看）<br>3.插入新节点的时候，核心思路是“寻找每个level的pre节点”。以我文章中插入k的例子来说，我们是怎么寻找到它的插入位置的？我们是先用第2层的指针进行遍历，发现k应该在a5到a9之间。于是，k的第2层的pre节点是a5！把a5记下来！（pre_node[2]=a5；）<br>然后，接下来，我们会用第1层的指针去遍历，这时候，会发现k在a5和a7之间。于是，k的第1层的pre节点是a5！！（pre_node[1]=a5；）<br>最后，用第0层的指针遍历，发现k在a6和a7之间，于是，k的第0层的pre节点是a6！！（pre_node[0]=a6；）<br>下一步，就把每一层的pre 
node和k的对应层连起来就好了。<br>4.一个有意思的场景，k有小概率生成4层指针，甚至5层指针，如果超出了之前所有节点的level，那么头节点就会扩展自己的level，低层level处理不变。新增的高层level直接连到k上。你会发现，随机level这个方法，完全基于概率，不用去考虑当前跳表中有多少个节点，这也是很巧妙的一点。<br><br>第二个问题:二叉检索树如何处理重复节点?如果你注意看我原文，我写了“右子树所有节点的值都大于等于根节点”。因此，二叉检索树是允许插入重复节点的。它的插入逻辑是“放在以该节点为根，右子树的最左节点的位置”。其实所谓“右子树的最左节点的位置”，其实拉直成链表来看，就是紧邻这个元素的后一个位置。</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Xeo83bVRZgql985iaPL7vaXQoN6VdBgbS0VYRgu69d5MdfLM4lpp5GXTNMSnnNEuvdYhBdib5KrnicmdrbDoicnBtQ/132" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>pedro</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-25 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0"> 我在学习红黑树的时候，深知红黑树的复杂，即使后来阅读《算法4》通过2-3树的方式来写红黑树，其实还是很有难度的，跳表在本身实现简单的情况下拥有和红黑树同等级别的性能，虽然应用没有红黑树广泛，但是确实是一个极其精巧的数据结构。 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 是的。所以跳表的设计很精巧。而且这种随机搭建高速通路的思路，在一些图搜索的场景中也有借鉴。</p> </div> <div 
class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> <span></span> 
</div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> </div> <!----> 
</div> </div> </div></li> <li class="reJj6Thl_0"><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/EvqrQ1wMs4SzC8dSBjAfVdEZ3yDT0bDUMicfRLq6BOSzjGFhCownt3S5MERXLpOpLmyJXCuyWbeOQG3ibzy0b4ibA/132" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>jkhcw</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-25 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0"> 有序数组优势是:一，快速而稳定的读性能，时间复杂度永远是O（1）.二，不会导致内存碎片化，避免了内存浪费. </div> 
<div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 数组的确比跳表更加稳定。不过内存碎片化问题，这个会有内存碎片处理来解决。<br><br>其实，还有两点是很关键的，一个是考虑实际情况，内存有局部性原理，对连续空间的处理会更高效；另一个是考虑范围查找，数组将查询结果成片复制出来效率会更高（内存拷贝技术+内存局部性原理）</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> 
</div> <!----> </div> </div> </div></li>', delta=0, field_comment_format='full_html', langcode='zh-hans', 
revision_id=1152 where entity_id=1152 
 {executed in 1 msec}
2020-11-25 10:29:05.686 INFO  jdbc.sqltiming Line:373 - select nodefieldc0_.entity_id as entity_i1_14_0_, nodefieldc0_.bundle as bundle2_14_0_, nodefieldc0_.field_comment_value 
as field_co3_14_0_, nodefieldc0_.delta as delta4_14_0_, nodefieldc0_.field_comment_format as 
field_co5_14_0_, nodefieldc0_.langcode as langcode6_14_0_, nodefieldc0_.revision_id as revision7_14_0_ 
from node_revision__field_comment nodefieldc0_ where nodefieldc0_.entity_id=1152 
 {executed in 0 msec}
2020-11-25 10:29:05.686 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|--------------------|------|---------------------|---------|------------|
|entity_id |bundle |field_comment_value |delta |field_comment_format |langcode |revision_id |
|----------|-------|--------------------|------|---------------------|---------|------------|
|[unread]  |book   |                    |0     |full_html            |zh-hans  |1152        |
|----------|-------|--------------------|------|---------------------|---------|------------|

2020-11-25 10:29:05.696 INFO  jdbc.sqltiming Line:373 - update node_revision__field_comment set bundle='book', field_comment_value='<li class="reJj6Thl_0"><img 
src="https://static001.geekbang.org/account/avatar/00/10/1d/13/31ea1b0b.jpg" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <a>峰</a> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-25 </div> </div> <!----> </div> <div> <div 
class="_3M6kV3zb_0"> 1，虽然时间复杂度一致，但并不代表真实的时间一致，时间复杂度只是量级，所以数据量小的情况下，数组能甩其他结构几条街。2，就是存储空间的节省。 
<br> <br>这篇文章让我有很多延伸想法，1，检索操作映射到底层核心就是cpu对存储的寻址方式，而这上层的抽象就是指针和数组，老师向我们展示了添加指针构建二叉树的过程，反过来思考，每个数据项都有对其他数据项的指针，检索问题就变成了留下那些对检索有帮助的指针，可以是比自身大的，可以是和自身相等的。而数组我把它抽象成这样一种结构，即我有一个中心节点知道指向所有数据的指针，而且还知道哪个指针指向的是第几个元素，只不过这里的指针是隐含的。 
<br>2 最近一直在想 计算机工程是tradeoff 的艺术，但我感觉大部分人很容易就变成了定性的说这个是时间换空间，这个是低延时是靠降低吞吐来换取的，但这个完全就是纸上的意淫，没有定量的思考就是耍流氓，就好像数组虽然我们说加个元素会导致大量元素迁移，你知道这个迁移的代价是多少吗，就是迁移的数据的个数吗，单位是多少呢？ 
当然定量又是何其艰难，业务何其复杂，计算机层次又何其多。 </div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> 
</div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 你的思考有两点非常好！<br>一个是从实际实现出发，而不是停留在纸面分析。由于有内存局部性原理，数组的查询效率是高于树和跳表的。甚至在小数据的情况下，都有可能数组的移动代价也不高（可用内存拷贝）。还有，数组还有范围查找能力更强的特点。<br>而另一点，你很好地去开始思考和抽象事情的核心，这是构建自己知识体系的很好的实践。<br><br><br></p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">10</span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/0f/54/9a/76c0af70.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>每天晒白牙</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-25 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0"> 跳表并不能完全替代有序数组 <br>1.有序数据占用的内存空间小于调表 <br>2.有序数组的读取操作能保持在很稳定的时间复杂度，而调表并不能 
<br>3.因为数组存储空间是连续的，可以利用内存的局部性原理加快查询 <br> <br>Redis 为何采用跳表而不是红黑树？ <br>1.跳表比红黑树更简单的实现了检索空间的平衡 
<br>2.跳表保持了链表顺序遍历的能力，需要遍历的场景，跳表比红黑树用起来方便 </div> <div class="_2r3UB1GX_0"> <span>展开</span><i 
class="iconfont"></i> </div> <!----> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> 
<i class="iconfont"></i> <span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> 
<span class="">5</span> </div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img 
src="https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <a>一步</a> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-25 </div> </div> <!----> </div> <div> <div 
class="_3M6kV3zb_0 _3D2NkqD6_0"> 有序数组 使用的是一段连续的内存可以支持随机访问，而且由于使用的是连续的内存的 可以高效使用 CPU 的局部性原理，可以缓存要访问数据之后的数据，进而范围查询更高效 
</div> <!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 总结得很好</p> </div> <div 
class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> <span></span> 
</div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">4</span> </div> <!----> 
</div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/0f/8f/bb/c1b69f95.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>老姜</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-25 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0"> 随机访问，充分利用CPU缓存，节省内存 </div> <div class="_2r3UB1GX_0"> <span>展开</span><i 
class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 回答很简明扼要！<br>除此之外，还有范围查找效率更高（CPU缓存 
+ 内存拷贝）</p> </div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">4</span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/0f/a1/e6/50da1b2d.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>旭东</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-29 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0"> 这个算法层层引入挺好，学习方法 </div> <div class="_2r3UB1GX_0"> <span>展开</span><i 
class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 这个也是我专栏设计的目标之一。用前面的知识引出后面的知识。后面的知识是前面的知识的灵活应用。<br>课程用到的知识基本都是自成体系，这样大家在学习的时候就不用再去其他地方补基础知识了。</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">2</span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/0f/56/ea/a88d4a46.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>Harry</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-25 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0"> 为了将 k 插入到跳表中，需要检索跳表以确定其插入位置，同时还要为其生成一个随机的层级。 <br> <br>如何确定插入位置？为何使用一个随机的层级？目前还没有头绪… 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 1.确认k的插入位置 : 其实就是在跳表中查询“k”，如果不存在，那么最后的查询位置，就是k应该插入的位置；如果k已经存在（假设允许重复元素），那么就在找到的k的后面插入。<br><br>2.随机的层级，是用概率的思路来解决跳表指针平衡分布的问题。我可以换一种角度再描述一下。你可以按我的描述，在纸上将图画出来，看看是否会好理解:<br>假设我们有m个节点，由于随机函数是（1/2）^n，因此，每个节点有第0层的概率是1，也就是说，所有的节点都有一个指向下一个节点的指针。（试着画出来）<br>而节点拥有第1层的概率，变成了1/2，也就是只有一半的随机节点会有第1层，那么这一半的节点就会连起来。（试着画出来）<br>在这一半的节点中，拥有第3层的节点数，又是随机的一半。（试着画出来）<br>你会看到，通过一个简单的随机函数，就能完成跳表的平衡分布指针的目的。</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">2</span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/1a/9d/7a/fb762fea.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>SkillIP</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-25 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0"> 最主要还是以空间换时间吧！ <br>还有就是要考虑业务场景，如果存储的对象本身没有多大，却存了一大堆地址，是得不偿失的。 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 是的。合理的空间利用率也是很重要的事情。<br>此外，由于有内存局部性原理，因此，连续空间上的查询性能实际上会比树和跳表好</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">2</span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLEGtB7lUzH66b3nibVu3Xat4C0Wfp0umU3slsN32TF3icBwDOpShgdzMhaLW9z5LDFg3TTh0H62qAA/132" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>千里之行</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-25 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0"> 在小数据量、修改不频繁的场景下，有序数组可以获得稳定的且较短的查询时间，但调表由于新插入元素的指针间隔并不均匀，所以查询时间就得不到很好的保证 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 是的，小数据量下，数组会有更稳定的性能。<br>但不仅如此，由于内存局部性原理，大数据量下，数组的查询效率依然很高。<br>此外，对于范围查找，数组也有更高的效率（内存局部性原理+内存拷贝）</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">2</span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/0f/54/9a/76c0af70.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>每天晒白牙</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-25 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0"> 跳表并不能完全替代有序数组 <br>1.有序数据占用的内存空间小于调表 <br>2.有序数组的读取操作能保持在很稳定的时间复杂度，而调表并不能 
<br>3.因为数组存储空间是连续的，可以利用内存的局部性原理加快查询 </div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> 
</div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 在内存空间之外，你说到了很重要的两点:<br>1.小数据范围下，跳表性能没有数组稳定。<br>2.考虑内存局部性原理，数组实际查询效率更高。<br><br>此外还有一点，考虑到范围查找需求，数据的处理效率会更高（内存拷贝+内存局部性原理）</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">2</span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/10/46/ce/a1871469.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>一单成名</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-25 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0"> 只想到一个节约内存空间 </div> <div class="_2r3UB1GX_0"> <span>展开</span><i 
class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 节约空间的确是最大的一个优点。很多时候，内存空间是紧张的，甚至需要我们做数据压缩处理。在这种场景下，如果适合用数组，就不应该用树或者跳表。<br>此外，尽管理论上时间代价级别相同，但由于有内存局部性原理，连续空间的数据被处理的效率会更高。因此数组的实际查询效率会更高。<br>并且，如果考虑范围查找，数组能快速处理大段区域（比如使用内存拷贝技术），再叠加局部性原理，范围查找数组效率会远高于跳表和树。</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span>1</span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">2</span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>aoe</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-30 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 对数组、链表、跳表、树的搜索有了进一步认识。谢谢老师！ </div> <!----> <div 
class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 继续加油！</p> </div> <div class="_1w8H0ktn_0 
_2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> <span></span> </div> <div 
class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> </div> <!----> </div> 
</div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/14/1c/71/2f52da16.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>努力努力再努力Xmn</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-29 </div> </div> <!----> 
</div> <div> <div class="_3M6kV3zb_0"> 老师说RandonLevel的结果是随机的，如果说RandomLevel的结果没有范围的话，那next数组的大小不就没法确定了吗？ 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 其实可以使用可变长数组来处理。一种简单的可变长数组实现方案就是:先给数组一个固定的初始长度，如果数组写满了，就生成一个原数组两倍大小的新数组，然后将原数组的元素都导入新数组中。<br>关于可变长数组，你可以参考一下c++中vector的实现方案。</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/10/8d/3c/9025c2ca.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>张珮磊想静静</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-28 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 在读少写多的场景下，需要频繁变更以使得数据有序，是不是就不会考虑用数组，而是优先考虑二叉树和跳表 
</div> <!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 如果频繁修改的代价很大，影响到了整体性能，那么的确二叉树和跳表表现会更好。<br>当然，如果数据规模不大的情况下，数组性能有内存局部性原理的加持，即使是频繁插入和删除，也不一定性能很差。因此要合理评估。</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/10/4d/49/28e73b9c.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>明翼</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-27 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0"> 数组有自己的独特优势，比如数据集中存放的，程序在从内存到缓存取数据的时候，一次性搬一块数据，临近的数据都搬进来了，而二叉树和调表，用指针连接，无法利用缓存局部性原理的优势；虽然数组插入和删除性能差，当时有的场景并不需要这些，有的只需要构建好就不变了，这种比较适合用数组。 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 是的。数组的内存局部性优势是很重要的一点。甚至对于小规模数据集来说，插入删除时大块移动数据的性能也不见得差。</p> </div> 
<div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> <span></span> 
</div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> </div> <!----> 
</div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/14/1c/71/2f52da16.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>努力努力再努力Xmn</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-26 </div> </div> <!----> 
</div> <div> <div class="_3M6kV3zb_0"> 对于图中的插入节点k，听了老师的讲解也明白了，但是在思考具体的实现的时候，不知道如何下手，对于图中的单链表而言，插入节点k需要修改两层的指针连接，那它不就需要两个pre指针，分别指向a5, 
a6;那如果要插入的节点位于a4和a5之间而且RandomLevel的结果为3的话，岂不是需要3个pre指针；昨晚想了好久也没想出来应该如何实现插入，今天我在总结向老师提问的时候突然想到是不是跳表在设计的时候每一层都有一个指针呢？ 
<br>还有一个问题就是对于二叉搜索树而言，如果插入的节点重复了怎么办呢？因为我觉得这个问题虽然在例子中很好解决，如果重复的话，直接放弃插入就是了，但是对于真实的场景又该如何解决呢？希望老师解答。 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 动手实践是非常棒的！尤其是我的专栏重点是在检索原理和分析上，因此如果你能自己去学习细节，这就是非常好的补充。接下来，我来给你补充一下细节:<br>1.跳表本身已经有了许多指针，因此如果用双链表的方式实现的话，指针数会翻倍。不合适。因此，跳表是单向的，没有pre指针。<br>2.对于单链表的插入，我们的具体实现是给单链表加上一个头节点，然后寻找插入位置的“pre节点”来完成操作。跳表也是一样，有一个头节点。头节点的level，是所以节点中level的最大值。从头节点开始，每个level的指针链接，可以看做多个独立的单链表。（你可以画出来看看）<br>3.插入新节点的时候，核心思路是“寻找每个level的pre节点”。以我文章中插入k的例子来说，我们是怎么寻找到它的插入位置的？我们是先用第2层的指针进行遍历，发现k应该在a5到a9之间。于是，k的第2层的pre节点是a5！把a5记下来！（pre_node[2]=a5；）<br>然后，接下来，我们会用第1层的指针去遍历，这时候，会发现k在a5和a7之间。于是，k的第1层的pre节点是a5！！（pre_node[1]=a5；）<br>最后，用第0层的指针遍历，发现k在a6和a7之间，于是，k的第0层的pre节点是a6！！（pre_node[0]=a6；）<br>下一步，就把每一层的pre 
node和k的对应层连起来就好了。<br>4.一个有意思的场景，k有小概率生成4层指针，甚至5层指针，如果超出了之前所有节点的level，那么头节点就会扩展自己的level，低层level处理不变。新增的高层level直接连到k上。你会发现，随机level这个方法，完全基于概率，不用去考虑当前跳表中有多少个节点，这也是很巧妙的一点。<br><br>第二个问题:二叉检索树如何处理重复节点?如果你注意看我原文，我写了“右子树所有节点的值都大于等于根节点”。因此，二叉检索树是允许插入重复节点的。它的插入逻辑是“放在以该节点为根，右子树的最左节点的位置”。其实所谓“右子树的最左节点的位置”，其实拉直成链表来看，就是紧邻这个元素的后一个位置。</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Xeo83bVRZgql985iaPL7vaXQoN6VdBgbS0VYRgu69d5MdfLM4lpp5GXTNMSnnNEuvdYhBdib5KrnicmdrbDoicnBtQ/132" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>pedro</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-25 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0"> 我在学习红黑树的时候，深知红黑树的复杂，即使后来阅读《算法4》通过2-3树的方式来写红黑树，其实还是很有难度的，跳表在本身实现简单的情况下拥有和红黑树同等级别的性能，虽然应用没有红黑树广泛，但是确实是一个极其精巧的数据结构。 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 是的。所以跳表的设计很精巧。而且这种随机搭建高速通路的思路，在一些图搜索的场景中也有借鉴。</p> </div> <div 
class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> <span></span> 
</div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> </div> <!----> 
</div> </div> </div></li> <li class="reJj6Thl_0"><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/EvqrQ1wMs4SzC8dSBjAfVdEZ3yDT0bDUMicfRLq6BOSzjGFhCownt3S5MERXLpOpLmyJXCuyWbeOQG3ibzy0b4ibA/132" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>jkhcw</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-25 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0"> 有序数组优势是:一，快速而稳定的读性能，时间复杂度永远是O（1）.二，不会导致内存碎片化，避免了内存浪费. </div> 
<div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 数组的确比跳表更加稳定。不过内存碎片化问题，这个会有内存碎片处理来解决。<br><br>其实，还有两点是很关键的，一个是考虑实际情况，内存有局部性原理，对连续空间的处理会更高效；另一个是考虑范围查找，数组将查询结果成片复制出来效率会更高（内存拷贝技术+内存局部性原理）</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> 
</div> <!----> </div> </div> </div></li>', delta=0, field_comment_format='full_html', langcode='zh-hans', 
revision_id=1152 where entity_id=1152 
 {executed in 8 msec}
2020-11-25 10:29:05.700 INFO  jdbc.sqltiming Line:373 - select bookfieldt0_.entity_id as entity_i1_9_, bookfieldt0_.bundle as bundle2_9_, bookfieldt0_.delta 
as delta3_9_, bookfieldt0_.langcode as langcode4_9_, bookfieldt0_.revision_id as revision5_9_, 
bookfieldt0_.field_thumb_value as field_th6_9_ from node__field_thumb bookfieldt0_ where bookfieldt0_.entity_id=1152 
 {executed in 1 msec}
2020-11-25 10:29:05.700 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------|------------------|
|entity_id |bundle |delta |langcode |revision_id |field_thumb_value |
|----------|-------|------|---------|------------|------------------|
|1152      |book   |0     |zh-hans  |1152        |                  |
|----------|-------|------|---------|------------|------------------|

2020-11-25 10:29:05.702 INFO  jdbc.sqltiming Line:373 - update node__field_thumb set bundle='book', delta=0, langcode='zh-hans', revision_id=1152, 
field_thumb_value='https://static001.geekbang.org/resource/image/58/99/583e373ff243054632dd602f44a30399.jpg' 
where entity_id=1152 
 {executed in 0 msec}
2020-11-25 10:29:05.705 INFO  jdbc.sqltiming Line:373 - select nodefieldt0_.entity_id as entity_i1_18_0_, nodefieldt0_.bundle as bundle2_18_0_, nodefieldt0_.delta 
as delta3_18_0_, nodefieldt0_.langcode as langcode4_18_0_, nodefieldt0_.revision_id as revision5_18_0_, 
nodefieldt0_.field_thumb_value as field_th6_18_0_ from node_revision__field_thumb nodefieldt0_ 
where nodefieldt0_.entity_id=1152 
 {executed in 0 msec}
2020-11-25 10:29:05.706 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------|------------------|
|entity_id |bundle |delta |langcode |revision_id |field_thumb_value |
|----------|-------|------|---------|------------|------------------|
|[unread]  |book   |0     |zh-hans  |1152        |                  |
|----------|-------|------|---------|------------|------------------|

2020-11-25 10:29:05.707 INFO  jdbc.sqltiming Line:373 - update node_revision__field_thumb set bundle='book', delta=0, langcode='zh-hans', revision_id=1152, 
field_thumb_value='https://static001.geekbang.org/resource/image/58/99/583e373ff243054632dd602f44a30399.jpg' 
where entity_id=1152 
 {executed in 0 msec}
2020-11-25 10:29:05.710 INFO  jdbc.sqltiming Line:373 - select bookfieldf0_.entity_id as entity_i1_6_0_, bookfieldf0_.bundle as bundle2_6_0_, bookfieldf0_.delta 
as delta3_6_0_, bookfieldf0_.field_fenlei_target_id as field_fe4_6_0_, bookfieldf0_.langcode 
as langcode5_6_0_, bookfieldf0_.revision_id as revision6_6_0_ from node__field_fenlei bookfieldf0_ 
where bookfieldf0_.entity_id=1152 
 {executed in 0 msec}
2020-11-25 10:29:05.710 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|-----------------------|---------|------------|
|entity_id |bundle |delta |field_fenlei_target_id |langcode |revision_id |
|----------|-------|------|-----------------------|---------|------------|
|[unread]  |book   |0     |1                      |zh-hans  |1152        |
|----------|-------|------|-----------------------|---------|------------|

2020-11-25 10:29:05.712 INFO  jdbc.sqltiming Line:373 - select nodefieldf0_.entity_id as entity_i1_15_0_, nodefieldf0_.bundle as bundle2_15_0_, nodefieldf0_.delta 
as delta3_15_0_, nodefieldf0_.field_fenlei_target_id as field_fe4_15_0_, nodefieldf0_.langcode 
as langcode5_15_0_, nodefieldf0_.revision_id as revision6_15_0_ from node_revision__field_fenlei 
nodefieldf0_ where nodefieldf0_.entity_id=1152 
 {executed in 0 msec}
2020-11-25 10:29:05.712 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|-----------------------|---------|------------|
|entity_id |bundle |delta |field_fenlei_target_id |langcode |revision_id |
|----------|-------|------|-----------------------|---------|------------|
|[unread]  |book   |0     |1                      |zh-hans  |1152        |
|----------|-------|------|-----------------------|---------|------------|

2020-11-25 10:29:05.714 INFO  jdbc.sqltiming Line:373 - select bookchecke0_.item_id as item_id1_2_, bookchecke0_.fsid as fsid2_2_, bookchecke0_.got 
as got3_2_, bookchecke0_.name as name4_2_, bookchecke0_.parse_fail as parse_fa5_2_, bookchecke0_.parsed 
as parsed6_2_, bookchecke0_.path as path7_2_, bookchecke0_.title as title8_2_, bookchecke0_.vid 
as vid9_2_ from book_check bookchecke0_ where bookchecke0_.fsid='549182670159463' and bookchecke0_.name='net_content' 
 {executed in 0 msec}
2020-11-25 10:29:05.715 INFO  jdbc.resultsettable Line:610 - 
|--------|---------|---------|---------|-----------|---------|---------|---------|---------|
|item_id |fsid     |got      |name     |parse_fail |parsed   |path     |title    |vid      |
|--------|---------|---------|---------|-----------|---------|---------|---------|---------|
|1153    |[unread] |[unread] |[unread] |[unread]   |[unread] |[unread] |[unread] |[unread] |
|--------|---------|---------|---------|-----------|---------|---------|---------|---------|

2020-11-25 10:29:57.260 INFO  jdbc.sqltiming Line:373 - update book_check set fsid='549182670159463', got=1, name='net_content', parse_fail='', parsed=1, 
path='123-检索技术核心20讲/02丨基础技术篇 (8讲)/03丨哈希检索：如何根据用户ID快速查询用户信息？.html', title='03丨哈希检索：如何根据用户ID快速查询用户信息？', 
vid=1153 where item_id=1153 
 {executed in 0 msec}
2020-11-25 10:29:57.269 INFO  jdbc.sqltiming Line:373 - select nodebodyen0_.entity_id as entity_i1_4_, nodebodyen0_.body_value as body_val2_4_, nodebodyen0_.body_summary 
as body_sum3_4_, nodebodyen0_.bundle as bundle4_4_, nodebodyen0_.delta as delta5_4_, nodebodyen0_.body_format 
as body_for6_4_, nodebodyen0_.langcode as langcode7_4_, nodebodyen0_.revision_id as revision8_4_ 
from node__body nodebodyen0_ where nodebodyen0_.entity_id=1153 
 {executed in 1 msec}
2020-11-25 10:29:57.269 INFO  jdbc.resultsettable Line:610 - 
|----------|-----------|-------------|-------|------|------------|---------|------------|
|entity_id |body_value |body_summary |bundle |delta |body_format |langcode |revision_id |
|----------|-----------|-------------|-------|------|------------|---------|------------|
|1153      |           |             |book   |0     |full_html   |zh-hans  |1153        |
|----------|-----------|-------------|-------|------|------------|---------|------------|

2020-11-25 10:29:57.270 INFO  jdbc.sqltiming Line:373 - select nodebodyre0_.entity_id as entity_i1_13_0_, nodebodyre0_.body_value as body_val2_13_0_, 
nodebodyre0_.body_summary as body_sum3_13_0_, nodebodyre0_.bundle as bundle4_13_0_, nodebodyre0_.delta 
as delta5_13_0_, nodebodyre0_.body_format as body_for6_13_0_, nodebodyre0_.langcode as langcode7_13_0_, 
nodebodyre0_.revision_id as revision8_13_0_ from node_revision__body nodebodyre0_ where nodebodyre0_.entity_id=1153 
 {executed in 0 msec}
2020-11-25 10:29:57.271 INFO  jdbc.resultsettable Line:610 - 
|----------|-----------|-------------|-------|------|------------|---------|------------|
|entity_id |body_value |body_summary |bundle |delta |body_format |langcode |revision_id |
|----------|-----------|-------------|-------|------|------------|---------|------------|
|[unread]  |           |             |book   |0     |full_html   |zh-hans  |1153        |
|----------|-----------|-------------|-------|------|------------|---------|------------|

2020-11-25 10:29:57.274 INFO  jdbc.sqltiming Line:373 - update node__body set body_value='<div data-slate-editor="true" data-key="844" autocorrect="off" 
spellcheck="false" data-gramm="false" style="outline: none; white-space: pre-wrap; overflow-wrap: 
break-word;"> <div class="se-099f7870 " data-slate-type="paragraph" data-slate-object="block" 
data-key="845"> <span data-slate-object="text" data-key="846"><span data-slate-leaf="true" 
data-offset-key="846:0" data-first-offset="true"><span data-slate-string="true">你好，我是陈东。</span></span></span> 
</div> <div class="se-b55d60e0 " data-slate-type="paragraph" data-slate-object="block" data-key="847"> 
<span data-slate-object="text" data-key="848"><span data-slate-leaf="true" data-offset-key="848:0" 
data-first-offset="true"><span data-slate-string="true">在实际应用中，我们经常会面临需要根据键（Key）来查询数据的问题。比如说，给你一个用户 
ID，要求你查出该用户的具体信息。这样的需求我们应该如何实现呢？你可能会想到，使用有序数组和二叉检索树都可以来实现。具体来说，我们可以将用户 ID 和用户信息作为一个整体的元素，然后以用户 
ID 作为 Key 来排序，存入有序数组或者二叉检索树中，这样我们就能通过二分查找算法快速查询到用户信息了。</span></span></span> </div> <div class="se-25578578 
" data-slate-type="paragraph" data-slate-object="block" data-key="849"> <span data-slate-object="text" 
data-key="850"><span data-slate-leaf="true" data-offset-key="850:0" data-first-offset="true"><span 
data-slate-string="true">但是，不管是有序数组、二叉检索树还是跳表，它们的检索效率都是 O(log n)。那有没有更高效的检索方案呢？也就是说，有没有能实现 
O(1) 级别的查询方案呢？今天，我们就一起来探讨一下这个问题。</span></span></span> </div> <h2 class="se-ca51fd05" data-slate-type="heading" 
data-slate-object="block" data-key="851"><span data-slate-object="text" data-key="852"><span 
data-slate-leaf="true" data-offset-key="852:0" data-first-offset="true"><span data-slate-string="true">使用 
Hash 函数将 Key 转换为数组下标</span></span></span></h2> <div class="se-0f0e9027 " data-slate-type="paragraph" 
data-slate-object="block" data-key="853"> <span data-slate-object="text" data-key="854"><span 
data-slate-leaf="true" data-offset-key="854:0" data-first-offset="true"><span data-slate-string="true">在第 
1 讲中我们说过，数组具有随机访问的特性。那给定一个用户 ID，想要查询对应的用户信息，我们能否利用数组的随机访问特性来实现呢？</span></span></span> </div> 
<div class="se-9a5616ae " data-slate-type="paragraph" data-slate-object="block" data-key="855"> 
<span data-slate-object="text" data-key="856"><span data-slate-leaf="true" data-offset-key="856:0" 
data-first-offset="true"><span data-slate-string="true">我们先来看一个例子。假设系统中的用户 ID 是从 1 开始的整数，并且随着注册数的增加而增加。如果系统中的用户数是有限的，不会大于 
10 万。那么用户的 ID 范围就会被固定在 1 到 10 万之间。在数字范围有限的情况下，我们完全可以申请一个长度为 10 万的数组，然后将用户 ID 作为数组下标，从而实现 O(1) 
级别的查询能力。</span></span></span> </div> <div class="se-5f14673e" data-slate-type="image" data-slate-object="block" 
data-key="857"> <img class="se-84793368" src="https://static001.geekbang.org/resource/image/bb/cf/bb7ac50d85287e55dde85490a02080cf.jpg"> 
</div> <div class="se-3a6fb3dd se-48ecaa69" data-slate-type="paragraph" data-slate-object="block" 
data-key="858"> <span data-slate-object="text" data-key="859"><span data-slate-leaf="true" 
data-offset-key="859:0" data-first-offset="true"><span class="se-76c2338e" data-slate-type="secondary" 
data-slate-object="mark"><span data-slate-string="true">将用户 ID 直接作为下标查询 ，由于数组下标从 0 开始，因此查询时 
ID 要减 1 </span></span></span></span> </div> <div class="se-434b0b90 " data-slate-type="paragraph" 
data-slate-object="block" data-key="860"> <span data-slate-object="text" data-key="861"><span 
data-slate-leaf="true" data-offset-key="861:0" data-first-offset="true"><span data-slate-string="true">注意，刚才我们举的这个例子中有一个假设：用户的 
ID 是一个数字，并且范围有限。符合这种假设的用户 ID 才能作为数组下标，使用数组的随机访问特性，达到 O(1) 时间代价的高效检索能力。那如果用户的 ID 数字范围很大，数组无法申请这么大的空间该怎么办呢？或者，用户的 
ID 不是数字而是字符串，还能作为数组下标吗？</span></span></span> </div> <div class="se-158571cf " data-slate-type="paragraph" 
data-slate-object="block" data-key="862"> <span data-slate-object="text" data-key="863"><span 
data-slate-leaf="true" data-offset-key="863:0" data-first-offset="true"><span data-slate-string="true">我们假设有一个系统使用字符串作为用户 
ID。如果有一个用户的 ID 是“tom”，我们该怎么处理呢？我们能否将它转换为一个数字来表示呢？你可以先想一想解决方案，再和我继续往下分析。</span></span></span> 
</div> <div class="se-cb3afe68 " data-slate-type="paragraph" data-slate-object="block" data-key="864"> 
<span data-slate-object="text" data-key="865"><span data-slate-leaf="true" data-offset-key="865:0" 
data-first-offset="true"><span data-slate-string="true">我们来考虑这样一种方案：字母表是有限的，只有 26 个，我们可以用字母在字母表中的位置顺序作为数值。于是，就有：“t” 
= 20，“o” = 15，“m” = 13。我们可以把这个 ID 看作是 26 进制的数字，那么对于“tom”这个字符串，把它转为对应的数值就是 20 * 26^2 + 15*26 
+ 13 =149123，这是一个小于 26^4 = 456976‬的数。</span></span></span> </div> <div class="se-6e3fcd04 " 
data-slate-type="paragraph" data-slate-object="block" data-key="866"> <span data-slate-object="text" 
data-key="867"><span data-slate-leaf="true" data-offset-key="867:0" data-first-offset="true"><span 
data-slate-string="true">如果所有用户的 ID 都不超过 3 个字符，使用这个方法，我们用一个可以存储 456976‬个元素的数组就可以存储所有用户的信息了。实际上，工业界有许多更复杂的将字符串转为整数的哈希算法，但核心思想都是利用每个字符的编码和位置信息进行计算，这里我就不展开了。</span></span></span> 
</div> <div class="se-35d29c79 " data-slate-type="paragraph" data-slate-object="block" data-key="868"> 
<span data-slate-object="text" data-key="869"><span data-slate-leaf="true" data-offset-key="869:0" 
data-first-offset="true"><span data-slate-string="true">那如果内存空间有限，我们只能开辟一个存储 10000 个元素的数组该怎么办呢？这个时候，我们可以使用“tom”对应的数值 
149123 除以数组长度 10000，得到余数 9123，用这个余数作为数组下标。</span></span></span> </div> <div class="se-6125b677 
" data-slate-type="paragraph" data-slate-object="block" data-key="870"> <span data-slate-object="text" 
data-key="871"><span data-slate-leaf="true" data-offset-key="871:0" data-first-offset="true"><span 
data-slate-string="true">这种将对象转为有限范围的正整数的表示方法，就叫作 </span></span></span><span data-slate-object="text" 
data-key="872"><span data-slate-leaf="true" data-offset-key="872:0" data-first-offset="true"><span 
class="se-4c1bde26" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">Hash</span></span></span></span><span 
data-slate-object="text" data-key="873"><span data-slate-leaf="true" data-offset-key="873:0" 
data-first-offset="true"><span data-slate-string="true">，翻译过来叫</span></span></span><span data-slate-object="text" 
data-key="874"><span data-slate-leaf="true" data-offset-key="874:0" data-first-offset="true"><span 
class="se-5cd56ee9" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">散列</span></span></span></span><span 
data-slate-object="text" data-key="875"><span data-slate-leaf="true" data-offset-key="875:0" 
data-first-offset="true"><span data-slate-string="true">，也可以直接音译为</span></span></span><span 
data-slate-object="text" data-key="876"><span data-slate-leaf="true" data-offset-key="876:0" 
data-first-offset="true"><span class="se-d6b2feee" data-slate-type="bold" data-slate-object="mark"><span 
data-slate-string="true">哈希</span></span></span></span><span data-slate-object="text" data-key="877"><span 
data-slate-leaf="true" data-offset-key="877:0" data-first-offset="true"><span data-slate-string="true">。而我们常说的 
Hash 函数就是指具体转换方法的函数。我们将对象进行 Hash，用得到的 Hash 值作为数组下标，将对应元素存在数组中。这个数组就叫作</span></span></span><span 
data-slate-object="text" data-key="878"><span data-slate-leaf="true" data-offset-key="878:0" 
data-first-offset="true"><span class="se-cc258018" data-slate-type="bold" data-slate-object="mark"><span 
data-slate-string="true">哈希表</span></span></span></span><span data-slate-object="text" data-key="879"><span 
data-slate-leaf="true" data-offset-key="879:0" data-first-offset="true"><span data-slate-string="true">。这样我们就可以利用数组的随机访问特性，达到 
O(1) 级别的查询性能。</span></span></span> </div> <div class="se-aa12f0b2 " data-slate-type="paragraph" 
data-slate-object="block" data-key="880"> <span data-slate-object="text" data-key="881"><span 
data-slate-leaf="true" data-offset-key="881:0" data-first-offset="true"><span data-slate-string="true">说到这里，你可能会有疑问了，Hash 
函数真的这么神奇吗？如果两个对象的哈希值是相同的怎么办？事实上，任何 Hash 函数都有可能造成对象不同，但 Hash 值相同的冲突。而且，数组空间是有限的，只要被 Hash 的元素个数大于数组上限，就一定会产生冲突。</span></span></span> 
</div> <div class="se-2e8c2a77 " data-slate-type="paragraph" data-slate-object="block" data-key="882"> 
<span data-slate-object="text" data-key="883"><span data-slate-leaf="true" data-offset-key="883:0" 
data-first-offset="true"><span data-slate-string="true">对于哈希冲突这个问题，我们有两类解决方案: 一类是构造尽可能理想的 Hash 
函数，使得 Hash 以后得到的数值尽可能平均分布，从而减少冲突发生的概率；另一类是在冲突发生以后，通过“提供冲突解决方案”来完成存储和查找。最常用的两种冲突解决方案是“开放寻址法”和“链表法”。下面，我就来介绍一下这两种方法，并且重点看看它们对检索效率的影响。</span></span></span> 
</div> <h2 class="se-e15cbf1f" data-slate-type="heading" data-slate-object="block" data-key="884"><span 
data-slate-object="text" data-key="885"><span data-slate-leaf="true" data-offset-key="885:0" 
data-first-offset="true"><span data-slate-string="true">如何利用开放寻址法解决 Hash 冲突？</span></span></span></h2> 
<div class="se-e1b07254 " data-slate-type="paragraph" data-slate-object="block" data-key="886"> 
<span data-slate-object="text" data-key="887"><span data-slate-leaf="true" data-offset-key="887:0" 
data-first-offset="true"><span data-slate-string="true">所谓“开放寻址法”，就是在冲突发生以后，最新的元素需要寻找新空闲的数组位置完成插入。那我们该如何寻找新空闲的位置呢？我们可以使用一种叫作“线性探查”（Linear 
Probing）的方案来进行查找。</span></span></span> </div> <div class="se-12311b32 " data-slate-type="paragraph" 
data-slate-object="block" data-key="888"> <span data-slate-object="text" data-key="889"><span 
data-slate-leaf="true" data-offset-key="889:0" data-first-offset="true"><span data-slate-string="true">“线性探查”的插入逻辑很简单：在当前位置发现有冲突以后，就顺序去查看数组的下一个位置，看看是否空闲。如果有空闲，就插入；如果不是空闲，再顺序去看下一个位置，直到找到空闲位置插入为止。</span></span></span> 
</div> <div class="se-bae4427e " data-slate-type="paragraph" data-slate-object="block" data-key="890"> 
<span data-slate-object="text" data-key="891"><span data-slate-leaf="true" data-offset-key="891:0" 
data-first-offset="true"><span data-slate-string="true">查询逻辑也和插入逻辑相似。我们先根据 Hash 值去查找相应数组下标的元素，如果该位置不为空，但是存储元素的 
Key 和查询的 Key 不一致，那就顺序到数组下一个位置去检索，就这样依次比较 Key。如果访问元素的 Key 和查询 Key 相等，我们就在哈希表中找到了对应元素；如果遍历到空闲处，依然没有元素的 
Key 和查询 Key 相等，则说明哈希表中不存在该元素。</span></span></span> </div> <div class="se-3381c07b " data-slate-type="paragraph" 
data-slate-object="block" data-key="892"> <span data-slate-object="text" data-key="893"><span 
data-slate-leaf="true" data-offset-key="893:0" data-first-offset="true"><span data-slate-string="true">为了帮助你更好地理解，我们来看一个例子。</span></span></span> 
</div> <div class="se-a2d6f33f " data-slate-type="paragraph" data-slate-object="block" data-key="894"> 
<span data-slate-object="text" data-key="895"><span data-slate-leaf="true" data-offset-key="895:0" 
data-first-offset="true"><span data-slate-string="true">假设一个哈希表中已经插入了两个 Key，key1 和 key2。其中 
Hash(key1) = 1, Hash(key2) = 2。这时，如果我们要插入一个 Hash 值为 1 的 key3。根据线性探查的插入逻辑，通过 3 步，我们就可以将 key3 
插入到哈希表下标为 3 的位置中。插入的过程如下：</span></span></span> </div> <div class="se-5fd9f687" data-slate-type="image" 
data-slate-object="block" data-key="896"> <img class="se-b257c40c" src="https://static001.geekbang.org/resource/image/8b/d0/8b0de808f6485bde014019e9d158b0d0.jpg"> 
</div> <div class="se-a1d5483f " data-slate-type="paragraph" data-slate-object="block" data-key="897"> 
<span data-slate-object="text" data-key="898"><span data-slate-leaf="true" data-offset-key="898:0" 
data-first-offset="true"><span data-slate-string="true">在查找 key3 的时候，因为 Hash（key3）= 1，我们会从哈希表下标为 
1 的位置开始顺序查找，经过 3 步找到 key3，查询结束。</span></span></span> </div> <div class="se-d9717fab " data-slate-type="paragraph" 
data-slate-object="block" data-key="899"> <span data-slate-object="text" data-key="900"><span 
data-slate-leaf="true" data-offset-key="900:0" data-first-offset="true"><span data-slate-string="true">讲到这里，你可能已经发现了一个问题：当我们插入一个 
Key 时，如果哈希表已经比较满了，这个 Key 就会沿着数组一直顺序遍历，直到遇到空位置才会成功插入。查询的时候也一样。但是，顺序遍历的代价是 O(n)，这样的检索性能很差。</span></span></span> 
</div> <div class="se-fe0f6de4 " data-slate-type="paragraph" data-slate-object="block" data-key="901"> 
<span data-slate-object="text" data-key="902"><span data-slate-leaf="true" data-offset-key="902:0" 
data-first-offset="true"><span data-slate-string="true">更糟糕的是，如果我们在插入 key1 后，先插入 key3 再插入 key2，那 
key3 就会抢占 key2 的位置，影响 key2 的插入和查询效率。</span></span></span><span data-slate-object="text" data-key="903"><span 
data-slate-leaf="true" data-offset-key="903:0" data-first-offset="true"><span class="se-af99cbfd" 
data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">因此，“线性探查”会影响哈希表的整体性能，而不只是 
Hash 值冲突的 Key</span></span></span></span><span data-slate-object="text" data-key="904"><span 
data-slate-leaf="true" data-offset-key="904:0" data-first-offset="true"><span data-slate-string="true">。</span></span></span> 
</div> <div class="se-dabbeb85 " data-slate-type="paragraph" data-slate-object="block" data-key="905"> 
<span data-slate-object="text" data-key="906"><span data-slate-leaf="true" data-offset-key="906:0" 
data-first-offset="true"><span data-slate-string="true">为了解决这个问题，我们可以使用“二次探查”（Quadratic Probing）和“双散列”（Double 
Hash）这两个方法进行优化。下面，我来分别解释一下这两个方法的优化原理。</span></span></span> </div> <div class="se-5f84fef4 " 
data-slate-type="paragraph" data-slate-object="block" data-key="907"> <span data-slate-object="text" 
data-key="908"><span data-slate-leaf="true" data-offset-key="908:0" data-first-offset="true"><span 
data-slate-string="true">二次探查就是将线性探查的步长从 i 改为 i^2：第一次探查，位置为 Hash(key) + 1^2；第二次探查，位置为 Hash(key) 
+2^2；第三次探查，位置为 Hash(key) + 3^2，依此类推。</span></span></span> </div> <div class="se-bafd0009 " 
data-slate-type="paragraph" data-slate-object="block" data-key="909"> <span data-slate-object="text" 
data-key="910"><span data-slate-leaf="true" data-offset-key="910:0" data-first-offset="true"><span 
data-slate-string="true">双散列就是使用多个 Hash 函数来求下标位置，当第一个 Hash 函数求出来的位置冲突时，启用第二个 Hash 函数，算出第二次探查的位置；如果还冲突，则启用第三个 
Hash 函数，算出第三次探查的位置，依此类推。</span></span></span> </div> <div class="se-0e91b4b6 " data-slate-type="paragraph" 
data-slate-object="block" data-key="911"> <span data-slate-object="text" data-key="912"><span 
data-slate-leaf="true" data-offset-key="912:0" data-first-offset="true"><span data-slate-string="true">无论是二次探查还是双散列，核心思路其实都是在发生冲突的情况下，将下个位置尽可能地岔开，让数据尽可能地随机分散存储，来降低对不相干 
Key 的干扰，从而提高整体的检索效率。</span></span></span> </div> <div class="se-53d0ac5c " data-slate-type="paragraph" 
data-slate-object="block" data-key="913"> <span data-slate-object="text" data-key="914"><span 
data-slate-leaf="true" data-offset-key="914:0" data-first-offset="true"><span data-slate-string="true">但是，对于开放寻址法来说，无论使用什么优化方案，随着插入的元素越多、哈希表越满，插入和检索的性能也就下降得越厉害。在极端情况下，当哈希表被写满的时候，为了保证能插入新元素，我们只能重新生成一个更大的哈希表，将旧哈希表中的所有数据重新 
Hash 一次写入新的哈希表，也就是 </span></span></span><span data-slate-object="text" data-key="915"><span 
data-slate-leaf="true" data-offset-key="915:0" data-first-offset="true"><span class="se-61515aec" 
data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">Re-Hash</span></span></span></span><span 
data-slate-object="text" data-key="916"><span data-slate-leaf="true" data-offset-key="916:0" 
data-first-offset="true"><span data-slate-string="true">，这样会造成非常大的额外开销。因此，在数据动态变化的场景下，使用开放寻址法并不是最合适的方案。</span></span></span> 
</div> <h2 class="se-497ed824" data-slate-type="heading" data-slate-object="block" data-key="917"><span 
data-slate-object="text" data-key="918"><span data-slate-leaf="true" data-offset-key="918:0" 
data-first-offset="true"><span data-slate-string="true">如何利用链表法解决 Hash 冲突？</span></span></span></h2> 
<div class="se-81866e45 " data-slate-type="paragraph" data-slate-object="block" data-key="919"> 
<span data-slate-object="text" data-key="920"><span data-slate-leaf="true" data-offset-key="920:0" 
data-first-offset="true"><span data-slate-string="true">相比开放寻址法，还有一种更常见的冲突解决方案，链表法。所谓“链表法”，就是在数组中不存储一个具体元素，而是存储一个链表头。如果一个 
Key 经过 Hash 函数计算，得到了对应的数组下标，那么我们就将它加入该位置所存的链表的尾部。</span></span></span> </div> <div class="se-8dde9a79 
" data-slate-type="paragraph" data-slate-object="block" data-key="921"> <span data-slate-object="text" 
data-key="922"><span data-slate-leaf="true" data-offset-key="922:0" data-first-offset="true"><span 
data-slate-string="true">这样做的好处是，如果 key3 和 key1 发生了冲突，那么 key3 会通过链表的方式链接在 key1 的后面，而不是去占据 key2 
的位置。这样当 key2 插入时，就不会有冲突了。最终效果如下图。</span></span></span> </div> <div class="se-a9c7a690" data-slate-type="image" 
data-slate-object="block" data-key="923"> <img class="se-70c1709b" src="https://static001.geekbang.org/resource/image/b9/07/b91d6e394af24935f67dc21293bc0c07.jpg"> 
</div> <div class="se-1f8f7a69 se-a0e1b836" data-slate-type="paragraph" data-slate-object="block" 
data-key="924"> <span data-slate-object="text" data-key="925"><span data-slate-leaf="true" 
data-offset-key="925:0" data-first-offset="true"><span class="se-76c2338e" data-slate-type="secondary" 
data-slate-object="mark"><span data-slate-string="true">链表法</span></span></span></span> </div> 
<div class="se-774e8d4d " data-slate-type="paragraph" data-slate-object="block" data-key="926"> 
<span data-slate-object="text" data-key="927"><span data-slate-leaf="true" data-offset-key="927:0" 
data-first-offset="true"><span data-slate-string="true">讲到这里，你可能已经发现了，其实链表法就是将我们前面讲过的数组和链表进行结合，既利用了数组的随机访问特性，又利用了链表的动态修改特性，同时提供了快速查询和动态修改的能力。</span></span></span> 
</div> <div class="se-8ffdafe3 " data-slate-type="paragraph" data-slate-object="block" data-key="928"> 
<span data-slate-object="text" data-key="929"><span data-slate-leaf="true" data-offset-key="929:0" 
data-first-offset="true"><span data-slate-string="true">想要查询时，我们会先根据查询 Key 的 Hash 值，去查找相应数组下标的链表。如果链表为空，则表示不存在该元素；如果链表不为空，则遍历链表，直到找到 
Key 相等的对应元素为止。</span></span></span> </div> <div class="se-2439dbc1 " data-slate-type="paragraph" 
data-slate-object="block" data-key="930"> <span data-slate-object="text" data-key="931"><span 
data-slate-leaf="true" data-offset-key="931:0" data-first-offset="true"><span data-slate-string="true">但是，如果链表很长，遍历代价还是会很高。那我们有没有更好的检索方案呢？你可以回想一下，在上一讲中我们就是用二叉检索树或跳表代替链表，来提高检索效率的。</span></span></span> 
</div> <div class="se-a8ee260d " data-slate-type="paragraph" data-slate-object="block" data-key="932"> 
<span data-slate-object="text" data-key="933"><span data-slate-leaf="true" data-offset-key="933:0" 
data-first-offset="true"><span data-slate-string="true">实际上，在 JDK1.8 之后，Java 中 HashMap 的实现就是在链表到了一定的长度时，将它转为红黑树；而当红黑树中的节点低于一定阈值时，就将它退化为链表。</span></span></span> 
</div> <div class="se-25d936f8" data-slate-type="image" data-slate-object="block" data-key="934"> 
<img class="se-7dc88a06" src="https://static001.geekbang.org/resource/image/8c/f2/8c5c5054e92ec24de3bde1ca15946af2.jpg"> 
</div> <div class="se-19616ce7 se-67e2ff2b" data-slate-type="paragraph" data-slate-object="block" 
data-key="935"> <span data-slate-object="text" data-key="936"><span data-slate-leaf="true" 
data-offset-key="936:0" data-first-offset="true"><span class="se-76c2338e" data-slate-type="secondary" 
data-slate-object="mark"><span data-slate-string="true">链表法：用红黑树来优化长链表</span></span></span></span> 
</div> <div class="se-2148663c " data-slate-type="paragraph" data-slate-object="block" data-key="937"> 
<span data-slate-object="text" data-key="938"><span data-slate-leaf="true" data-offset-key="938:0" 
data-first-offset="true"><span data-slate-string="true">第一个阶段，通过 Hash 函数将要查询的 Key 转为数组下标，去查询对应的位置。这个阶段的查询代价是 
O(1) 级别。</span></span></span> </div> <div class="se-9d8dfd7c " data-slate-type="paragraph" 
data-slate-object="block" data-key="939"> <span data-slate-object="text" data-key="940"><span 
data-slate-leaf="true" data-offset-key="940:0" data-first-offset="true"><span data-slate-string="true">第二阶段，将数组下标所存的链表头或树根取出。如果是链表，就使用遍历的方式查找，这部分查询的时间代价是 
O(n)。由于链表长度是有上限的，因此实际开销并不会很大，可以视为常数级别时间。如果是红黑树，则用二分查找的方式去查询，时间代价是 O(log n)。如果哈希表中冲突的元素不多，那么落入红黑树的数据规模也不会太大，红黑树中的检索代价也可以视为常数级别时间。</span></span></span> 
</div> <h2 class="se-a6ecc7c8" data-slate-type="heading" data-slate-object="block" data-key="941"><span 
data-slate-object="text" data-key="942"><span data-slate-leaf="true" data-offset-key="942:0" 
data-first-offset="true"><span data-slate-string="true">哈希表有什么缺点？</span></span></span></h2> 
<div class="se-315f67d2 " data-slate-type="paragraph" data-slate-object="block" data-key="943"> 
<span data-slate-object="text" data-key="944"><span data-slate-leaf="true" data-offset-key="944:0" 
data-first-offset="true"><span data-slate-string="true">哈希表既有接近 O(1) 的检索效率，又能支持动态数据的场景，看起来非常好，那是不是在任何场景下，我们都可以用它来代替有序数组和二叉检索树呢？答案是否定的。前面我们说了这么多哈希表的优点，下面我们就来讲讲它的缺点。</span></span></span> 
</div> <div class="se-f0f45c38 " data-slate-type="paragraph" data-slate-object="block" data-key="945"> 
<span data-slate-object="text" data-key="946"><span data-slate-leaf="true" data-offset-key="946:0" 
data-first-offset="true"><span data-slate-string="true">首先，哈希表接近 O(1) 的检索效率是有前提条件的，就是哈希表要足够大和有足够的空闲位置，否则就会非常容易发生冲突。我们一般用</span></span></span><span 
data-slate-object="text" data-key="947"><span data-slate-leaf="true" data-offset-key="947:0" 
data-first-offset="true"><span class="se-13489a4f" data-slate-type="bold" data-slate-object="mark"><span 
data-slate-string="true">装载因子（load factor）</span></span></span></span><span data-slate-object="text" 
data-key="948"><span data-slate-leaf="true" data-offset-key="948:0" data-first-offset="true"><span 
data-slate-string="true">来表示哈希表的填充率。装载因子 = 哈希表中元素个数 / 哈希表的长度。</span></span></span> </div> <div 
class="se-198c53bb " data-slate-type="paragraph" data-slate-object="block" data-key="949"> 
<span data-slate-object="text" data-key="950"><span data-slate-leaf="true" data-offset-key="950:0" 
data-first-offset="true"><span data-slate-string="true">如果频繁发生冲突，大部分的数据会被持续地添加到链表或二叉检索树中，检索也会发生在链表或者二叉检索树中，这样检索效率就会退化。因此，为了保证哈希表的检索效率，我们需要预估哈希表中的数据量，提前生成足够大的哈希表。按经验来说，我们一般要预留一半以上的空闲位置，哈希表才会有足够优秀的检索效率。这就让哈希表和有序数组、二叉检索树相比，需要的存储空间更多了。</span></span></span> 
</div> <div class="se-f3039eec " data-slate-type="paragraph" data-slate-object="block" data-key="951"> 
<span data-slate-object="text" data-key="952"><span data-slate-leaf="true" data-offset-key="952:0" 
data-first-offset="true"><span data-slate-string="true">另一方面，尽管哈希表使用 Hash 值直接进行下标访问，带来了 O(1) 
级别的查询能力，但是也失去了“有序存储”这个特点。因此，如果我们的查询场景需要遍历数据，或者需要进行范围查询，那么哈希表本身是没有什么加速办法的。比如说，如果我们在一个很大的哈希表中存储了少数的几个元素，为了知道存储了哪些元素，我们只能从哈希表的第一个位置开始遍历，直到结尾，这样性能并不好。</span></span></span> 
</div> <h2 class="se-144f36bf" data-slate-type="heading" data-slate-object="block" data-key="953"><span 
data-slate-object="text" data-key="954"><span data-slate-leaf="true" data-offset-key="954:0" 
data-first-offset="true"><span data-slate-string="true">重点回顾</span></span></span></h2> <div 
class="se-0120456a " data-slate-type="paragraph" data-slate-object="block" data-key="955"> 
<span data-slate-object="text" data-key="956"><span data-slate-leaf="true" data-offset-key="956:0" 
data-first-offset="true"><span data-slate-string="true">好了，关于哈希检索我们就讲到这里。你会看到，哈希表的本质是一个数组，它通过 
Hash 函数将查询的 Key 转为数组下标，利用数组的随机访问特性，使得我们能在 O(1) 的时间代价内完成检索。</span></span></span> </div> <div 
class="se-aef3afd5 " data-slate-type="paragraph" data-slate-object="block" data-key="957"> 
<span data-slate-object="text" data-key="958"><span data-slate-leaf="true" data-offset-key="958:0" 
data-first-offset="true"><span data-slate-string="true">尽管哈希检索没有使用二分查找，但无论是设计理想的哈希函数，还是保证哈希表有足够的空闲位置，包括解决冲突的“二次探查”和“双散列”方案，本质上都是希望数据插入哈希表的时候，分布能均衡，这样检索才能更高效。从这个角度来看，其实哈希检索提高检索效率的原理，和二叉检索树需要平衡左右子树深度的原理是一样的，也就是说，高效的检索需要均匀划分检索空间。</span></span></span> 
</div> <div class="se-a19f26bd " data-slate-type="paragraph" data-slate-object="block" data-key="959"> 
<span data-slate-object="text" data-key="960"><span data-slate-leaf="true" data-offset-key="960:0" 
data-first-offset="true"><span data-slate-string="true">另一方面，你会看到，复杂的数据结构和检索算法其实都是由最基础的数据结构和算法组成的。比如说 
JDK1.8 中哈希表的实现，就是使用了数组、链表、红黑树这三种数据结构和相应的检索算法。因此，对于这些基础的数据结构，我们需要深刻地理解它们的检索原理和适用场景，这也为我们未来学习更复杂的系统打下了扎实的基础。</span></span></span> 
</div> <h2 class="se-5ffe5b59" data-slate-type="heading" data-slate-object="block" data-key="961"><span 
data-slate-object="text" data-key="962"><span data-slate-leaf="true" data-offset-key="962:0" 
data-first-offset="true"><span data-slate-string="true">课堂讨论</span></span></span></h2> <div 
class="se-9aff1d4f " data-slate-type="paragraph" data-slate-object="block" data-key="963"> 
<span data-slate-object="text" data-key="964"><span data-slate-leaf="true" data-offset-key="964:0" 
data-first-offset="true"><span data-slate-string="true">假设一个哈希表是使用开放寻址法实现的，如果我们需要删除其中一个元素，可以直接删除吗？为什么呢？如果这个哈希表是使用链表法实现的会有不同吗？</span></span></span> 
</div> <div class="se-b07a4640 " data-slate-type="paragraph" data-slate-object="block" data-key="965"> 
<span data-slate-object="text" data-key="966"><span data-slate-leaf="true" data-offset-key="966:0" 
data-first-offset="true"><span data-slate-string="true">欢迎在留言区畅所欲言，说出你的思考过程和最终答案。如果有收获，也欢迎把这篇文章分享给你的朋友。</span></span></span> 
</div> </div>', body_summary='', bundle='book', delta=0, body_format='full_html', langcode='zh-hans', 
revision_id=1153 where entity_id=1153 
 {executed in 1 msec}
2020-11-25 10:29:57.276 INFO  jdbc.sqltiming Line:373 - update node_revision__body set body_value='<div data-slate-editor="true" data-key="844" autocorrect="off" 
spellcheck="false" data-gramm="false" style="outline: none; white-space: pre-wrap; overflow-wrap: 
break-word;"> <div class="se-099f7870 " data-slate-type="paragraph" data-slate-object="block" 
data-key="845"> <span data-slate-object="text" data-key="846"><span data-slate-leaf="true" 
data-offset-key="846:0" data-first-offset="true"><span data-slate-string="true">你好，我是陈东。</span></span></span> 
</div> <div class="se-b55d60e0 " data-slate-type="paragraph" data-slate-object="block" data-key="847"> 
<span data-slate-object="text" data-key="848"><span data-slate-leaf="true" data-offset-key="848:0" 
data-first-offset="true"><span data-slate-string="true">在实际应用中，我们经常会面临需要根据键（Key）来查询数据的问题。比如说，给你一个用户 
ID，要求你查出该用户的具体信息。这样的需求我们应该如何实现呢？你可能会想到，使用有序数组和二叉检索树都可以来实现。具体来说，我们可以将用户 ID 和用户信息作为一个整体的元素，然后以用户 
ID 作为 Key 来排序，存入有序数组或者二叉检索树中，这样我们就能通过二分查找算法快速查询到用户信息了。</span></span></span> </div> <div class="se-25578578 
" data-slate-type="paragraph" data-slate-object="block" data-key="849"> <span data-slate-object="text" 
data-key="850"><span data-slate-leaf="true" data-offset-key="850:0" data-first-offset="true"><span 
data-slate-string="true">但是，不管是有序数组、二叉检索树还是跳表，它们的检索效率都是 O(log n)。那有没有更高效的检索方案呢？也就是说，有没有能实现 
O(1) 级别的查询方案呢？今天，我们就一起来探讨一下这个问题。</span></span></span> </div> <h2 class="se-ca51fd05" data-slate-type="heading" 
data-slate-object="block" data-key="851"><span data-slate-object="text" data-key="852"><span 
data-slate-leaf="true" data-offset-key="852:0" data-first-offset="true"><span data-slate-string="true">使用 
Hash 函数将 Key 转换为数组下标</span></span></span></h2> <div class="se-0f0e9027 " data-slate-type="paragraph" 
data-slate-object="block" data-key="853"> <span data-slate-object="text" data-key="854"><span 
data-slate-leaf="true" data-offset-key="854:0" data-first-offset="true"><span data-slate-string="true">在第 
1 讲中我们说过，数组具有随机访问的特性。那给定一个用户 ID，想要查询对应的用户信息，我们能否利用数组的随机访问特性来实现呢？</span></span></span> </div> 
<div class="se-9a5616ae " data-slate-type="paragraph" data-slate-object="block" data-key="855"> 
<span data-slate-object="text" data-key="856"><span data-slate-leaf="true" data-offset-key="856:0" 
data-first-offset="true"><span data-slate-string="true">我们先来看一个例子。假设系统中的用户 ID 是从 1 开始的整数，并且随着注册数的增加而增加。如果系统中的用户数是有限的，不会大于 
10 万。那么用户的 ID 范围就会被固定在 1 到 10 万之间。在数字范围有限的情况下，我们完全可以申请一个长度为 10 万的数组，然后将用户 ID 作为数组下标，从而实现 O(1) 
级别的查询能力。</span></span></span> </div> <div class="se-5f14673e" data-slate-type="image" data-slate-object="block" 
data-key="857"> <img class="se-84793368" src="https://static001.geekbang.org/resource/image/bb/cf/bb7ac50d85287e55dde85490a02080cf.jpg"> 
</div> <div class="se-3a6fb3dd se-48ecaa69" data-slate-type="paragraph" data-slate-object="block" 
data-key="858"> <span data-slate-object="text" data-key="859"><span data-slate-leaf="true" 
data-offset-key="859:0" data-first-offset="true"><span class="se-76c2338e" data-slate-type="secondary" 
data-slate-object="mark"><span data-slate-string="true">将用户 ID 直接作为下标查询 ，由于数组下标从 0 开始，因此查询时 
ID 要减 1 </span></span></span></span> </div> <div class="se-434b0b90 " data-slate-type="paragraph" 
data-slate-object="block" data-key="860"> <span data-slate-object="text" data-key="861"><span 
data-slate-leaf="true" data-offset-key="861:0" data-first-offset="true"><span data-slate-string="true">注意，刚才我们举的这个例子中有一个假设：用户的 
ID 是一个数字，并且范围有限。符合这种假设的用户 ID 才能作为数组下标，使用数组的随机访问特性，达到 O(1) 时间代价的高效检索能力。那如果用户的 ID 数字范围很大，数组无法申请这么大的空间该怎么办呢？或者，用户的 
ID 不是数字而是字符串，还能作为数组下标吗？</span></span></span> </div> <div class="se-158571cf " data-slate-type="paragraph" 
data-slate-object="block" data-key="862"> <span data-slate-object="text" data-key="863"><span 
data-slate-leaf="true" data-offset-key="863:0" data-first-offset="true"><span data-slate-string="true">我们假设有一个系统使用字符串作为用户 
ID。如果有一个用户的 ID 是“tom”，我们该怎么处理呢？我们能否将它转换为一个数字来表示呢？你可以先想一想解决方案，再和我继续往下分析。</span></span></span> 
</div> <div class="se-cb3afe68 " data-slate-type="paragraph" data-slate-object="block" data-key="864"> 
<span data-slate-object="text" data-key="865"><span data-slate-leaf="true" data-offset-key="865:0" 
data-first-offset="true"><span data-slate-string="true">我们来考虑这样一种方案：字母表是有限的，只有 26 个，我们可以用字母在字母表中的位置顺序作为数值。于是，就有：“t” 
= 20，“o” = 15，“m” = 13。我们可以把这个 ID 看作是 26 进制的数字，那么对于“tom”这个字符串，把它转为对应的数值就是 20 * 26^2 + 15*26 
+ 13 =149123，这是一个小于 26^4 = 456976‬的数。</span></span></span> </div> <div class="se-6e3fcd04 " 
data-slate-type="paragraph" data-slate-object="block" data-key="866"> <span data-slate-object="text" 
data-key="867"><span data-slate-leaf="true" data-offset-key="867:0" data-first-offset="true"><span 
data-slate-string="true">如果所有用户的 ID 都不超过 3 个字符，使用这个方法，我们用一个可以存储 456976‬个元素的数组就可以存储所有用户的信息了。实际上，工业界有许多更复杂的将字符串转为整数的哈希算法，但核心思想都是利用每个字符的编码和位置信息进行计算，这里我就不展开了。</span></span></span> 
</div> <div class="se-35d29c79 " data-slate-type="paragraph" data-slate-object="block" data-key="868"> 
<span data-slate-object="text" data-key="869"><span data-slate-leaf="true" data-offset-key="869:0" 
data-first-offset="true"><span data-slate-string="true">那如果内存空间有限，我们只能开辟一个存储 10000 个元素的数组该怎么办呢？这个时候，我们可以使用“tom”对应的数值 
149123 除以数组长度 10000，得到余数 9123，用这个余数作为数组下标。</span></span></span> </div> <div class="se-6125b677 
" data-slate-type="paragraph" data-slate-object="block" data-key="870"> <span data-slate-object="text" 
data-key="871"><span data-slate-leaf="true" data-offset-key="871:0" data-first-offset="true"><span 
data-slate-string="true">这种将对象转为有限范围的正整数的表示方法，就叫作 </span></span></span><span data-slate-object="text" 
data-key="872"><span data-slate-leaf="true" data-offset-key="872:0" data-first-offset="true"><span 
class="se-4c1bde26" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">Hash</span></span></span></span><span 
data-slate-object="text" data-key="873"><span data-slate-leaf="true" data-offset-key="873:0" 
data-first-offset="true"><span data-slate-string="true">，翻译过来叫</span></span></span><span data-slate-object="text" 
data-key="874"><span data-slate-leaf="true" data-offset-key="874:0" data-first-offset="true"><span 
class="se-5cd56ee9" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">散列</span></span></span></span><span 
data-slate-object="text" data-key="875"><span data-slate-leaf="true" data-offset-key="875:0" 
data-first-offset="true"><span data-slate-string="true">，也可以直接音译为</span></span></span><span 
data-slate-object="text" data-key="876"><span data-slate-leaf="true" data-offset-key="876:0" 
data-first-offset="true"><span class="se-d6b2feee" data-slate-type="bold" data-slate-object="mark"><span 
data-slate-string="true">哈希</span></span></span></span><span data-slate-object="text" data-key="877"><span 
data-slate-leaf="true" data-offset-key="877:0" data-first-offset="true"><span data-slate-string="true">。而我们常说的 
Hash 函数就是指具体转换方法的函数。我们将对象进行 Hash，用得到的 Hash 值作为数组下标，将对应元素存在数组中。这个数组就叫作</span></span></span><span 
data-slate-object="text" data-key="878"><span data-slate-leaf="true" data-offset-key="878:0" 
data-first-offset="true"><span class="se-cc258018" data-slate-type="bold" data-slate-object="mark"><span 
data-slate-string="true">哈希表</span></span></span></span><span data-slate-object="text" data-key="879"><span 
data-slate-leaf="true" data-offset-key="879:0" data-first-offset="true"><span data-slate-string="true">。这样我们就可以利用数组的随机访问特性，达到 
O(1) 级别的查询性能。</span></span></span> </div> <div class="se-aa12f0b2 " data-slate-type="paragraph" 
data-slate-object="block" data-key="880"> <span data-slate-object="text" data-key="881"><span 
data-slate-leaf="true" data-offset-key="881:0" data-first-offset="true"><span data-slate-string="true">说到这里，你可能会有疑问了，Hash 
函数真的这么神奇吗？如果两个对象的哈希值是相同的怎么办？事实上，任何 Hash 函数都有可能造成对象不同，但 Hash 值相同的冲突。而且，数组空间是有限的，只要被 Hash 的元素个数大于数组上限，就一定会产生冲突。</span></span></span> 
</div> <div class="se-2e8c2a77 " data-slate-type="paragraph" data-slate-object="block" data-key="882"> 
<span data-slate-object="text" data-key="883"><span data-slate-leaf="true" data-offset-key="883:0" 
data-first-offset="true"><span data-slate-string="true">对于哈希冲突这个问题，我们有两类解决方案: 一类是构造尽可能理想的 Hash 
函数，使得 Hash 以后得到的数值尽可能平均分布，从而减少冲突发生的概率；另一类是在冲突发生以后，通过“提供冲突解决方案”来完成存储和查找。最常用的两种冲突解决方案是“开放寻址法”和“链表法”。下面，我就来介绍一下这两种方法，并且重点看看它们对检索效率的影响。</span></span></span> 
</div> <h2 class="se-e15cbf1f" data-slate-type="heading" data-slate-object="block" data-key="884"><span 
data-slate-object="text" data-key="885"><span data-slate-leaf="true" data-offset-key="885:0" 
data-first-offset="true"><span data-slate-string="true">如何利用开放寻址法解决 Hash 冲突？</span></span></span></h2> 
<div class="se-e1b07254 " data-slate-type="paragraph" data-slate-object="block" data-key="886"> 
<span data-slate-object="text" data-key="887"><span data-slate-leaf="true" data-offset-key="887:0" 
data-first-offset="true"><span data-slate-string="true">所谓“开放寻址法”，就是在冲突发生以后，最新的元素需要寻找新空闲的数组位置完成插入。那我们该如何寻找新空闲的位置呢？我们可以使用一种叫作“线性探查”（Linear 
Probing）的方案来进行查找。</span></span></span> </div> <div class="se-12311b32 " data-slate-type="paragraph" 
data-slate-object="block" data-key="888"> <span data-slate-object="text" data-key="889"><span 
data-slate-leaf="true" data-offset-key="889:0" data-first-offset="true"><span data-slate-string="true">“线性探查”的插入逻辑很简单：在当前位置发现有冲突以后，就顺序去查看数组的下一个位置，看看是否空闲。如果有空闲，就插入；如果不是空闲，再顺序去看下一个位置，直到找到空闲位置插入为止。</span></span></span> 
</div> <div class="se-bae4427e " data-slate-type="paragraph" data-slate-object="block" data-key="890"> 
<span data-slate-object="text" data-key="891"><span data-slate-leaf="true" data-offset-key="891:0" 
data-first-offset="true"><span data-slate-string="true">查询逻辑也和插入逻辑相似。我们先根据 Hash 值去查找相应数组下标的元素，如果该位置不为空，但是存储元素的 
Key 和查询的 Key 不一致，那就顺序到数组下一个位置去检索，就这样依次比较 Key。如果访问元素的 Key 和查询 Key 相等，我们就在哈希表中找到了对应元素；如果遍历到空闲处，依然没有元素的 
Key 和查询 Key 相等，则说明哈希表中不存在该元素。</span></span></span> </div> <div class="se-3381c07b " data-slate-type="paragraph" 
data-slate-object="block" data-key="892"> <span data-slate-object="text" data-key="893"><span 
data-slate-leaf="true" data-offset-key="893:0" data-first-offset="true"><span data-slate-string="true">为了帮助你更好地理解，我们来看一个例子。</span></span></span> 
</div> <div class="se-a2d6f33f " data-slate-type="paragraph" data-slate-object="block" data-key="894"> 
<span data-slate-object="text" data-key="895"><span data-slate-leaf="true" data-offset-key="895:0" 
data-first-offset="true"><span data-slate-string="true">假设一个哈希表中已经插入了两个 Key，key1 和 key2。其中 
Hash(key1) = 1, Hash(key2) = 2。这时，如果我们要插入一个 Hash 值为 1 的 key3。根据线性探查的插入逻辑，通过 3 步，我们就可以将 key3 
插入到哈希表下标为 3 的位置中。插入的过程如下：</span></span></span> </div> <div class="se-5fd9f687" data-slate-type="image" 
data-slate-object="block" data-key="896"> <img class="se-b257c40c" src="https://static001.geekbang.org/resource/image/8b/d0/8b0de808f6485bde014019e9d158b0d0.jpg"> 
</div> <div class="se-a1d5483f " data-slate-type="paragraph" data-slate-object="block" data-key="897"> 
<span data-slate-object="text" data-key="898"><span data-slate-leaf="true" data-offset-key="898:0" 
data-first-offset="true"><span data-slate-string="true">在查找 key3 的时候，因为 Hash（key3）= 1，我们会从哈希表下标为 
1 的位置开始顺序查找，经过 3 步找到 key3，查询结束。</span></span></span> </div> <div class="se-d9717fab " data-slate-type="paragraph" 
data-slate-object="block" data-key="899"> <span data-slate-object="text" data-key="900"><span 
data-slate-leaf="true" data-offset-key="900:0" data-first-offset="true"><span data-slate-string="true">讲到这里，你可能已经发现了一个问题：当我们插入一个 
Key 时，如果哈希表已经比较满了，这个 Key 就会沿着数组一直顺序遍历，直到遇到空位置才会成功插入。查询的时候也一样。但是，顺序遍历的代价是 O(n)，这样的检索性能很差。</span></span></span> 
</div> <div class="se-fe0f6de4 " data-slate-type="paragraph" data-slate-object="block" data-key="901"> 
<span data-slate-object="text" data-key="902"><span data-slate-leaf="true" data-offset-key="902:0" 
data-first-offset="true"><span data-slate-string="true">更糟糕的是，如果我们在插入 key1 后，先插入 key3 再插入 key2，那 
key3 就会抢占 key2 的位置，影响 key2 的插入和查询效率。</span></span></span><span data-slate-object="text" data-key="903"><span 
data-slate-leaf="true" data-offset-key="903:0" data-first-offset="true"><span class="se-af99cbfd" 
data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">因此，“线性探查”会影响哈希表的整体性能，而不只是 
Hash 值冲突的 Key</span></span></span></span><span data-slate-object="text" data-key="904"><span 
data-slate-leaf="true" data-offset-key="904:0" data-first-offset="true"><span data-slate-string="true">。</span></span></span> 
</div> <div class="se-dabbeb85 " data-slate-type="paragraph" data-slate-object="block" data-key="905"> 
<span data-slate-object="text" data-key="906"><span data-slate-leaf="true" data-offset-key="906:0" 
data-first-offset="true"><span data-slate-string="true">为了解决这个问题，我们可以使用“二次探查”（Quadratic Probing）和“双散列”（Double 
Hash）这两个方法进行优化。下面，我来分别解释一下这两个方法的优化原理。</span></span></span> </div> <div class="se-5f84fef4 " 
data-slate-type="paragraph" data-slate-object="block" data-key="907"> <span data-slate-object="text" 
data-key="908"><span data-slate-leaf="true" data-offset-key="908:0" data-first-offset="true"><span 
data-slate-string="true">二次探查就是将线性探查的步长从 i 改为 i^2：第一次探查，位置为 Hash(key) + 1^2；第二次探查，位置为 Hash(key) 
+2^2；第三次探查，位置为 Hash(key) + 3^2，依此类推。</span></span></span> </div> <div class="se-bafd0009 " 
data-slate-type="paragraph" data-slate-object="block" data-key="909"> <span data-slate-object="text" 
data-key="910"><span data-slate-leaf="true" data-offset-key="910:0" data-first-offset="true"><span 
data-slate-string="true">双散列就是使用多个 Hash 函数来求下标位置，当第一个 Hash 函数求出来的位置冲突时，启用第二个 Hash 函数，算出第二次探查的位置；如果还冲突，则启用第三个 
Hash 函数，算出第三次探查的位置，依此类推。</span></span></span> </div> <div class="se-0e91b4b6 " data-slate-type="paragraph" 
data-slate-object="block" data-key="911"> <span data-slate-object="text" data-key="912"><span 
data-slate-leaf="true" data-offset-key="912:0" data-first-offset="true"><span data-slate-string="true">无论是二次探查还是双散列，核心思路其实都是在发生冲突的情况下，将下个位置尽可能地岔开，让数据尽可能地随机分散存储，来降低对不相干 
Key 的干扰，从而提高整体的检索效率。</span></span></span> </div> <div class="se-53d0ac5c " data-slate-type="paragraph" 
data-slate-object="block" data-key="913"> <span data-slate-object="text" data-key="914"><span 
data-slate-leaf="true" data-offset-key="914:0" data-first-offset="true"><span data-slate-string="true">但是，对于开放寻址法来说，无论使用什么优化方案，随着插入的元素越多、哈希表越满，插入和检索的性能也就下降得越厉害。在极端情况下，当哈希表被写满的时候，为了保证能插入新元素，我们只能重新生成一个更大的哈希表，将旧哈希表中的所有数据重新 
Hash 一次写入新的哈希表，也就是 </span></span></span><span data-slate-object="text" data-key="915"><span 
data-slate-leaf="true" data-offset-key="915:0" data-first-offset="true"><span class="se-61515aec" 
data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">Re-Hash</span></span></span></span><span 
data-slate-object="text" data-key="916"><span data-slate-leaf="true" data-offset-key="916:0" 
data-first-offset="true"><span data-slate-string="true">，这样会造成非常大的额外开销。因此，在数据动态变化的场景下，使用开放寻址法并不是最合适的方案。</span></span></span> 
</div> <h2 class="se-497ed824" data-slate-type="heading" data-slate-object="block" data-key="917"><span 
data-slate-object="text" data-key="918"><span data-slate-leaf="true" data-offset-key="918:0" 
data-first-offset="true"><span data-slate-string="true">如何利用链表法解决 Hash 冲突？</span></span></span></h2> 
<div class="se-81866e45 " data-slate-type="paragraph" data-slate-object="block" data-key="919"> 
<span data-slate-object="text" data-key="920"><span data-slate-leaf="true" data-offset-key="920:0" 
data-first-offset="true"><span data-slate-string="true">相比开放寻址法，还有一种更常见的冲突解决方案，链表法。所谓“链表法”，就是在数组中不存储一个具体元素，而是存储一个链表头。如果一个 
Key 经过 Hash 函数计算，得到了对应的数组下标，那么我们就将它加入该位置所存的链表的尾部。</span></span></span> </div> <div class="se-8dde9a79 
" data-slate-type="paragraph" data-slate-object="block" data-key="921"> <span data-slate-object="text" 
data-key="922"><span data-slate-leaf="true" data-offset-key="922:0" data-first-offset="true"><span 
data-slate-string="true">这样做的好处是，如果 key3 和 key1 发生了冲突，那么 key3 会通过链表的方式链接在 key1 的后面，而不是去占据 key2 
的位置。这样当 key2 插入时，就不会有冲突了。最终效果如下图。</span></span></span> </div> <div class="se-a9c7a690" data-slate-type="image" 
data-slate-object="block" data-key="923"> <img class="se-70c1709b" src="https://static001.geekbang.org/resource/image/b9/07/b91d6e394af24935f67dc21293bc0c07.jpg"> 
</div> <div class="se-1f8f7a69 se-a0e1b836" data-slate-type="paragraph" data-slate-object="block" 
data-key="924"> <span data-slate-object="text" data-key="925"><span data-slate-leaf="true" 
data-offset-key="925:0" data-first-offset="true"><span class="se-76c2338e" data-slate-type="secondary" 
data-slate-object="mark"><span data-slate-string="true">链表法</span></span></span></span> </div> 
<div class="se-774e8d4d " data-slate-type="paragraph" data-slate-object="block" data-key="926"> 
<span data-slate-object="text" data-key="927"><span data-slate-leaf="true" data-offset-key="927:0" 
data-first-offset="true"><span data-slate-string="true">讲到这里，你可能已经发现了，其实链表法就是将我们前面讲过的数组和链表进行结合，既利用了数组的随机访问特性，又利用了链表的动态修改特性，同时提供了快速查询和动态修改的能力。</span></span></span> 
</div> <div class="se-8ffdafe3 " data-slate-type="paragraph" data-slate-object="block" data-key="928"> 
<span data-slate-object="text" data-key="929"><span data-slate-leaf="true" data-offset-key="929:0" 
data-first-offset="true"><span data-slate-string="true">想要查询时，我们会先根据查询 Key 的 Hash 值，去查找相应数组下标的链表。如果链表为空，则表示不存在该元素；如果链表不为空，则遍历链表，直到找到 
Key 相等的对应元素为止。</span></span></span> </div> <div class="se-2439dbc1 " data-slate-type="paragraph" 
data-slate-object="block" data-key="930"> <span data-slate-object="text" data-key="931"><span 
data-slate-leaf="true" data-offset-key="931:0" data-first-offset="true"><span data-slate-string="true">但是，如果链表很长，遍历代价还是会很高。那我们有没有更好的检索方案呢？你可以回想一下，在上一讲中我们就是用二叉检索树或跳表代替链表，来提高检索效率的。</span></span></span> 
</div> <div class="se-a8ee260d " data-slate-type="paragraph" data-slate-object="block" data-key="932"> 
<span data-slate-object="text" data-key="933"><span data-slate-leaf="true" data-offset-key="933:0" 
data-first-offset="true"><span data-slate-string="true">实际上，在 JDK1.8 之后，Java 中 HashMap 的实现就是在链表到了一定的长度时，将它转为红黑树；而当红黑树中的节点低于一定阈值时，就将它退化为链表。</span></span></span> 
</div> <div class="se-25d936f8" data-slate-type="image" data-slate-object="block" data-key="934"> 
<img class="se-7dc88a06" src="https://static001.geekbang.org/resource/image/8c/f2/8c5c5054e92ec24de3bde1ca15946af2.jpg"> 
</div> <div class="se-19616ce7 se-67e2ff2b" data-slate-type="paragraph" data-slate-object="block" 
data-key="935"> <span data-slate-object="text" data-key="936"><span data-slate-leaf="true" 
data-offset-key="936:0" data-first-offset="true"><span class="se-76c2338e" data-slate-type="secondary" 
data-slate-object="mark"><span data-slate-string="true">链表法：用红黑树来优化长链表</span></span></span></span> 
</div> <div class="se-2148663c " data-slate-type="paragraph" data-slate-object="block" data-key="937"> 
<span data-slate-object="text" data-key="938"><span data-slate-leaf="true" data-offset-key="938:0" 
data-first-offset="true"><span data-slate-string="true">第一个阶段，通过 Hash 函数将要查询的 Key 转为数组下标，去查询对应的位置。这个阶段的查询代价是 
O(1) 级别。</span></span></span> </div> <div class="se-9d8dfd7c " data-slate-type="paragraph" 
data-slate-object="block" data-key="939"> <span data-slate-object="text" data-key="940"><span 
data-slate-leaf="true" data-offset-key="940:0" data-first-offset="true"><span data-slate-string="true">第二阶段，将数组下标所存的链表头或树根取出。如果是链表，就使用遍历的方式查找，这部分查询的时间代价是 
O(n)。由于链表长度是有上限的，因此实际开销并不会很大，可以视为常数级别时间。如果是红黑树，则用二分查找的方式去查询，时间代价是 O(log n)。如果哈希表中冲突的元素不多，那么落入红黑树的数据规模也不会太大，红黑树中的检索代价也可以视为常数级别时间。</span></span></span> 
</div> <h2 class="se-a6ecc7c8" data-slate-type="heading" data-slate-object="block" data-key="941"><span 
data-slate-object="text" data-key="942"><span data-slate-leaf="true" data-offset-key="942:0" 
data-first-offset="true"><span data-slate-string="true">哈希表有什么缺点？</span></span></span></h2> 
<div class="se-315f67d2 " data-slate-type="paragraph" data-slate-object="block" data-key="943"> 
<span data-slate-object="text" data-key="944"><span data-slate-leaf="true" data-offset-key="944:0" 
data-first-offset="true"><span data-slate-string="true">哈希表既有接近 O(1) 的检索效率，又能支持动态数据的场景，看起来非常好，那是不是在任何场景下，我们都可以用它来代替有序数组和二叉检索树呢？答案是否定的。前面我们说了这么多哈希表的优点，下面我们就来讲讲它的缺点。</span></span></span> 
</div> <div class="se-f0f45c38 " data-slate-type="paragraph" data-slate-object="block" data-key="945"> 
<span data-slate-object="text" data-key="946"><span data-slate-leaf="true" data-offset-key="946:0" 
data-first-offset="true"><span data-slate-string="true">首先，哈希表接近 O(1) 的检索效率是有前提条件的，就是哈希表要足够大和有足够的空闲位置，否则就会非常容易发生冲突。我们一般用</span></span></span><span 
data-slate-object="text" data-key="947"><span data-slate-leaf="true" data-offset-key="947:0" 
data-first-offset="true"><span class="se-13489a4f" data-slate-type="bold" data-slate-object="mark"><span 
data-slate-string="true">装载因子（load factor）</span></span></span></span><span data-slate-object="text" 
data-key="948"><span data-slate-leaf="true" data-offset-key="948:0" data-first-offset="true"><span 
data-slate-string="true">来表示哈希表的填充率。装载因子 = 哈希表中元素个数 / 哈希表的长度。</span></span></span> </div> <div 
class="se-198c53bb " data-slate-type="paragraph" data-slate-object="block" data-key="949"> 
<span data-slate-object="text" data-key="950"><span data-slate-leaf="true" data-offset-key="950:0" 
data-first-offset="true"><span data-slate-string="true">如果频繁发生冲突，大部分的数据会被持续地添加到链表或二叉检索树中，检索也会发生在链表或者二叉检索树中，这样检索效率就会退化。因此，为了保证哈希表的检索效率，我们需要预估哈希表中的数据量，提前生成足够大的哈希表。按经验来说，我们一般要预留一半以上的空闲位置，哈希表才会有足够优秀的检索效率。这就让哈希表和有序数组、二叉检索树相比，需要的存储空间更多了。</span></span></span> 
</div> <div class="se-f3039eec " data-slate-type="paragraph" data-slate-object="block" data-key="951"> 
<span data-slate-object="text" data-key="952"><span data-slate-leaf="true" data-offset-key="952:0" 
data-first-offset="true"><span data-slate-string="true">另一方面，尽管哈希表使用 Hash 值直接进行下标访问，带来了 O(1) 
级别的查询能力，但是也失去了“有序存储”这个特点。因此，如果我们的查询场景需要遍历数据，或者需要进行范围查询，那么哈希表本身是没有什么加速办法的。比如说，如果我们在一个很大的哈希表中存储了少数的几个元素，为了知道存储了哪些元素，我们只能从哈希表的第一个位置开始遍历，直到结尾，这样性能并不好。</span></span></span> 
</div> <h2 class="se-144f36bf" data-slate-type="heading" data-slate-object="block" data-key="953"><span 
data-slate-object="text" data-key="954"><span data-slate-leaf="true" data-offset-key="954:0" 
data-first-offset="true"><span data-slate-string="true">重点回顾</span></span></span></h2> <div 
class="se-0120456a " data-slate-type="paragraph" data-slate-object="block" data-key="955"> 
<span data-slate-object="text" data-key="956"><span data-slate-leaf="true" data-offset-key="956:0" 
data-first-offset="true"><span data-slate-string="true">好了，关于哈希检索我们就讲到这里。你会看到，哈希表的本质是一个数组，它通过 
Hash 函数将查询的 Key 转为数组下标，利用数组的随机访问特性，使得我们能在 O(1) 的时间代价内完成检索。</span></span></span> </div> <div 
class="se-aef3afd5 " data-slate-type="paragraph" data-slate-object="block" data-key="957"> 
<span data-slate-object="text" data-key="958"><span data-slate-leaf="true" data-offset-key="958:0" 
data-first-offset="true"><span data-slate-string="true">尽管哈希检索没有使用二分查找，但无论是设计理想的哈希函数，还是保证哈希表有足够的空闲位置，包括解决冲突的“二次探查”和“双散列”方案，本质上都是希望数据插入哈希表的时候，分布能均衡，这样检索才能更高效。从这个角度来看，其实哈希检索提高检索效率的原理，和二叉检索树需要平衡左右子树深度的原理是一样的，也就是说，高效的检索需要均匀划分检索空间。</span></span></span> 
</div> <div class="se-a19f26bd " data-slate-type="paragraph" data-slate-object="block" data-key="959"> 
<span data-slate-object="text" data-key="960"><span data-slate-leaf="true" data-offset-key="960:0" 
data-first-offset="true"><span data-slate-string="true">另一方面，你会看到，复杂的数据结构和检索算法其实都是由最基础的数据结构和算法组成的。比如说 
JDK1.8 中哈希表的实现，就是使用了数组、链表、红黑树这三种数据结构和相应的检索算法。因此，对于这些基础的数据结构，我们需要深刻地理解它们的检索原理和适用场景，这也为我们未来学习更复杂的系统打下了扎实的基础。</span></span></span> 
</div> <h2 class="se-5ffe5b59" data-slate-type="heading" data-slate-object="block" data-key="961"><span 
data-slate-object="text" data-key="962"><span data-slate-leaf="true" data-offset-key="962:0" 
data-first-offset="true"><span data-slate-string="true">课堂讨论</span></span></span></h2> <div 
class="se-9aff1d4f " data-slate-type="paragraph" data-slate-object="block" data-key="963"> 
<span data-slate-object="text" data-key="964"><span data-slate-leaf="true" data-offset-key="964:0" 
data-first-offset="true"><span data-slate-string="true">假设一个哈希表是使用开放寻址法实现的，如果我们需要删除其中一个元素，可以直接删除吗？为什么呢？如果这个哈希表是使用链表法实现的会有不同吗？</span></span></span> 
</div> <div class="se-b07a4640 " data-slate-type="paragraph" data-slate-object="block" data-key="965"> 
<span data-slate-object="text" data-key="966"><span data-slate-leaf="true" data-offset-key="966:0" 
data-first-offset="true"><span data-slate-string="true">欢迎在留言区畅所欲言，说出你的思考过程和最终答案。如果有收获，也欢迎把这篇文章分享给你的朋友。</span></span></span> 
</div> </div>', body_summary='', bundle='book', delta=0, body_format='full_html', langcode='zh-hans', 
revision_id=1153 where entity_id=1153 
 {executed in 1 msec}
2020-11-25 10:29:57.283 INFO  jdbc.sqltiming Line:373 - select nodefiledd0_.nid as nid1_10_, nodefiledd0_.changed as changed2_10_, nodefiledd0_.created 
as created3_10_, nodefiledd0_.default_langcode as default_4_10_, nodefiledd0_.langcode as langcode5_10_, 
nodefiledd0_.promote as promote6_10_, nodefiledd0_.revision_translation_affected as revision7_10_, 
nodefiledd0_.status as status8_10_, nodefiledd0_.sticky as sticky9_10_, nodefiledd0_.title 
as title10_10_, nodefiledd0_.type as type11_10_, nodefiledd0_.uid as uid12_10_, nodefiledd0_.vid 
as vid13_10_ from node_field_data nodefiledd0_ where nodefiledd0_.nid=1153 
 {executed in 1 msec}
2020-11-25 10:29:57.283 INFO  jdbc.resultsettable Line:610 - 
|-----|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|--------------------------|-----|----|-----|
|nid  |changed    |created    |default_langcode |langcode |promote |revision_translation_affected |status |sticky |title                     |type |uid |vid  |
|-----|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|--------------------------|-----|----|-----|
|1153 |1606115346 |1606115346 |1                |zh-hans  |0       |1                             |1      |0      |03丨哈希检索：如何根据用户ID快速查询用户信息？ |book |1   |1153 |
|-----|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|--------------------------|-----|----|-----|

2020-11-25 10:29:57.284 INFO  jdbc.sqltiming Line:373 - select nodefieldr0_.nid as nid1_11_0_, nodefieldr0_.changed as changed2_11_0_, nodefieldr0_.created 
as created3_11_0_, nodefieldr0_.default_langcode as default_4_11_0_, nodefieldr0_.langcode 
as langcode5_11_0_, nodefieldr0_.promote as promote6_11_0_, nodefieldr0_.revision_translation_affected 
as revision7_11_0_, nodefieldr0_.status as status8_11_0_, nodefieldr0_.sticky as sticky9_11_0_, 
nodefieldr0_.title as title10_11_0_, nodefieldr0_.uid as uid11_11_0_, nodefieldr0_.vid as vid12_11_0_ 
from node_field_revision nodefieldr0_ where nodefieldr0_.nid=1153 
 {executed in 0 msec}
2020-11-25 10:29:57.285 INFO  jdbc.resultsettable Line:610 - 
|---------|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|--------------------------|----|-----|
|nid      |changed    |created    |default_langcode |langcode |promote |revision_translation_affected |status |sticky |title                     |uid |vid  |
|---------|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|--------------------------|----|-----|
|[unread] |1606115346 |1606115346 |1                |zh-hans  |0       |1                             |1      |0      |03丨哈希检索：如何根据用户ID快速查询用户信息？ |1   |1153 |
|---------|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|--------------------------|----|-----|

2020-11-25 10:29:57.287 INFO  jdbc.sqltiming Line:373 - update node_field_data set changed=1606271397, created=1606271397, default_langcode=1, langcode='zh-hans', 
promote=0, revision_translation_affected=1, status=1, sticky=0, title='03丨哈希检索：如何根据用户ID快速查询用户信息？', 
type='book', uid=1, vid=1153 where nid=1153 
 {executed in 0 msec}
2020-11-25 10:29:57.288 INFO  jdbc.sqltiming Line:373 - update node_field_revision set changed=1606271397, created=1606271397, default_langcode=1, 
langcode='zh-hans', promote=0, revision_translation_affected=1, status=1, sticky=0, title='03丨哈希检索：如何根据用户ID快速查询用户信息？', 
uid=1, vid=1153 where nid=1153 
 {executed in 0 msec}
2020-11-25 10:29:57.293 INFO  jdbc.sqltiming Line:373 - select bookfieldm0_.entity_id as entity_i1_8_, bookfieldm0_.bundle as bundle2_8_, bookfieldm0_.delta 
as delta3_8_, bookfieldm0_.langcode as langcode4_8_, bookfieldm0_.field_media_value as field_me5_8_, 
bookfieldm0_.revision_id as revision6_8_ from node__field_media bookfieldm0_ where bookfieldm0_.entity_id=1153 
 {executed in 0 msec}
2020-11-25 10:29:57.293 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------------|------------|
|entity_id |bundle |delta |langcode |field_media_value |revision_id |
|----------|-------|------|---------|------------------|------------|
|1153      |book   |0     |zh-hans  |                  |1153        |
|----------|-------|------|---------|------------------|------------|

2020-11-25 10:29:57.296 INFO  jdbc.sqltiming Line:373 - select nodefieldm0_.entity_id as entity_i1_17_0_, nodefieldm0_.bundle as bundle2_17_0_, nodefieldm0_.delta 
as delta3_17_0_, nodefieldm0_.langcode as langcode4_17_0_, nodefieldm0_.field_media_value as 
field_me5_17_0_, nodefieldm0_.revision_id as revision6_17_0_ from node_revision__field_media 
nodefieldm0_ where nodefieldm0_.entity_id=1153 
 {executed in 0 msec}
2020-11-25 10:29:57.297 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------------|------------|
|entity_id |bundle |delta |langcode |field_media_value |revision_id |
|----------|-------|------|---------|------------------|------------|
|[unread]  |book   |0     |zh-hans  |                  |1153        |
|----------|-------|------|---------|------------------|------------|

2020-11-25 10:29:57.300 INFO  jdbc.sqltiming Line:373 - select bookfieldc0_.entity_id as entity_i1_5_, bookfieldc0_.bundle as bundle2_5_, bookfieldc0_.field_comment_value 
as field_co3_5_, bookfieldc0_.delta as delta4_5_, bookfieldc0_.field_comment_format as field_co5_5_, 
bookfieldc0_.langcode as langcode6_5_, bookfieldc0_.revision_id as revision7_5_ from node__field_comment 
bookfieldc0_ where bookfieldc0_.entity_id=1153 
 {executed in 0 msec}
2020-11-25 10:29:57.300 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|--------------------|------|---------------------|---------|------------|
|entity_id |bundle |field_comment_value |delta |field_comment_format |langcode |revision_id |
|----------|-------|--------------------|------|---------------------|---------|------------|
|1153      |book   |                    |0     |full_html            |zh-hans  |1153        |
|----------|-------|--------------------|------|---------------------|---------|------------|

2020-11-25 10:29:57.303 INFO  jdbc.sqltiming Line:373 - update node__field_comment set bundle='book', field_comment_value='<li class="reJj6Thl_0"><img 
src="https://static001.geekbang.org/account/avatar/00/14/0f/53/92a50f01.jpg" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <a>徐洲更</a> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-28 </div> </div> <!----> </div> <div> <div 
class="_3M6kV3zb_0"> 我这几天刚好看过一个C语言的哈希表实现源代码khash.h，它用的就是open addressing方法。 在删除元素的时候 不会真正的删除，会有一个flag记录状态。后续插入新的元素还能用。否则就会导致每次就要重新申请内存，rehash，计算量太大。链表法的话，删除的是对应的node 
，时间复杂度是O(1) 所以删除很快 </div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> 
</div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 是的。这种加一个flag记录状态的设计，其实在许多算法和系统中都有出现。是我们可以学习和掌握的一种方法。</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span>1</span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">2</span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Xeo83bVRZgql985iaPL7vaXQoN6VdBgbS0VYRgu69d5MdfLM4lpp5GXTNMSnnNEuvdYhBdib5KrnicmdrbDoicnBtQ/132" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>pedro</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-27 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0"> 今天的内容权当回顾吧，期待后续的干货。 </div> <div class="_2r3UB1GX_0"> <span>展开</span><i 
class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 对于有基础和经验的工程师，可以当做回顾。同时也思考一下工业界的实际实现方案。<br>在后面，我准备写几篇加餐，补充更多的实践工程内容。让有经验的工程师更有收获。</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span>1</span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">2</span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/10/1d/13/31ea1b0b.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>峰</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-27 </div> </div> <!----> </div> <div> 
<div class="_3M6kV3zb_0"> 不能，这样不能和数据不存在的情况区分，链表法就可以了，核心考量是冲突元素是否是聚集的。 <br>hash 表中的hash 是一个将key 
转化成数组下标的映射关系，我们这里只讲到这个转化尽可能的均匀的散列，但如果加上尽可能保留原始key 空间的距离大小信息(以前我学降维得出的结论是数据降维要做的事情是把你想从高维空间保留的信息尽可能在数据的低维表示上同样成立)，是否就可以在一定程度上解决hash 
完全没法做范围查询的缺陷，好早之前看过点局部敏感hash 的一些东东，想来应该可以结合。 </div> <div class="_2r3UB1GX_0"> <span>展开</span><i 
class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 是的。直接删除会有问题。探查链条会被终止。<br>局部敏感哈希能在距离信息进行一定的保留，因此在近似检索中是一个方案。在进阶篇我会介绍。</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">2</span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/0f/54/9a/76c0af70.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>每天晒白牙</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-28 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0"> 链表法可以直接删除，开放寻址法不行。 <br>开放寻址法在 hash 冲突后会继续往后面看，如果为空，就放到后面，这样会存在连续的几个值的 
hash 值都相同的情况，但如果想删除的数据在中间的话，就会影响对后面数据的查询了 <br>可以增加一个删除标识，这种添加删除标识的在数据库中也常用 </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 
没错！这种增加一个删除标识的做法，其实在许多算法和系统的设计中都有出现。也是一种常见的设计思路。</p> </div> <div class="_1w8H0ktn_0 _2A421P4G_0"> 
<div class="_2jsFl-X0_0"> <i class="iconfont"></i> <span></span> </div> <div class="_2P4B1Hdm_0"> 
<i class="iconfont"></i> <span class="">1</span> </div> <!----> </div> </div> </div></li> 
<li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>一步</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-27 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0"> 通过开放寻址法是不可以简单的删除元素的，如果要删除的元素是通过寻址法找的存储下标，那么该元素所在的下标不是本身 hash 
后的位置 <br> <br>链表法是可以的：因为元素本身的 hash 值和存储位置的下标 值是一致的 <br> <br> </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 
哈希表在查找元素的时候，不是只看下标的，还要对比下标位置的元素值，相同才算找到。这也是为什么会有线性探查等方法。<br>不能直接删除的问题在于，直接删除会把探查序列中断。举个例子:有三个元素a，b，c的hash值是冲突的，那么探查序列会把他们放在三个位置上，比如1，2，3（探查序列是123），如果我们把b删了，那么2这个位置就空了。这时候，要查询c，探查序列就会在2的位置中断，查不到c。</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/18/7b/74/9b88e040.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>柏油</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-27 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0"> 开放寻址法从理论上讲应该也是可以删除的，不过稍微麻烦些，需要保证同一hash值删除的key前后元素串联性，以保证此hash值在删除当前key之后的元素能被寻址到，可以用特殊值代替，但是在检索时可能会遍历这些特殊值 
效率上更低；而链表法则可以很好的支持删除 </div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> 
</div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 很正确。直接删除会打断探查序列。因此，需要加入特殊标志，表示这是被删除的。</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/14/1c/71/2f52da16.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>努力努力再努力Xmn</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-29 </div> </div> <!----> 
</div> <div> <div class="_3M6kV3zb_0"> 开放寻址法的话应该是不可以的，因为一旦删除的话就会改变哈希表的长度，那样的话所有的元素的位置都会发生改变，不过删除的时候可以把这个位置赋予某个特定的值，用以表示此位置为空。 
<br>对于链表法的话就不存在上述问题了，就和链表中删除某一个元素一样了。 </div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> 
</div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 结论是正确的。不过删除元素并不会改变哈希表的长度。哈希表的长度是固定的。<br>不能直接删除的问题在于，直接删除会把探查序列中断。举个例子:有三个元素a，b，c的hash值是冲突的，那么探查序列会把他们放在三个位置上，比如1，2，3（探查序列是123），如果我们把b删了，那么2这个位置就空了。这时候，要查询c，探查序列就会在2的位置中断，查不到c。</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/16/d0/73/06ed7823.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>Z_CHP</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-29 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0"> 期待后续的干货 </div> <div class="_2r3UB1GX_0"> <span>展开</span><i 
class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 对于有经验的工程师而言，基础篇可以当做是梳理自己的知识点，并做总结和深入思考。比如说，哈希表结合遍历需求，是一个怎么样的数据结构?在实际场景中能怎么使用?（比如缓存）<br>此外，我会提供基础篇的加餐，你会发现，原来工业界的许多高效实现，都是基于基础篇中的知识完成的。</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>一步</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-27 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0"> 哈希表的本质是一个数组，它通过 Hash 函数将查询的 Key 转为数组下标 <br>---------------------------- 
<br>这里有个以为 通过Hash 函数计算的结果一定是一个正整数吗？ 还是说可以通过不同的进制，当做正整数 </div> <div class="_2r3UB1GX_0"> <span>展开</span><i 
class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 本质是要把key作为数组下标。而数组下标是正整数。<br>只要能满足这个目的就好。</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/12/9b/6e/edd2da0c.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>蓝魔丶</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-27 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 老师，如果开放寻址法是采用的二次探查或者双重散列解决冲突，可以直接删除嘛？ </div> <!----> 
<div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 即使是这样，也是会出问题的。直接删除会把探查序列中断。<br>举个例子:有三个元素a，b，c的hash值是冲突的，那么探查序列会把他们放在三个位置上，比如1，2，3（探查序列是123），如果我们把b删了，那么2这个位置就空了。这时候，要查询c，探查序列就会在2的位置中断，查不到c。<br>因此，真有删除需求的话，我们会通过将删除的元素做一个标志区别，而不是真正删除，这样就能保留探查序列了。</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span>1</span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/10/5f/e5/54325854.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>范闲</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-27 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0"> 链表法可以删除，因为key对应的hash都映射到一个节点，所有的值都存在链表上。 <br>开放寻址不可以，无法判断key的hash被映射到哪里。 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 结论是正确的。不过理由还不够充分。开放寻址是可以通过线性探查等方式确认映射位置的。问题在于，直接删除会把探查序列中断。举个例子:有三个元素a，b，c的hash值是冲突的，那么探查序列会把他们放在三个位置上，比如1，2，3（探查序列是123），如果我们把b删了，那么2这个位置就空了。这时候，要查询c，探查序列就会在2的位置中断，查不到c。</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLEGtB7lUzH66b3nibVu3Xat4C0Wfp0umU3slsN32TF3icBwDOpShgdzMhaLW9z5LDFg3TTh0H62qAA/132" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>千里之行</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-27 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> Hash表使用开放寻址法的时候，不能直接删除数据。直接删除的话可能形成查询无结果的假象，出现漏查的情况，链表法就不存在这个问题，但应该注意容错，可能会造成空值报错 
</div> <!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 是的。很细心。直接删除会造成探查链条被中断，导致本来后面可以查到的，但由于被中断返回了无结果。一般来说，会加一个状态位区分，而不是真正删除。</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/14/9b/d0/86aee34c.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>刘凯</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-27 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0"> 老师，后边的课程全是理论吗，有没有讲讲实现某种查询的方案加工具啊，必竞学课的不完全是研究算法的。肯定也有像我这样用于应用的， 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 基础篇主要是介绍一些检索相关的重要数据结构和算法。不过这部分内容和课本上相比，会融入更多工业界的例子。<br>而在后面进阶篇的课程，重点会介绍各种业务中的查询解决方案了。</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/14/9b/d0/86aee34c.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>刘凯</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-27 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0"> 不太理解算法，但感觉在有序的问题上，插入不是其优点，那么感觉删除也不是优点。链表在插上就改变个指针，那么删除肯定也没任何问题。 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 你的直觉很好。结论是正确的。不过理由不够充分哦。你可以再想想，包括好好看看前面两课。<br>其实对于工程师而言，基础还是很重要的。否则，如果使用ES或Lucene，但是不清楚支持它的技术，那么想优化可能都无从下手。</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> 
</div> <!----> </div> </div> </div></li>', delta=0, field_comment_format='full_html', langcode='zh-hans', 
revision_id=1153 where entity_id=1153 
 {executed in 1 msec}
2020-11-25 10:29:57.307 INFO  jdbc.sqltiming Line:373 - select nodefieldc0_.entity_id as entity_i1_14_0_, nodefieldc0_.bundle as bundle2_14_0_, nodefieldc0_.field_comment_value 
as field_co3_14_0_, nodefieldc0_.delta as delta4_14_0_, nodefieldc0_.field_comment_format as 
field_co5_14_0_, nodefieldc0_.langcode as langcode6_14_0_, nodefieldc0_.revision_id as revision7_14_0_ 
from node_revision__field_comment nodefieldc0_ where nodefieldc0_.entity_id=1153 
 {executed in 0 msec}
2020-11-25 10:29:57.308 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|--------------------|------|---------------------|---------|------------|
|entity_id |bundle |field_comment_value |delta |field_comment_format |langcode |revision_id |
|----------|-------|--------------------|------|---------------------|---------|------------|
|[unread]  |book   |                    |0     |full_html            |zh-hans  |1153        |
|----------|-------|--------------------|------|---------------------|---------|------------|

2020-11-25 10:29:57.309 INFO  jdbc.sqltiming Line:373 - update node_revision__field_comment set bundle='book', field_comment_value='<li class="reJj6Thl_0"><img 
src="https://static001.geekbang.org/account/avatar/00/14/0f/53/92a50f01.jpg" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <a>徐洲更</a> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-28 </div> </div> <!----> </div> <div> <div 
class="_3M6kV3zb_0"> 我这几天刚好看过一个C语言的哈希表实现源代码khash.h，它用的就是open addressing方法。 在删除元素的时候 不会真正的删除，会有一个flag记录状态。后续插入新的元素还能用。否则就会导致每次就要重新申请内存，rehash，计算量太大。链表法的话，删除的是对应的node 
，时间复杂度是O(1) 所以删除很快 </div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> 
</div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 是的。这种加一个flag记录状态的设计，其实在许多算法和系统中都有出现。是我们可以学习和掌握的一种方法。</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span>1</span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">2</span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Xeo83bVRZgql985iaPL7vaXQoN6VdBgbS0VYRgu69d5MdfLM4lpp5GXTNMSnnNEuvdYhBdib5KrnicmdrbDoicnBtQ/132" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>pedro</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-27 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0"> 今天的内容权当回顾吧，期待后续的干货。 </div> <div class="_2r3UB1GX_0"> <span>展开</span><i 
class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 对于有基础和经验的工程师，可以当做回顾。同时也思考一下工业界的实际实现方案。<br>在后面，我准备写几篇加餐，补充更多的实践工程内容。让有经验的工程师更有收获。</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span>1</span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">2</span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/10/1d/13/31ea1b0b.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>峰</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-27 </div> </div> <!----> </div> <div> 
<div class="_3M6kV3zb_0"> 不能，这样不能和数据不存在的情况区分，链表法就可以了，核心考量是冲突元素是否是聚集的。 <br>hash 表中的hash 是一个将key 
转化成数组下标的映射关系，我们这里只讲到这个转化尽可能的均匀的散列，但如果加上尽可能保留原始key 空间的距离大小信息(以前我学降维得出的结论是数据降维要做的事情是把你想从高维空间保留的信息尽可能在数据的低维表示上同样成立)，是否就可以在一定程度上解决hash 
完全没法做范围查询的缺陷，好早之前看过点局部敏感hash 的一些东东，想来应该可以结合。 </div> <div class="_2r3UB1GX_0"> <span>展开</span><i 
class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 是的。直接删除会有问题。探查链条会被终止。<br>局部敏感哈希能在距离信息进行一定的保留，因此在近似检索中是一个方案。在进阶篇我会介绍。</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">2</span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/0f/54/9a/76c0af70.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>每天晒白牙</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-28 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0"> 链表法可以直接删除，开放寻址法不行。 <br>开放寻址法在 hash 冲突后会继续往后面看，如果为空，就放到后面，这样会存在连续的几个值的 
hash 值都相同的情况，但如果想删除的数据在中间的话，就会影响对后面数据的查询了 <br>可以增加一个删除标识，这种添加删除标识的在数据库中也常用 </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 
没错！这种增加一个删除标识的做法，其实在许多算法和系统的设计中都有出现。也是一种常见的设计思路。</p> </div> <div class="_1w8H0ktn_0 _2A421P4G_0"> 
<div class="_2jsFl-X0_0"> <i class="iconfont"></i> <span></span> </div> <div class="_2P4B1Hdm_0"> 
<i class="iconfont"></i> <span class="">1</span> </div> <!----> </div> </div> </div></li> 
<li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>一步</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-27 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0"> 通过开放寻址法是不可以简单的删除元素的，如果要删除的元素是通过寻址法找的存储下标，那么该元素所在的下标不是本身 hash 
后的位置 <br> <br>链表法是可以的：因为元素本身的 hash 值和存储位置的下标 值是一致的 <br> <br> </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 
哈希表在查找元素的时候，不是只看下标的，还要对比下标位置的元素值，相同才算找到。这也是为什么会有线性探查等方法。<br>不能直接删除的问题在于，直接删除会把探查序列中断。举个例子:有三个元素a，b，c的hash值是冲突的，那么探查序列会把他们放在三个位置上，比如1，2，3（探查序列是123），如果我们把b删了，那么2这个位置就空了。这时候，要查询c，探查序列就会在2的位置中断，查不到c。</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/18/7b/74/9b88e040.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>柏油</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-27 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0"> 开放寻址法从理论上讲应该也是可以删除的，不过稍微麻烦些，需要保证同一hash值删除的key前后元素串联性，以保证此hash值在删除当前key之后的元素能被寻址到，可以用特殊值代替，但是在检索时可能会遍历这些特殊值 
效率上更低；而链表法则可以很好的支持删除 </div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> 
</div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 很正确。直接删除会打断探查序列。因此，需要加入特殊标志，表示这是被删除的。</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/14/1c/71/2f52da16.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>努力努力再努力Xmn</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-29 </div> </div> <!----> 
</div> <div> <div class="_3M6kV3zb_0"> 开放寻址法的话应该是不可以的，因为一旦删除的话就会改变哈希表的长度，那样的话所有的元素的位置都会发生改变，不过删除的时候可以把这个位置赋予某个特定的值，用以表示此位置为空。 
<br>对于链表法的话就不存在上述问题了，就和链表中删除某一个元素一样了。 </div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> 
</div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 结论是正确的。不过删除元素并不会改变哈希表的长度。哈希表的长度是固定的。<br>不能直接删除的问题在于，直接删除会把探查序列中断。举个例子:有三个元素a，b，c的hash值是冲突的，那么探查序列会把他们放在三个位置上，比如1，2，3（探查序列是123），如果我们把b删了，那么2这个位置就空了。这时候，要查询c，探查序列就会在2的位置中断，查不到c。</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/16/d0/73/06ed7823.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>Z_CHP</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-29 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0"> 期待后续的干货 </div> <div class="_2r3UB1GX_0"> <span>展开</span><i 
class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 对于有经验的工程师而言，基础篇可以当做是梳理自己的知识点，并做总结和深入思考。比如说，哈希表结合遍历需求，是一个怎么样的数据结构?在实际场景中能怎么使用?（比如缓存）<br>此外，我会提供基础篇的加餐，你会发现，原来工业界的许多高效实现，都是基于基础篇中的知识完成的。</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>一步</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-27 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0"> 哈希表的本质是一个数组，它通过 Hash 函数将查询的 Key 转为数组下标 <br>---------------------------- 
<br>这里有个以为 通过Hash 函数计算的结果一定是一个正整数吗？ 还是说可以通过不同的进制，当做正整数 </div> <div class="_2r3UB1GX_0"> <span>展开</span><i 
class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 本质是要把key作为数组下标。而数组下标是正整数。<br>只要能满足这个目的就好。</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/12/9b/6e/edd2da0c.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>蓝魔丶</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-27 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 老师，如果开放寻址法是采用的二次探查或者双重散列解决冲突，可以直接删除嘛？ </div> <!----> 
<div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 即使是这样，也是会出问题的。直接删除会把探查序列中断。<br>举个例子:有三个元素a，b，c的hash值是冲突的，那么探查序列会把他们放在三个位置上，比如1，2，3（探查序列是123），如果我们把b删了，那么2这个位置就空了。这时候，要查询c，探查序列就会在2的位置中断，查不到c。<br>因此，真有删除需求的话，我们会通过将删除的元素做一个标志区别，而不是真正删除，这样就能保留探查序列了。</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span>1</span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/10/5f/e5/54325854.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>范闲</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-27 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0"> 链表法可以删除，因为key对应的hash都映射到一个节点，所有的值都存在链表上。 <br>开放寻址不可以，无法判断key的hash被映射到哪里。 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 结论是正确的。不过理由还不够充分。开放寻址是可以通过线性探查等方式确认映射位置的。问题在于，直接删除会把探查序列中断。举个例子:有三个元素a，b，c的hash值是冲突的，那么探查序列会把他们放在三个位置上，比如1，2，3（探查序列是123），如果我们把b删了，那么2这个位置就空了。这时候，要查询c，探查序列就会在2的位置中断，查不到c。</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLEGtB7lUzH66b3nibVu3Xat4C0Wfp0umU3slsN32TF3icBwDOpShgdzMhaLW9z5LDFg3TTh0H62qAA/132" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>千里之行</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-27 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> Hash表使用开放寻址法的时候，不能直接删除数据。直接删除的话可能形成查询无结果的假象，出现漏查的情况，链表法就不存在这个问题，但应该注意容错，可能会造成空值报错 
</div> <!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 是的。很细心。直接删除会造成探查链条被中断，导致本来后面可以查到的，但由于被中断返回了无结果。一般来说，会加一个状态位区分，而不是真正删除。</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/14/9b/d0/86aee34c.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>刘凯</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-27 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0"> 老师，后边的课程全是理论吗，有没有讲讲实现某种查询的方案加工具啊，必竞学课的不完全是研究算法的。肯定也有像我这样用于应用的， 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 基础篇主要是介绍一些检索相关的重要数据结构和算法。不过这部分内容和课本上相比，会融入更多工业界的例子。<br>而在后面进阶篇的课程，重点会介绍各种业务中的查询解决方案了。</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/14/9b/d0/86aee34c.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>刘凯</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-27 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0"> 不太理解算法，但感觉在有序的问题上，插入不是其优点，那么感觉删除也不是优点。链表在插上就改变个指针，那么删除肯定也没任何问题。 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 你的直觉很好。结论是正确的。不过理由不够充分哦。你可以再想想，包括好好看看前面两课。<br>其实对于工程师而言，基础还是很重要的。否则，如果使用ES或Lucene，但是不清楚支持它的技术，那么想优化可能都无从下手。</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> 
</div> <!----> </div> </div> </div></li>', delta=0, field_comment_format='full_html', langcode='zh-hans', 
revision_id=1153 where entity_id=1153 
 {executed in 1 msec}
2020-11-25 10:29:57.314 INFO  jdbc.sqltiming Line:373 - select bookfieldt0_.entity_id as entity_i1_9_, bookfieldt0_.bundle as bundle2_9_, bookfieldt0_.delta 
as delta3_9_, bookfieldt0_.langcode as langcode4_9_, bookfieldt0_.revision_id as revision5_9_, 
bookfieldt0_.field_thumb_value as field_th6_9_ from node__field_thumb bookfieldt0_ where bookfieldt0_.entity_id=1153 
 {executed in 1 msec}
2020-11-25 10:29:57.314 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------|------------------|
|entity_id |bundle |delta |langcode |revision_id |field_thumb_value |
|----------|-------|------|---------|------------|------------------|
|1153      |book   |0     |zh-hans  |1153        |                  |
|----------|-------|------|---------|------------|------------------|

2020-11-25 10:29:57.316 INFO  jdbc.sqltiming Line:373 - update node__field_thumb set bundle='book', delta=0, langcode='zh-hans', revision_id=1153, 
field_thumb_value='https://static001.geekbang.org/resource/image/fe/e7/fe54bc50797244afa76333d05c68ece7.jpg' 
where entity_id=1153 
 {executed in 0 msec}
2020-11-25 10:29:57.320 INFO  jdbc.sqltiming Line:373 - select nodefieldt0_.entity_id as entity_i1_18_0_, nodefieldt0_.bundle as bundle2_18_0_, nodefieldt0_.delta 
as delta3_18_0_, nodefieldt0_.langcode as langcode4_18_0_, nodefieldt0_.revision_id as revision5_18_0_, 
nodefieldt0_.field_thumb_value as field_th6_18_0_ from node_revision__field_thumb nodefieldt0_ 
where nodefieldt0_.entity_id=1153 
 {executed in 0 msec}
2020-11-25 10:29:57.321 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------|------------------|
|entity_id |bundle |delta |langcode |revision_id |field_thumb_value |
|----------|-------|------|---------|------------|------------------|
|[unread]  |book   |0     |zh-hans  |1153        |                  |
|----------|-------|------|---------|------------|------------------|

2020-11-25 10:29:57.322 INFO  jdbc.sqltiming Line:373 - update node_revision__field_thumb set bundle='book', delta=0, langcode='zh-hans', revision_id=1153, 
field_thumb_value='https://static001.geekbang.org/resource/image/fe/e7/fe54bc50797244afa76333d05c68ece7.jpg' 
where entity_id=1153 
 {executed in 0 msec}
2020-11-25 10:29:57.327 INFO  jdbc.sqltiming Line:373 - select bookfieldf0_.entity_id as entity_i1_6_0_, bookfieldf0_.bundle as bundle2_6_0_, bookfieldf0_.delta 
as delta3_6_0_, bookfieldf0_.field_fenlei_target_id as field_fe4_6_0_, bookfieldf0_.langcode 
as langcode5_6_0_, bookfieldf0_.revision_id as revision6_6_0_ from node__field_fenlei bookfieldf0_ 
where bookfieldf0_.entity_id=1153 
 {executed in 1 msec}
2020-11-25 10:29:57.327 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|-----------------------|---------|------------|
|entity_id |bundle |delta |field_fenlei_target_id |langcode |revision_id |
|----------|-------|------|-----------------------|---------|------------|
|[unread]  |book   |0     |1                      |zh-hans  |1153        |
|----------|-------|------|-----------------------|---------|------------|

2020-11-25 10:29:57.330 INFO  jdbc.sqltiming Line:373 - select nodefieldf0_.entity_id as entity_i1_15_0_, nodefieldf0_.bundle as bundle2_15_0_, nodefieldf0_.delta 
as delta3_15_0_, nodefieldf0_.field_fenlei_target_id as field_fe4_15_0_, nodefieldf0_.langcode 
as langcode5_15_0_, nodefieldf0_.revision_id as revision6_15_0_ from node_revision__field_fenlei 
nodefieldf0_ where nodefieldf0_.entity_id=1153 
 {executed in 0 msec}
2020-11-25 10:29:57.331 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|-----------------------|---------|------------|
|entity_id |bundle |delta |field_fenlei_target_id |langcode |revision_id |
|----------|-------|------|-----------------------|---------|------------|
|[unread]  |book   |0     |1                      |zh-hans  |1153        |
|----------|-------|------|-----------------------|---------|------------|

2020-11-25 10:29:57.333 INFO  jdbc.sqltiming Line:373 - select bookchecke0_.item_id as item_id1_2_, bookchecke0_.fsid as fsid2_2_, bookchecke0_.got 
as got3_2_, bookchecke0_.name as name4_2_, bookchecke0_.parse_fail as parse_fa5_2_, bookchecke0_.parsed 
as parsed6_2_, bookchecke0_.path as path7_2_, bookchecke0_.title as title8_2_, bookchecke0_.vid 
as vid9_2_ from book_check bookchecke0_ where bookchecke0_.fsid='983423512582907' and bookchecke0_.name='net_content' 
 {executed in 0 msec}
2020-11-25 10:29:57.333 INFO  jdbc.resultsettable Line:610 - 
|--------|---------|---------|---------|-----------|---------|---------|---------|---------|
|item_id |fsid     |got      |name     |parse_fail |parsed   |path     |title    |vid      |
|--------|---------|---------|---------|-----------|---------|---------|---------|---------|
|1154    |[unread] |[unread] |[unread] |[unread]   |[unread] |[unread] |[unread] |[unread] |
|--------|---------|---------|---------|-----------|---------|---------|---------|---------|

2020-11-25 10:32:07.393 INFO  jdbc.sqltiming Line:373 - update book_check set fsid='983423512582907', got=1, name='net_content', parse_fail='', parsed=1, 
path='123-检索技术核心20讲/02丨基础技术篇 (8讲)/04丨状态检索：如何快速判断一个用户是否存在？.html', title='04丨状态检索：如何快速判断一个用户是否存在？', 
vid=1154 where item_id=1154 
 {executed in 0 msec}
2020-11-25 10:32:07.402 INFO  jdbc.sqltiming Line:373 - select nodebodyen0_.entity_id as entity_i1_4_, nodebodyen0_.body_value as body_val2_4_, nodebodyen0_.body_summary 
as body_sum3_4_, nodebodyen0_.bundle as bundle4_4_, nodebodyen0_.delta as delta5_4_, nodebodyen0_.body_format 
as body_for6_4_, nodebodyen0_.langcode as langcode7_4_, nodebodyen0_.revision_id as revision8_4_ 
from node__body nodebodyen0_ where nodebodyen0_.entity_id=1154 
 {executed in 0 msec}
2020-11-25 10:32:07.402 INFO  jdbc.resultsettable Line:610 - 
|----------|-----------|-------------|-------|------|------------|---------|------------|
|entity_id |body_value |body_summary |bundle |delta |body_format |langcode |revision_id |
|----------|-----------|-------------|-------|------|------------|---------|------------|
|1154      |           |             |book   |0     |full_html   |zh-hans  |1154        |
|----------|-----------|-------------|-------|------|------------|---------|------------|

2020-11-25 10:32:07.403 INFO  jdbc.sqltiming Line:373 - select nodebodyre0_.entity_id as entity_i1_13_0_, nodebodyre0_.body_value as body_val2_13_0_, 
nodebodyre0_.body_summary as body_sum3_13_0_, nodebodyre0_.bundle as bundle4_13_0_, nodebodyre0_.delta 
as delta5_13_0_, nodebodyre0_.body_format as body_for6_13_0_, nodebodyre0_.langcode as langcode7_13_0_, 
nodebodyre0_.revision_id as revision8_13_0_ from node_revision__body nodebodyre0_ where nodebodyre0_.entity_id=1154 
 {executed in 0 msec}
2020-11-25 10:32:07.404 INFO  jdbc.resultsettable Line:610 - 
|----------|-----------|-------------|-------|------|------------|---------|------------|
|entity_id |body_value |body_summary |bundle |delta |body_format |langcode |revision_id |
|----------|-----------|-------------|-------|------|------------|---------|------------|
|[unread]  |           |             |book   |0     |full_html   |zh-hans  |1154        |
|----------|-----------|-------------|-------|------|------------|---------|------------|

2020-11-25 10:32:07.406 INFO  jdbc.sqltiming Line:373 - update node__body set body_value='<div data-slate-editor="true" data-key="1201" autocorrect="off" 
spellcheck="false" data-gramm="false" style="outline: none; white-space: pre-wrap; overflow-wrap: 
break-word;"> <div class="se-1a4a431a " data-slate-type="paragraph" data-slate-object="block" 
data-key="1202"> <span data-slate-object="text" data-key="1203"><span data-slate-leaf="true" 
data-offset-key="1203:0" data-first-offset="true"><span data-slate-string="true">你好，我是陈东。</span></span></span> 
</div> <div class="se-9af80b45 " data-slate-type="paragraph" data-slate-object="block" data-key="1204"> 
<span data-slate-object="text" data-key="1205"><span data-slate-leaf="true" data-offset-key="1205:0" 
data-first-offset="true"><span data-slate-string="true">在实际工作中，我们经常需要判断一个对象是否存在。比如说，在注册新用户时，我们需要先快速判断这个用户 
ID 是否被注册过；再比如说，在爬虫系统抓取网页之前，我们要判断一个 URL 是否已经被抓取过，从而避免无谓的、重复的抓取工作。</span></span></span> </div> 
<div class="se-d8f3ba3a " data-slate-type="paragraph" data-slate-object="block" data-key="1206"> 
<span data-slate-object="text" data-key="1207"><span data-slate-leaf="true" data-offset-key="1207:0" 
data-first-offset="true"><span data-slate-string="true">那么，对于这一类是否存在的状态检索需求，如果直接使用我们之前学习过的检索技术，有序数组、二叉检索树以及哈希表来实现的话，它们的检索性能如何呢？是否还有优化的方案呢？今天，我们就一起来讨论一下这些问题。</span></span></span> 
</div> <h2 class="se-fb4610f3" data-slate-type="heading" data-slate-object="block" data-key="1208"><span 
data-slate-object="text" data-key="1209"><span data-slate-leaf="true" data-offset-key="1209:0" 
data-first-offset="true"><span data-slate-string="true">如何使用数组的随机访问特性提高查询效率？</span></span></span></h2> 
<div class="se-ae72d48f " data-slate-type="paragraph" data-slate-object="block" data-key="1210"> 
<span data-slate-object="text" data-key="1211"><span data-slate-leaf="true" data-offset-key="1211:0" 
data-first-offset="true"><span data-slate-string="true">以注册新用户时查询用户 ID 是否存在为例，我们可以直接使用有序数组、二叉检索树或者哈希表来存储所有的用户 
ID。</span></span></span> </div> <div class="se-6e02b427 " data-slate-type="paragraph" data-slate-object="block" 
data-key="1212"> <span data-slate-object="text" data-key="1213"><span data-slate-leaf="true" 
data-offset-key="1213:0" data-first-offset="true"><span data-slate-string="true">我们知道，无论是有序数组还是二叉检索树，它们都是使用二分查找的思想从中间元素开始查起的。所以，在查询用户 
ID 是否存在时，它们的平均检索时间代价都是 O(log n)，而哈希表的平均检索时间代价是 O(1)。因此，如果我们希望能快速查询出元素是否存在，那哈希表无疑是最合适的选择。不过，如果从工程实现的角度来看的话，哈希表的查询过程还是可以优化的。</span></span></span> 
</div> <div class="se-a62d0d40 " data-slate-type="paragraph" data-slate-object="block" data-key="1214"> 
<span data-slate-object="text" data-key="1215"><span data-slate-leaf="true" data-offset-key="1215:0" 
data-first-offset="true"><span data-slate-string="true">比如说，如果我们要查询的对象 ID 本身是正整数类型，而且 ID 范围有上限的话。我们就可以申请一个足够大的数组，让数组的长度超过 
ID 的上限。然后，把数组中所有位置的值都初始化为 0。对于存在的用户，我们</span></span></span><span data-slate-object="text" data-key="1216"><span 
data-slate-leaf="true" data-offset-key="1216:0" data-first-offset="true"><span class="se-f103ef34" 
data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">直接将用户 ID 的值作为数组下标</span></span></span></span><span 
data-slate-object="text" data-key="1217"><span data-slate-leaf="true" data-offset-key="1217:0" 
data-first-offset="true"><span data-slate-string="true">，将该位置的值从 0 设为 1 就可以了。</span></span></span> 
</div> <div class="se-d05d13fd " data-slate-type="paragraph" data-slate-object="block" data-key="1218"> 
<span data-slate-object="text" data-key="1219"><span data-slate-leaf="true" data-offset-key="1219:0" 
data-first-offset="true"><span data-slate-string="true">这种情况下，当我们查询一个用户 ID 是否存在时，会直接以该 ID 为数组下标去访问数组，如果该位置为 
1，说明该 ID 存在；如果为 0，就说明该 ID 不存在。和哈希表的查找流程相比，这个流程就节省了计算哈希值得到数组下标的环节，并且直接利用数组随机访问的特性，在 O(1) 的时间内就能判断出元素是否存在，查询效率是最高的。</span></span></span> 
</div> <div class="se-fdda588a " data-slate-type="paragraph" data-slate-object="block" data-key="1220"> 
<span data-slate-object="text" data-key="1221"><span data-slate-leaf="true" data-offset-key="1221:0" 
data-first-offset="true"><span data-slate-string="true">但是，直接使用 ID 作为数组下标会有一个问题：如果 ID 的范围比较广，比如说在 
10 万之内，那我们就需要保证数组的长度大于 10 万。所以，这种方案的占用空间会很大。</span></span></span> </div> <div class="se-af24ca9f 
" data-slate-type="paragraph" data-slate-object="block" data-key="1222"> <span data-slate-object="text" 
data-key="1223"><span data-slate-leaf="true" data-offset-key="1223:0" data-first-offset="true"><span 
data-slate-string="true">而且，如果这个数组是一个 int 32 类型的整型数组，那么每个元素就会占据 4 个字节，用 4 个字节来存储 0 和 1 会是一个巨大的空间浪费。那我们该如何优化呢？你可以先想一想，然后我们一起来讨论。</span></span></span> 
</div> <h2 class="se-f30a8529" data-slate-type="heading" data-slate-object="block" data-key="1224"><span 
data-slate-object="text" data-key="1225"><span data-slate-leaf="true" data-offset-key="1225:0" 
data-first-offset="true"><span data-slate-string="true">如何使用位图来减少存储空间？</span></span></span></h2> 
<div class="se-d79d5227 " data-slate-type="paragraph" data-slate-object="block" data-key="1226"> 
<span data-slate-object="text" data-key="1227"><span data-slate-leaf="true" data-offset-key="1227:0" 
data-first-offset="true"><span data-slate-string="true">最直观的一个想法就是，使用最少字节的类型来定义数组。比如说，使用 1 
个字节的 char 类型数组，或者使用 bool 类型的数组（在许多系统中，一个 bool 类型的元素也是 1 个字节）。它们和 4 个字节的 int 32 数组相比，空间使用效率提升了 
4 倍，这已经算是不错的改善了。</span></span></span> </div> <div class="se-80642b40 " data-slate-type="paragraph" 
data-slate-object="block" data-key="1228"> <span data-slate-object="text" data-key="1229"><span 
data-slate-leaf="true" data-offset-key="1229:0" data-first-offset="true"><span data-slate-string="true">但是，使用 
char 类型的数组，依然是一个非常“浪费空间”的方案。因为表示 0 或者 1，理论上只需要一个 bit。所以，如果我们能以 bit 为单位来构建这个数组，那使用空间就是 int 32 
数组的 1/32，从而大幅减少了存储使用的内存空间。这种以 bit 为单位构建数组的方案，就叫作 </span></span></span><span data-slate-object="text" 
data-key="1230"><span data-slate-leaf="true" data-offset-key="1230:0" data-first-offset="true"><span 
class="se-9bc4d14f" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">Bitmap</span></span></span></span><span 
data-slate-object="text" data-key="1231"><span data-slate-leaf="true" data-offset-key="1231:0" 
data-first-offset="true"><span data-slate-string="true">，翻译为</span></span></span><span data-slate-object="text" 
data-key="1232"><span data-slate-leaf="true" data-offset-key="1232:0" data-first-offset="true"><span 
class="se-fa99008f" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">位图</span></span></span></span><span 
data-slate-object="text" data-key="1233"><span data-slate-leaf="true" data-offset-key="1233:0" 
data-first-offset="true"><span data-slate-string="true">。</span></span></span> </div> <div 
class="se-bfbe8e7c " data-slate-type="paragraph" data-slate-object="block" data-key="1234"> 
<span data-slate-object="text" data-key="1235"><span data-slate-leaf="true" data-offset-key="1235:0" 
data-first-offset="true"><span data-slate-string="true">位图的优势非常明显，但许多系统中并没有以 bit 为单位的数据类型。因此，我们往往需要对其他类型的数组进行一些转换设计，使其能对相应的 
bit 位的位置进行访问，从而实现位图。</span></span></span> </div> <div class="se-ccc5d2ad " data-slate-type="paragraph" 
data-slate-object="block" data-key="1236"> <span data-slate-object="text" data-key="1237"><span 
data-slate-leaf="true" data-offset-key="1237:0" data-first-offset="true"><span data-slate-string="true">我们以 
char 类型的数组为例子。假设我们申请了一个 1000 个元素的 char 类型数组，每个 char 元素有 8 个 bit，如果一个 bit 表示一个用户，那么 1000 个元素的 
char 类型数组就能表示 8*1000 = 8000 个用户。如果一个用户的 ID 是 11，那么位图中的第 11 个 bit 就表示这个用户是否存在的信息。</span></span></span> 
</div> <div class="se-8a605baf " data-slate-type="paragraph" data-slate-object="block" data-key="1238"> 
<span data-slate-object="text" data-key="1239"><span data-slate-leaf="true" data-offset-key="1239:0" 
data-first-offset="true"><span data-slate-string="true">这种情况下，我们怎么才能快速访问到第 11 个 bit 呢？</span></span></span> 
</div> <div class="se-cea948fa " data-slate-type="paragraph" data-slate-object="block" data-key="1240"> 
<span data-slate-object="text" data-key="1241"><span data-slate-leaf="true" data-offset-key="1241:0" 
data-first-offset="true"><span data-slate-string="true">首先，数组是以 char 类型的元素为一个单位的，因此，我们的第一步，就是要找到第 
11 个 bit 在数组的第几个元素里。具体的计算过程：一个元素占 8 个 bit，我们用 11 除以 8，得到的结果是 1，余数是 3。这就代表着，第 11 个 bit 存在于第 
2 个元素里，并且在第 2 个元素里的位置是第 3 个。</span></span></span> </div> <div class="se-0b70f4f8 " data-slate-type="paragraph" 
data-slate-object="block" data-key="1242"> <span data-slate-object="text" data-key="1243"><span 
data-slate-leaf="true" data-offset-key="1243:0" data-first-offset="true"><span data-slate-string="true">对于第 
2 个元素的访问，我们直接使用数组下标[1]就可以在 O(1) 的时间内访问到。对于第 2 个元素中的第 3 个 bit 的访问，我们可以通过位运算，先构造一个二进制为 00100000 
的字节（字节的第 3 位为 1），然后和第 2 个元素做 and 运算，就能得知该元素的第 3 位是 1 还是 0。这也是一个时间代价为 O(1) 的操作。这样一来，通过两次 O(1) 
时间代价的查找，我们就可以知道第 11 个 bit 的值是 0 还是 1 了。</span></span></span> </div> <div class="se-f28b9cdd" 
data-slate-type="image" data-slate-object="block" data-key="1244"> <img class="se-307eb522" 
src="https://static001.geekbang.org/resource/image/70/85/7003f942bc4626ae74fd66badbb21f85.jpg"> 
</div> <div class="se-ac7fdf9a se-bf3de79d" data-slate-type="paragraph" data-slate-object="block" 
data-key="1245"> <span data-slate-object="text" data-key="1246"><span data-slate-leaf="true" 
data-offset-key="1246:0" data-first-offset="true"><span class="se-76c2338e" data-slate-type="secondary" 
data-slate-object="mark"><span data-slate-string="true">用户 ID 为 11 的位图定位</span></span></span></span> 
</div> <div class="se-36ca877b " data-slate-type="paragraph" data-slate-object="block" data-key="1247"> 
<span data-slate-object="text" data-key="1248"><span data-slate-leaf="true" data-offset-key="1248:0" 
data-first-offset="true"><span data-slate-string="true">尽管位图相对于原始数组来说，在元素存储上已经有了很大的优化，但如果我们还想进一步优化存储空间，是否还有其他的优化方案呢？我们知道，</span></span></span><span 
data-slate-object="text" data-key="1249"><span data-slate-leaf="true" data-offset-key="1249:0" 
data-first-offset="true"><span class="se-9c5e7764" data-slate-type="bold" data-slate-object="mark"><span 
data-slate-string="true">一个数组所占的空间其实就是“数组元素个数 * 每个元素大小”</span></span></span></span><span data-slate-object="text" 
data-key="1250"><span data-slate-leaf="true" data-offset-key="1250:0" data-first-offset="true"><span 
data-slate-string="true">。我们已经将每个元素大小压缩到了最小单位 1 个 bit，如果还要进行优化，那么自然会想到优化“数组元素个数”。</span></span></span> 
</div> <div class="se-3871ea3d " data-slate-type="paragraph" data-slate-object="block" data-key="1251"> 
<span data-slate-object="text" data-key="1252"><span data-slate-leaf="true" data-offset-key="1252:0" 
data-first-offset="true"><span data-slate-string="true">没错，限制数组的长度是一个可行的方案。不过前面我们也说了，数组长度必须大于 
ID 的上限。因此，如果我们希望将数组长度压缩到一个足够小的值之内，我们就需要使用哈希函数将大于数组长度的用户 ID，转换为一个小于数组长度的数值作为下标。除此以外，使用哈希函数也带来了另一个优点，那就是我们不需要把用户 
ID 限制为正整数了，它也可以是字符串。这样一来，压缩数组长度，并使用哈希函数，就是一个更加通用的解决方案。</span></span></span> </div> <div class="se-23538822 
" data-slate-type="paragraph" data-slate-object="block" data-key="1253"> <span data-slate-object="text" 
data-key="1254"><span data-slate-leaf="true" data-offset-key="1254:0" data-first-offset="true"><span 
data-slate-string="true">但是我们也知道，数组压缩得越小，发生哈希冲突的可能性就会越大，如果两个元素 A 和 B 的哈希值冲突了，映射到了同一个位置。那么，如果我们查询 
A 时，该位置的结果为 1，其实并不能说明元素 A 一定存在。因此，如何在数组压缩的情况下缓解哈希冲突，保证一定的查询正确率，是我们面临的主要问题。</span></span></span> 
</div> <div class="se-79c9175d " data-slate-type="paragraph" data-slate-object="block" data-key="1255"> 
<span data-slate-object="text" data-key="1256"><span data-slate-leaf="true" data-offset-key="1256:0" 
data-first-offset="true"><span data-slate-string="true">在第 3 讲中，我们讲了哈希表解决哈希冲突的两种常用方法：开放寻址法和链表法。开放寻址法中有一个优化方案叫“双散列”，它的原理是使用多个哈希函数来解决冲突问题。我们能否借鉴这个思想，在位图的场景下使用多个哈希函数来降低冲突概率呢？没错，这其实就是布隆过滤器（Bloom 
Filter）的设计思想。</span></span></span> </div> <div class="se-622f7d96 " data-slate-type="paragraph" 
data-slate-object="block" data-key="1257"> <span data-slate-object="text" data-key="1258"><span 
data-slate-leaf="true" data-offset-key="1258:0" data-first-offset="true"><span data-slate-string="true">布隆过滤器最大的特点，就是对一个对象使用多个哈希函数。如果我们使用了 
k 个哈希函数，就会得到 k 个哈希值，也就是 k 个下标，我们会把数组中对应下标位置的值都置为 1。布隆过滤器和位图最大的区别就在于，我们不再使用一位来表示一个对象，而是使用 k 
位来表示一个对象。这样两个对象的 k 位都相同的概率就会大大降低，从而能够解决哈希冲突的问题了。</span></span></span> </div> <div class="se-ed4974cf" 
data-slate-type="image" data-slate-object="block" data-key="1259"> <img class="se-5d8dc332" 
src="https://static001.geekbang.org/resource/image/08/cb/089de1531a75731a657ae2c6e55c55cb.jpg"> 
</div> <div class="se-9911d446 se-96813674" data-slate-type="paragraph" data-slate-object="block" 
data-key="1260"> <span data-slate-object="text" data-key="1261"><span data-slate-leaf="true" 
data-offset-key="1261:0" data-first-offset="true"><span class="se-76c2338e" data-slate-type="secondary" 
data-slate-object="mark"><span data-slate-string="true">Bloom filter 示例</span></span></span></span> 
</div> <div class="se-7c405673 " data-slate-type="paragraph" data-slate-object="block" data-key="1262"> 
<span data-slate-object="text" data-key="1263"><span data-slate-leaf="true" data-offset-key="1263:0" 
data-first-offset="true"><span data-slate-string="true">但是，布隆过滤器的查询有一个特点，就是即使任何两个元素的哈希值不冲突，而且我们查询对象的 
k 个位置的值都是 1，查询结果为存在，这个结果也可能是错误的。这就叫作</span></span></span><span data-slate-object="text" data-key="1264"><span 
data-slate-leaf="true" data-offset-key="1264:0" data-first-offset="true"><span class="se-f1a518fa" 
data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">布隆过滤器的错误率</span></span></span></span><span 
data-slate-object="text" data-key="1265"><span data-slate-leaf="true" data-offset-key="1265:0" 
data-first-offset="true"><span data-slate-string="true">。</span></span></span> </div> <div 
class="se-98877110 " data-slate-type="paragraph" data-slate-object="block" data-key="1266"> 
<span data-slate-object="text" data-key="1267"><span data-slate-leaf="true" data-offset-key="1267:0" 
data-first-offset="true"><span data-slate-string="true">我在下图给出了一个例子。我们可以看到，布隆过滤器中存储了 x 和 y 
两个对象，它们对应的 bit 位被置为 1。当我们查询一个不存在的对象 z 时，如果 z 的 k 个哈希值的对应位置的值正好都是 1，z 就会被错误地认定为存在。而且，这个时候，z 
和 x，以及 z 和 y，两两之间也并没有发生哈希冲突。</span></span></span> </div> <div class="se-512d19a7" data-slate-type="image" 
data-slate-object="block" data-key="1268"> <img class="se-5d38d4d1" src="https://static001.geekbang.org/resource/image/7f/26/7f9a98a2e877b298c0be5b5c7b8a5626.jpg"> 
</div> <div class="se-f282e2da se-248d60c2" data-slate-type="paragraph" data-slate-object="block" 
data-key="1269"> <span data-slate-object="text" data-key="1270"><span data-slate-leaf="true" 
data-offset-key="1270:0" data-first-offset="true"><span class="se-76c2338e" data-slate-type="secondary" 
data-slate-object="mark"><span data-slate-string="true">Bloom filter 错误率示例</span></span></span></span> 
</div> <div class="se-07236523 " data-slate-type="paragraph" data-slate-object="block" data-key="1271"> 
<span data-slate-object="text" data-key="1272"><span data-slate-leaf="true" data-offset-key="1272:0" 
data-first-offset="true"><span data-slate-string="true">那遇到“可能存在”这样的情况，我们该怎么办呢？不要忘了我们的使用场景：我们希望用更小的代价快速判断 
ID 是否已经被注册了。在这个使用场景中，就算我们无法确认 ID 是否已经被注册了，让用户再换一个 ID 注册，这也不会损害新用户的体验。在系统不要求结果 100% 准确的情况下，我们可以直接当作这个用户 
ID 已经被注册了就可以了。这样，我们使用布隆过滤器就可以快速完成“是否存在”的检索。</span></span></span> </div> <div class="se-4cc9ba64 
" data-slate-type="paragraph" data-slate-object="block" data-key="1273"> <span data-slate-object="text" 
data-key="1274"><span data-slate-leaf="true" data-offset-key="1274:0" data-first-offset="true"><span 
data-slate-string="true">除此之外，对于布隆过滤器而言，如果哈希函数的个数不合理，比如哈希函数特别多，布隆过滤器的错误率就会变大。因此，除了使用多个哈希函数避免哈希冲突以外，我们还要控制布隆过滤器中哈希函数的个数。有这样一个</span></span></span><span 
data-slate-object="text" data-key="1275"><span data-slate-leaf="true" data-offset-key="1275:0" 
data-first-offset="true"><span class="se-3d6fca76" data-slate-type="bold" data-slate-object="mark"><span 
data-slate-string="true">计算最优哈希函数个数的数学公式: 哈希函数个数 k = (m/n) * ln(2)</span></span></span></span><span 
data-slate-object="text" data-key="1276"><span data-slate-leaf="true" data-offset-key="1276:0" 
data-first-offset="true"><span data-slate-string="true">。其中 m 为 bit 数组长度，n 为要存入的对象的个数。实际上，如果哈希函数个数为 
1，且数组长度足够，布隆过滤器就可以退化成一个位图。所以，我们可以认为“</span></span></span><span data-slate-object="text" data-key="1277"><span 
data-slate-leaf="true" data-offset-key="1277:0" data-first-offset="true"><span class="se-315bff0a" 
data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">位图是只有一个特殊的哈希函数，且没有被压缩长度的布隆过滤器</span></span></span></span><span 
data-slate-object="text" data-key="1278"><span data-slate-leaf="true" data-offset-key="1278:0" 
data-first-offset="true"><span data-slate-string="true">”。</span></span></span> </div> <h2 
class="se-6aeb7649" data-slate-type="heading" data-slate-object="block" data-key="1279"><span 
data-slate-object="text" data-key="1280"><span data-slate-leaf="true" data-offset-key="1280:0" 
data-first-offset="true"><span data-slate-string="true">重点回顾</span></span></span></h2> <div 
class="se-8c227b03 " data-slate-type="paragraph" data-slate-object="block" data-key="1281"> 
<span data-slate-object="text" data-key="1282"><span data-slate-leaf="true" data-offset-key="1282:0" 
data-first-offset="true"><span data-slate-string="true">好了，状态检索的内容我们就讲到这里。我们一起来总结一下，这一讲你要掌握的重点内容。</span></span></span> 
</div> <div class="se-0c5d58e2 " data-slate-type="paragraph" data-slate-object="block" data-key="1283"> 
<span data-slate-object="text" data-key="1284"><span data-slate-leaf="true" data-offset-key="1284:0" 
data-first-offset="true"><span data-slate-string="true">今天，我们主要解决了快速判断一个对象是否存在的问题。相比于有序数组、二叉检索树和哈希表这三种方案，位图和布隆过滤器其实更适合解决这类状态检索的问题。这是因为，在不要求 
100% 判断正确的情况下，使用位图和布隆过滤器可以达到 O(1) 时间代价的检索效率，同时空间使用率也非常高效。</span></span></span> </div> <div 
class="se-7222c6e4 " data-slate-type="paragraph" data-slate-object="block" data-key="1285"> 
<span data-slate-object="text" data-key="1286"><span data-slate-leaf="true" data-offset-key="1286:0" 
data-first-offset="true"><span data-slate-string="true">虽然位图和布隆过滤器的原理和实现都非常简单，但是在许多复杂的大型系统中都可以见到它们的身影。</span></span></span> 
</div> <div class="se-9f5f865c " data-slate-type="paragraph" data-slate-object="block" data-key="1287"> 
<span data-slate-object="text" data-key="1288"><span data-slate-leaf="true" data-offset-key="1288:0" 
data-first-offset="true"><span data-slate-string="true">比如，存储系统中的数据是存储在磁盘中的，而磁盘中的检索效率非常低，因此，我们往往会先使用内存中的布隆过滤器来快速判断数据是否存在，不存在就直接返回，只有可能存在才会去磁盘检索，这样就避免了为无效数据读取磁盘的额外开销。</span></span></span> 
</div> <div class="se-9cad4472 " data-slate-type="paragraph" data-slate-object="block" data-key="1289"> 
<span data-slate-object="text" data-key="1290"><span data-slate-leaf="true" data-offset-key="1290:0" 
data-first-offset="true"><span data-slate-string="true">再比如，在搜索引擎中，我们也需要使用布隆过滤器快速判断网站是否已经被抓取过，如果一定不存在，我们就直接去抓取；如果可能存在，那我们可以根据需要，直接放弃抓取或者再次确认是否需要抓取。</span></span></span><span 
data-slate-object="text" data-key="1291"><span data-slate-leaf="true" data-offset-key="1291:0" 
data-first-offset="true"><span class="se-e9d4dd2a" data-slate-type="bold" data-slate-object="mark"><span 
data-slate-string="true">你会发现，这种快速预判断的思想，也是提高应用整体检索性能的一种常见设计思路。</span></span></span></span> 
</div> <h2 class="se-758f3f92" data-slate-type="heading" data-slate-object="block" data-key="1292"><span 
data-slate-object="text" data-key="1293"><span data-slate-leaf="true" data-offset-key="1293:0" 
data-first-offset="true"><span data-slate-string="true">课堂讨论</span></span></span></h2> <div 
class="se-02c98706 " data-slate-type="paragraph" data-slate-object="block" data-key="1294"> 
<span data-slate-object="text" data-key="1295"><span data-slate-leaf="true" data-offset-key="1295:0" 
data-first-offset="true"><span data-slate-string="true">这节课的内容，你可以结合这道讨论题进一步加深理解：</span></span></span> 
</div> <div class="se-8d42e9d7 " data-slate-type="paragraph" data-slate-object="block" data-key="1296"> 
<span data-slate-object="text" data-key="1297"><span data-slate-leaf="true" data-offset-key="1297:0" 
data-first-offset="true"><span data-slate-string="true">如果位图中一个元素被删除了，我们可以将对应 bit 位置为 0。但如果布隆过滤器中一个元素被删除了，我们直接将对应的 
k 个 bit 位置为 0，会产生什么样的问题呢？为什么？</span></span></span> </div> <div class="se-34fd5358 " data-slate-type="paragraph" 
data-slate-object="block" data-key="1298"> <span data-slate-object="text" data-key="1299"><span 
data-slate-leaf="true" data-offset-key="1299:0" data-first-offset="true"><span data-slate-string="true">欢迎在留言区畅所欲言，说出你的思考过程和最终答案。如果有收获，也欢迎把这篇文章分享给你的朋友。</span></span></span> 
</div> </div>', body_summary='', bundle='book', delta=0, body_format='full_html', langcode='zh-hans', 
revision_id=1154 where entity_id=1154 
 {executed in 1 msec}
2020-11-25 10:32:07.408 INFO  jdbc.sqltiming Line:373 - update node_revision__body set body_value='<div data-slate-editor="true" data-key="1201" autocorrect="off" 
spellcheck="false" data-gramm="false" style="outline: none; white-space: pre-wrap; overflow-wrap: 
break-word;"> <div class="se-1a4a431a " data-slate-type="paragraph" data-slate-object="block" 
data-key="1202"> <span data-slate-object="text" data-key="1203"><span data-slate-leaf="true" 
data-offset-key="1203:0" data-first-offset="true"><span data-slate-string="true">你好，我是陈东。</span></span></span> 
</div> <div class="se-9af80b45 " data-slate-type="paragraph" data-slate-object="block" data-key="1204"> 
<span data-slate-object="text" data-key="1205"><span data-slate-leaf="true" data-offset-key="1205:0" 
data-first-offset="true"><span data-slate-string="true">在实际工作中，我们经常需要判断一个对象是否存在。比如说，在注册新用户时，我们需要先快速判断这个用户 
ID 是否被注册过；再比如说，在爬虫系统抓取网页之前，我们要判断一个 URL 是否已经被抓取过，从而避免无谓的、重复的抓取工作。</span></span></span> </div> 
<div class="se-d8f3ba3a " data-slate-type="paragraph" data-slate-object="block" data-key="1206"> 
<span data-slate-object="text" data-key="1207"><span data-slate-leaf="true" data-offset-key="1207:0" 
data-first-offset="true"><span data-slate-string="true">那么，对于这一类是否存在的状态检索需求，如果直接使用我们之前学习过的检索技术，有序数组、二叉检索树以及哈希表来实现的话，它们的检索性能如何呢？是否还有优化的方案呢？今天，我们就一起来讨论一下这些问题。</span></span></span> 
</div> <h2 class="se-fb4610f3" data-slate-type="heading" data-slate-object="block" data-key="1208"><span 
data-slate-object="text" data-key="1209"><span data-slate-leaf="true" data-offset-key="1209:0" 
data-first-offset="true"><span data-slate-string="true">如何使用数组的随机访问特性提高查询效率？</span></span></span></h2> 
<div class="se-ae72d48f " data-slate-type="paragraph" data-slate-object="block" data-key="1210"> 
<span data-slate-object="text" data-key="1211"><span data-slate-leaf="true" data-offset-key="1211:0" 
data-first-offset="true"><span data-slate-string="true">以注册新用户时查询用户 ID 是否存在为例，我们可以直接使用有序数组、二叉检索树或者哈希表来存储所有的用户 
ID。</span></span></span> </div> <div class="se-6e02b427 " data-slate-type="paragraph" data-slate-object="block" 
data-key="1212"> <span data-slate-object="text" data-key="1213"><span data-slate-leaf="true" 
data-offset-key="1213:0" data-first-offset="true"><span data-slate-string="true">我们知道，无论是有序数组还是二叉检索树，它们都是使用二分查找的思想从中间元素开始查起的。所以，在查询用户 
ID 是否存在时，它们的平均检索时间代价都是 O(log n)，而哈希表的平均检索时间代价是 O(1)。因此，如果我们希望能快速查询出元素是否存在，那哈希表无疑是最合适的选择。不过，如果从工程实现的角度来看的话，哈希表的查询过程还是可以优化的。</span></span></span> 
</div> <div class="se-a62d0d40 " data-slate-type="paragraph" data-slate-object="block" data-key="1214"> 
<span data-slate-object="text" data-key="1215"><span data-slate-leaf="true" data-offset-key="1215:0" 
data-first-offset="true"><span data-slate-string="true">比如说，如果我们要查询的对象 ID 本身是正整数类型，而且 ID 范围有上限的话。我们就可以申请一个足够大的数组，让数组的长度超过 
ID 的上限。然后，把数组中所有位置的值都初始化为 0。对于存在的用户，我们</span></span></span><span data-slate-object="text" data-key="1216"><span 
data-slate-leaf="true" data-offset-key="1216:0" data-first-offset="true"><span class="se-f103ef34" 
data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">直接将用户 ID 的值作为数组下标</span></span></span></span><span 
data-slate-object="text" data-key="1217"><span data-slate-leaf="true" data-offset-key="1217:0" 
data-first-offset="true"><span data-slate-string="true">，将该位置的值从 0 设为 1 就可以了。</span></span></span> 
</div> <div class="se-d05d13fd " data-slate-type="paragraph" data-slate-object="block" data-key="1218"> 
<span data-slate-object="text" data-key="1219"><span data-slate-leaf="true" data-offset-key="1219:0" 
data-first-offset="true"><span data-slate-string="true">这种情况下，当我们查询一个用户 ID 是否存在时，会直接以该 ID 为数组下标去访问数组，如果该位置为 
1，说明该 ID 存在；如果为 0，就说明该 ID 不存在。和哈希表的查找流程相比，这个流程就节省了计算哈希值得到数组下标的环节，并且直接利用数组随机访问的特性，在 O(1) 的时间内就能判断出元素是否存在，查询效率是最高的。</span></span></span> 
</div> <div class="se-fdda588a " data-slate-type="paragraph" data-slate-object="block" data-key="1220"> 
<span data-slate-object="text" data-key="1221"><span data-slate-leaf="true" data-offset-key="1221:0" 
data-first-offset="true"><span data-slate-string="true">但是，直接使用 ID 作为数组下标会有一个问题：如果 ID 的范围比较广，比如说在 
10 万之内，那我们就需要保证数组的长度大于 10 万。所以，这种方案的占用空间会很大。</span></span></span> </div> <div class="se-af24ca9f 
" data-slate-type="paragraph" data-slate-object="block" data-key="1222"> <span data-slate-object="text" 
data-key="1223"><span data-slate-leaf="true" data-offset-key="1223:0" data-first-offset="true"><span 
data-slate-string="true">而且，如果这个数组是一个 int 32 类型的整型数组，那么每个元素就会占据 4 个字节，用 4 个字节来存储 0 和 1 会是一个巨大的空间浪费。那我们该如何优化呢？你可以先想一想，然后我们一起来讨论。</span></span></span> 
</div> <h2 class="se-f30a8529" data-slate-type="heading" data-slate-object="block" data-key="1224"><span 
data-slate-object="text" data-key="1225"><span data-slate-leaf="true" data-offset-key="1225:0" 
data-first-offset="true"><span data-slate-string="true">如何使用位图来减少存储空间？</span></span></span></h2> 
<div class="se-d79d5227 " data-slate-type="paragraph" data-slate-object="block" data-key="1226"> 
<span data-slate-object="text" data-key="1227"><span data-slate-leaf="true" data-offset-key="1227:0" 
data-first-offset="true"><span data-slate-string="true">最直观的一个想法就是，使用最少字节的类型来定义数组。比如说，使用 1 
个字节的 char 类型数组，或者使用 bool 类型的数组（在许多系统中，一个 bool 类型的元素也是 1 个字节）。它们和 4 个字节的 int 32 数组相比，空间使用效率提升了 
4 倍，这已经算是不错的改善了。</span></span></span> </div> <div class="se-80642b40 " data-slate-type="paragraph" 
data-slate-object="block" data-key="1228"> <span data-slate-object="text" data-key="1229"><span 
data-slate-leaf="true" data-offset-key="1229:0" data-first-offset="true"><span data-slate-string="true">但是，使用 
char 类型的数组，依然是一个非常“浪费空间”的方案。因为表示 0 或者 1，理论上只需要一个 bit。所以，如果我们能以 bit 为单位来构建这个数组，那使用空间就是 int 32 
数组的 1/32，从而大幅减少了存储使用的内存空间。这种以 bit 为单位构建数组的方案，就叫作 </span></span></span><span data-slate-object="text" 
data-key="1230"><span data-slate-leaf="true" data-offset-key="1230:0" data-first-offset="true"><span 
class="se-9bc4d14f" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">Bitmap</span></span></span></span><span 
data-slate-object="text" data-key="1231"><span data-slate-leaf="true" data-offset-key="1231:0" 
data-first-offset="true"><span data-slate-string="true">，翻译为</span></span></span><span data-slate-object="text" 
data-key="1232"><span data-slate-leaf="true" data-offset-key="1232:0" data-first-offset="true"><span 
class="se-fa99008f" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">位图</span></span></span></span><span 
data-slate-object="text" data-key="1233"><span data-slate-leaf="true" data-offset-key="1233:0" 
data-first-offset="true"><span data-slate-string="true">。</span></span></span> </div> <div 
class="se-bfbe8e7c " data-slate-type="paragraph" data-slate-object="block" data-key="1234"> 
<span data-slate-object="text" data-key="1235"><span data-slate-leaf="true" data-offset-key="1235:0" 
data-first-offset="true"><span data-slate-string="true">位图的优势非常明显，但许多系统中并没有以 bit 为单位的数据类型。因此，我们往往需要对其他类型的数组进行一些转换设计，使其能对相应的 
bit 位的位置进行访问，从而实现位图。</span></span></span> </div> <div class="se-ccc5d2ad " data-slate-type="paragraph" 
data-slate-object="block" data-key="1236"> <span data-slate-object="text" data-key="1237"><span 
data-slate-leaf="true" data-offset-key="1237:0" data-first-offset="true"><span data-slate-string="true">我们以 
char 类型的数组为例子。假设我们申请了一个 1000 个元素的 char 类型数组，每个 char 元素有 8 个 bit，如果一个 bit 表示一个用户，那么 1000 个元素的 
char 类型数组就能表示 8*1000 = 8000 个用户。如果一个用户的 ID 是 11，那么位图中的第 11 个 bit 就表示这个用户是否存在的信息。</span></span></span> 
</div> <div class="se-8a605baf " data-slate-type="paragraph" data-slate-object="block" data-key="1238"> 
<span data-slate-object="text" data-key="1239"><span data-slate-leaf="true" data-offset-key="1239:0" 
data-first-offset="true"><span data-slate-string="true">这种情况下，我们怎么才能快速访问到第 11 个 bit 呢？</span></span></span> 
</div> <div class="se-cea948fa " data-slate-type="paragraph" data-slate-object="block" data-key="1240"> 
<span data-slate-object="text" data-key="1241"><span data-slate-leaf="true" data-offset-key="1241:0" 
data-first-offset="true"><span data-slate-string="true">首先，数组是以 char 类型的元素为一个单位的，因此，我们的第一步，就是要找到第 
11 个 bit 在数组的第几个元素里。具体的计算过程：一个元素占 8 个 bit，我们用 11 除以 8，得到的结果是 1，余数是 3。这就代表着，第 11 个 bit 存在于第 
2 个元素里，并且在第 2 个元素里的位置是第 3 个。</span></span></span> </div> <div class="se-0b70f4f8 " data-slate-type="paragraph" 
data-slate-object="block" data-key="1242"> <span data-slate-object="text" data-key="1243"><span 
data-slate-leaf="true" data-offset-key="1243:0" data-first-offset="true"><span data-slate-string="true">对于第 
2 个元素的访问，我们直接使用数组下标[1]就可以在 O(1) 的时间内访问到。对于第 2 个元素中的第 3 个 bit 的访问，我们可以通过位运算，先构造一个二进制为 00100000 
的字节（字节的第 3 位为 1），然后和第 2 个元素做 and 运算，就能得知该元素的第 3 位是 1 还是 0。这也是一个时间代价为 O(1) 的操作。这样一来，通过两次 O(1) 
时间代价的查找，我们就可以知道第 11 个 bit 的值是 0 还是 1 了。</span></span></span> </div> <div class="se-f28b9cdd" 
data-slate-type="image" data-slate-object="block" data-key="1244"> <img class="se-307eb522" 
src="https://static001.geekbang.org/resource/image/70/85/7003f942bc4626ae74fd66badbb21f85.jpg"> 
</div> <div class="se-ac7fdf9a se-bf3de79d" data-slate-type="paragraph" data-slate-object="block" 
data-key="1245"> <span data-slate-object="text" data-key="1246"><span data-slate-leaf="true" 
data-offset-key="1246:0" data-first-offset="true"><span class="se-76c2338e" data-slate-type="secondary" 
data-slate-object="mark"><span data-slate-string="true">用户 ID 为 11 的位图定位</span></span></span></span> 
</div> <div class="se-36ca877b " data-slate-type="paragraph" data-slate-object="block" data-key="1247"> 
<span data-slate-object="text" data-key="1248"><span data-slate-leaf="true" data-offset-key="1248:0" 
data-first-offset="true"><span data-slate-string="true">尽管位图相对于原始数组来说，在元素存储上已经有了很大的优化，但如果我们还想进一步优化存储空间，是否还有其他的优化方案呢？我们知道，</span></span></span><span 
data-slate-object="text" data-key="1249"><span data-slate-leaf="true" data-offset-key="1249:0" 
data-first-offset="true"><span class="se-9c5e7764" data-slate-type="bold" data-slate-object="mark"><span 
data-slate-string="true">一个数组所占的空间其实就是“数组元素个数 * 每个元素大小”</span></span></span></span><span data-slate-object="text" 
data-key="1250"><span data-slate-leaf="true" data-offset-key="1250:0" data-first-offset="true"><span 
data-slate-string="true">。我们已经将每个元素大小压缩到了最小单位 1 个 bit，如果还要进行优化，那么自然会想到优化“数组元素个数”。</span></span></span> 
</div> <div class="se-3871ea3d " data-slate-type="paragraph" data-slate-object="block" data-key="1251"> 
<span data-slate-object="text" data-key="1252"><span data-slate-leaf="true" data-offset-key="1252:0" 
data-first-offset="true"><span data-slate-string="true">没错，限制数组的长度是一个可行的方案。不过前面我们也说了，数组长度必须大于 
ID 的上限。因此，如果我们希望将数组长度压缩到一个足够小的值之内，我们就需要使用哈希函数将大于数组长度的用户 ID，转换为一个小于数组长度的数值作为下标。除此以外，使用哈希函数也带来了另一个优点，那就是我们不需要把用户 
ID 限制为正整数了，它也可以是字符串。这样一来，压缩数组长度，并使用哈希函数，就是一个更加通用的解决方案。</span></span></span> </div> <div class="se-23538822 
" data-slate-type="paragraph" data-slate-object="block" data-key="1253"> <span data-slate-object="text" 
data-key="1254"><span data-slate-leaf="true" data-offset-key="1254:0" data-first-offset="true"><span 
data-slate-string="true">但是我们也知道，数组压缩得越小，发生哈希冲突的可能性就会越大，如果两个元素 A 和 B 的哈希值冲突了，映射到了同一个位置。那么，如果我们查询 
A 时，该位置的结果为 1，其实并不能说明元素 A 一定存在。因此，如何在数组压缩的情况下缓解哈希冲突，保证一定的查询正确率，是我们面临的主要问题。</span></span></span> 
</div> <div class="se-79c9175d " data-slate-type="paragraph" data-slate-object="block" data-key="1255"> 
<span data-slate-object="text" data-key="1256"><span data-slate-leaf="true" data-offset-key="1256:0" 
data-first-offset="true"><span data-slate-string="true">在第 3 讲中，我们讲了哈希表解决哈希冲突的两种常用方法：开放寻址法和链表法。开放寻址法中有一个优化方案叫“双散列”，它的原理是使用多个哈希函数来解决冲突问题。我们能否借鉴这个思想，在位图的场景下使用多个哈希函数来降低冲突概率呢？没错，这其实就是布隆过滤器（Bloom 
Filter）的设计思想。</span></span></span> </div> <div class="se-622f7d96 " data-slate-type="paragraph" 
data-slate-object="block" data-key="1257"> <span data-slate-object="text" data-key="1258"><span 
data-slate-leaf="true" data-offset-key="1258:0" data-first-offset="true"><span data-slate-string="true">布隆过滤器最大的特点，就是对一个对象使用多个哈希函数。如果我们使用了 
k 个哈希函数，就会得到 k 个哈希值，也就是 k 个下标，我们会把数组中对应下标位置的值都置为 1。布隆过滤器和位图最大的区别就在于，我们不再使用一位来表示一个对象，而是使用 k 
位来表示一个对象。这样两个对象的 k 位都相同的概率就会大大降低，从而能够解决哈希冲突的问题了。</span></span></span> </div> <div class="se-ed4974cf" 
data-slate-type="image" data-slate-object="block" data-key="1259"> <img class="se-5d8dc332" 
src="https://static001.geekbang.org/resource/image/08/cb/089de1531a75731a657ae2c6e55c55cb.jpg"> 
</div> <div class="se-9911d446 se-96813674" data-slate-type="paragraph" data-slate-object="block" 
data-key="1260"> <span data-slate-object="text" data-key="1261"><span data-slate-leaf="true" 
data-offset-key="1261:0" data-first-offset="true"><span class="se-76c2338e" data-slate-type="secondary" 
data-slate-object="mark"><span data-slate-string="true">Bloom filter 示例</span></span></span></span> 
</div> <div class="se-7c405673 " data-slate-type="paragraph" data-slate-object="block" data-key="1262"> 
<span data-slate-object="text" data-key="1263"><span data-slate-leaf="true" data-offset-key="1263:0" 
data-first-offset="true"><span data-slate-string="true">但是，布隆过滤器的查询有一个特点，就是即使任何两个元素的哈希值不冲突，而且我们查询对象的 
k 个位置的值都是 1，查询结果为存在，这个结果也可能是错误的。这就叫作</span></span></span><span data-slate-object="text" data-key="1264"><span 
data-slate-leaf="true" data-offset-key="1264:0" data-first-offset="true"><span class="se-f1a518fa" 
data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">布隆过滤器的错误率</span></span></span></span><span 
data-slate-object="text" data-key="1265"><span data-slate-leaf="true" data-offset-key="1265:0" 
data-first-offset="true"><span data-slate-string="true">。</span></span></span> </div> <div 
class="se-98877110 " data-slate-type="paragraph" data-slate-object="block" data-key="1266"> 
<span data-slate-object="text" data-key="1267"><span data-slate-leaf="true" data-offset-key="1267:0" 
data-first-offset="true"><span data-slate-string="true">我在下图给出了一个例子。我们可以看到，布隆过滤器中存储了 x 和 y 
两个对象，它们对应的 bit 位被置为 1。当我们查询一个不存在的对象 z 时，如果 z 的 k 个哈希值的对应位置的值正好都是 1，z 就会被错误地认定为存在。而且，这个时候，z 
和 x，以及 z 和 y，两两之间也并没有发生哈希冲突。</span></span></span> </div> <div class="se-512d19a7" data-slate-type="image" 
data-slate-object="block" data-key="1268"> <img class="se-5d38d4d1" src="https://static001.geekbang.org/resource/image/7f/26/7f9a98a2e877b298c0be5b5c7b8a5626.jpg"> 
</div> <div class="se-f282e2da se-248d60c2" data-slate-type="paragraph" data-slate-object="block" 
data-key="1269"> <span data-slate-object="text" data-key="1270"><span data-slate-leaf="true" 
data-offset-key="1270:0" data-first-offset="true"><span class="se-76c2338e" data-slate-type="secondary" 
data-slate-object="mark"><span data-slate-string="true">Bloom filter 错误率示例</span></span></span></span> 
</div> <div class="se-07236523 " data-slate-type="paragraph" data-slate-object="block" data-key="1271"> 
<span data-slate-object="text" data-key="1272"><span data-slate-leaf="true" data-offset-key="1272:0" 
data-first-offset="true"><span data-slate-string="true">那遇到“可能存在”这样的情况，我们该怎么办呢？不要忘了我们的使用场景：我们希望用更小的代价快速判断 
ID 是否已经被注册了。在这个使用场景中，就算我们无法确认 ID 是否已经被注册了，让用户再换一个 ID 注册，这也不会损害新用户的体验。在系统不要求结果 100% 准确的情况下，我们可以直接当作这个用户 
ID 已经被注册了就可以了。这样，我们使用布隆过滤器就可以快速完成“是否存在”的检索。</span></span></span> </div> <div class="se-4cc9ba64 
" data-slate-type="paragraph" data-slate-object="block" data-key="1273"> <span data-slate-object="text" 
data-key="1274"><span data-slate-leaf="true" data-offset-key="1274:0" data-first-offset="true"><span 
data-slate-string="true">除此之外，对于布隆过滤器而言，如果哈希函数的个数不合理，比如哈希函数特别多，布隆过滤器的错误率就会变大。因此，除了使用多个哈希函数避免哈希冲突以外，我们还要控制布隆过滤器中哈希函数的个数。有这样一个</span></span></span><span 
data-slate-object="text" data-key="1275"><span data-slate-leaf="true" data-offset-key="1275:0" 
data-first-offset="true"><span class="se-3d6fca76" data-slate-type="bold" data-slate-object="mark"><span 
data-slate-string="true">计算最优哈希函数个数的数学公式: 哈希函数个数 k = (m/n) * ln(2)</span></span></span></span><span 
data-slate-object="text" data-key="1276"><span data-slate-leaf="true" data-offset-key="1276:0" 
data-first-offset="true"><span data-slate-string="true">。其中 m 为 bit 数组长度，n 为要存入的对象的个数。实际上，如果哈希函数个数为 
1，且数组长度足够，布隆过滤器就可以退化成一个位图。所以，我们可以认为“</span></span></span><span data-slate-object="text" data-key="1277"><span 
data-slate-leaf="true" data-offset-key="1277:0" data-first-offset="true"><span class="se-315bff0a" 
data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">位图是只有一个特殊的哈希函数，且没有被压缩长度的布隆过滤器</span></span></span></span><span 
data-slate-object="text" data-key="1278"><span data-slate-leaf="true" data-offset-key="1278:0" 
data-first-offset="true"><span data-slate-string="true">”。</span></span></span> </div> <h2 
class="se-6aeb7649" data-slate-type="heading" data-slate-object="block" data-key="1279"><span 
data-slate-object="text" data-key="1280"><span data-slate-leaf="true" data-offset-key="1280:0" 
data-first-offset="true"><span data-slate-string="true">重点回顾</span></span></span></h2> <div 
class="se-8c227b03 " data-slate-type="paragraph" data-slate-object="block" data-key="1281"> 
<span data-slate-object="text" data-key="1282"><span data-slate-leaf="true" data-offset-key="1282:0" 
data-first-offset="true"><span data-slate-string="true">好了，状态检索的内容我们就讲到这里。我们一起来总结一下，这一讲你要掌握的重点内容。</span></span></span> 
</div> <div class="se-0c5d58e2 " data-slate-type="paragraph" data-slate-object="block" data-key="1283"> 
<span data-slate-object="text" data-key="1284"><span data-slate-leaf="true" data-offset-key="1284:0" 
data-first-offset="true"><span data-slate-string="true">今天，我们主要解决了快速判断一个对象是否存在的问题。相比于有序数组、二叉检索树和哈希表这三种方案，位图和布隆过滤器其实更适合解决这类状态检索的问题。这是因为，在不要求 
100% 判断正确的情况下，使用位图和布隆过滤器可以达到 O(1) 时间代价的检索效率，同时空间使用率也非常高效。</span></span></span> </div> <div 
class="se-7222c6e4 " data-slate-type="paragraph" data-slate-object="block" data-key="1285"> 
<span data-slate-object="text" data-key="1286"><span data-slate-leaf="true" data-offset-key="1286:0" 
data-first-offset="true"><span data-slate-string="true">虽然位图和布隆过滤器的原理和实现都非常简单，但是在许多复杂的大型系统中都可以见到它们的身影。</span></span></span> 
</div> <div class="se-9f5f865c " data-slate-type="paragraph" data-slate-object="block" data-key="1287"> 
<span data-slate-object="text" data-key="1288"><span data-slate-leaf="true" data-offset-key="1288:0" 
data-first-offset="true"><span data-slate-string="true">比如，存储系统中的数据是存储在磁盘中的，而磁盘中的检索效率非常低，因此，我们往往会先使用内存中的布隆过滤器来快速判断数据是否存在，不存在就直接返回，只有可能存在才会去磁盘检索，这样就避免了为无效数据读取磁盘的额外开销。</span></span></span> 
</div> <div class="se-9cad4472 " data-slate-type="paragraph" data-slate-object="block" data-key="1289"> 
<span data-slate-object="text" data-key="1290"><span data-slate-leaf="true" data-offset-key="1290:0" 
data-first-offset="true"><span data-slate-string="true">再比如，在搜索引擎中，我们也需要使用布隆过滤器快速判断网站是否已经被抓取过，如果一定不存在，我们就直接去抓取；如果可能存在，那我们可以根据需要，直接放弃抓取或者再次确认是否需要抓取。</span></span></span><span 
data-slate-object="text" data-key="1291"><span data-slate-leaf="true" data-offset-key="1291:0" 
data-first-offset="true"><span class="se-e9d4dd2a" data-slate-type="bold" data-slate-object="mark"><span 
data-slate-string="true">你会发现，这种快速预判断的思想，也是提高应用整体检索性能的一种常见设计思路。</span></span></span></span> 
</div> <h2 class="se-758f3f92" data-slate-type="heading" data-slate-object="block" data-key="1292"><span 
data-slate-object="text" data-key="1293"><span data-slate-leaf="true" data-offset-key="1293:0" 
data-first-offset="true"><span data-slate-string="true">课堂讨论</span></span></span></h2> <div 
class="se-02c98706 " data-slate-type="paragraph" data-slate-object="block" data-key="1294"> 
<span data-slate-object="text" data-key="1295"><span data-slate-leaf="true" data-offset-key="1295:0" 
data-first-offset="true"><span data-slate-string="true">这节课的内容，你可以结合这道讨论题进一步加深理解：</span></span></span> 
</div> <div class="se-8d42e9d7 " data-slate-type="paragraph" data-slate-object="block" data-key="1296"> 
<span data-slate-object="text" data-key="1297"><span data-slate-leaf="true" data-offset-key="1297:0" 
data-first-offset="true"><span data-slate-string="true">如果位图中一个元素被删除了，我们可以将对应 bit 位置为 0。但如果布隆过滤器中一个元素被删除了，我们直接将对应的 
k 个 bit 位置为 0，会产生什么样的问题呢？为什么？</span></span></span> </div> <div class="se-34fd5358 " data-slate-type="paragraph" 
data-slate-object="block" data-key="1298"> <span data-slate-object="text" data-key="1299"><span 
data-slate-leaf="true" data-offset-key="1299:0" data-first-offset="true"><span data-slate-string="true">欢迎在留言区畅所欲言，说出你的思考过程和最终答案。如果有收获，也欢迎把这篇文章分享给你的朋友。</span></span></span> 
</div> </div>', body_summary='', bundle='book', delta=0, body_format='full_html', langcode='zh-hans', 
revision_id=1154 where entity_id=1154 
 {executed in 1 msec}
2020-11-25 10:32:07.415 INFO  jdbc.sqltiming Line:373 - select nodefiledd0_.nid as nid1_10_, nodefiledd0_.changed as changed2_10_, nodefiledd0_.created 
as created3_10_, nodefiledd0_.default_langcode as default_4_10_, nodefiledd0_.langcode as langcode5_10_, 
nodefiledd0_.promote as promote6_10_, nodefiledd0_.revision_translation_affected as revision7_10_, 
nodefiledd0_.status as status8_10_, nodefiledd0_.sticky as sticky9_10_, nodefiledd0_.title 
as title10_10_, nodefiledd0_.type as type11_10_, nodefiledd0_.uid as uid12_10_, nodefiledd0_.vid 
as vid13_10_ from node_field_data nodefiledd0_ where nodefiledd0_.nid=1154 
 {executed in 1 msec}
2020-11-25 10:32:07.415 INFO  jdbc.resultsettable Line:610 - 
|-----|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|------------------------|-----|----|-----|
|nid  |changed    |created    |default_langcode |langcode |promote |revision_translation_affected |status |sticky |title                   |type |uid |vid  |
|-----|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|------------------------|-----|----|-----|
|1154 |1606264760 |1606264760 |1                |zh-hans  |0       |1                             |1      |0      |04丨状态检索：如何快速判断一个用户是否存在？ |book |1   |1154 |
|-----|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|------------------------|-----|----|-----|

2020-11-25 10:32:07.416 INFO  jdbc.sqltiming Line:373 - select nodefieldr0_.nid as nid1_11_0_, nodefieldr0_.changed as changed2_11_0_, nodefieldr0_.created 
as created3_11_0_, nodefieldr0_.default_langcode as default_4_11_0_, nodefieldr0_.langcode 
as langcode5_11_0_, nodefieldr0_.promote as promote6_11_0_, nodefieldr0_.revision_translation_affected 
as revision7_11_0_, nodefieldr0_.status as status8_11_0_, nodefieldr0_.sticky as sticky9_11_0_, 
nodefieldr0_.title as title10_11_0_, nodefieldr0_.uid as uid11_11_0_, nodefieldr0_.vid as vid12_11_0_ 
from node_field_revision nodefieldr0_ where nodefieldr0_.nid=1154 
 {executed in 0 msec}
2020-11-25 10:32:07.416 INFO  jdbc.resultsettable Line:610 - 
|---------|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|------------------------|----|-----|
|nid      |changed    |created    |default_langcode |langcode |promote |revision_translation_affected |status |sticky |title                   |uid |vid  |
|---------|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|------------------------|----|-----|
|[unread] |1606264760 |1606264760 |1                |zh-hans  |0       |1                             |1      |0      |04丨状态检索：如何快速判断一个用户是否存在？ |1   |1154 |
|---------|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|------------------------|----|-----|

2020-11-25 10:32:07.418 INFO  jdbc.sqltiming Line:373 - update node_field_data set changed=1606271527, created=1606271527, default_langcode=1, langcode='zh-hans', 
promote=0, revision_translation_affected=1, status=1, sticky=0, title='04丨状态检索：如何快速判断一个用户是否存在？', 
type='book', uid=1, vid=1154 where nid=1154 
 {executed in 0 msec}
2020-11-25 10:32:07.418 INFO  jdbc.sqltiming Line:373 - update node_field_revision set changed=1606271527, created=1606271527, default_langcode=1, 
langcode='zh-hans', promote=0, revision_translation_affected=1, status=1, sticky=0, title='04丨状态检索：如何快速判断一个用户是否存在？', 
uid=1, vid=1154 where nid=1154 
 {executed in 0 msec}
2020-11-25 10:32:07.422 INFO  jdbc.sqltiming Line:373 - select bookfieldm0_.entity_id as entity_i1_8_, bookfieldm0_.bundle as bundle2_8_, bookfieldm0_.delta 
as delta3_8_, bookfieldm0_.langcode as langcode4_8_, bookfieldm0_.field_media_value as field_me5_8_, 
bookfieldm0_.revision_id as revision6_8_ from node__field_media bookfieldm0_ where bookfieldm0_.entity_id=1154 
 {executed in 0 msec}
2020-11-25 10:32:07.423 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------------|------------|
|entity_id |bundle |delta |langcode |field_media_value |revision_id |
|----------|-------|------|---------|------------------|------------|
|1154      |book   |0     |zh-hans  |                  |1154        |
|----------|-------|------|---------|------------------|------------|

2020-11-25 10:32:07.424 INFO  jdbc.sqltiming Line:373 - select nodefieldm0_.entity_id as entity_i1_17_0_, nodefieldm0_.bundle as bundle2_17_0_, nodefieldm0_.delta 
as delta3_17_0_, nodefieldm0_.langcode as langcode4_17_0_, nodefieldm0_.field_media_value as 
field_me5_17_0_, nodefieldm0_.revision_id as revision6_17_0_ from node_revision__field_media 
nodefieldm0_ where nodefieldm0_.entity_id=1154 
 {executed in 0 msec}
2020-11-25 10:32:07.425 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------------|------------|
|entity_id |bundle |delta |langcode |field_media_value |revision_id |
|----------|-------|------|---------|------------------|------------|
|[unread]  |book   |0     |zh-hans  |                  |1154        |
|----------|-------|------|---------|------------------|------------|

2020-11-25 10:32:07.427 INFO  jdbc.sqltiming Line:373 - select bookfieldc0_.entity_id as entity_i1_5_, bookfieldc0_.bundle as bundle2_5_, bookfieldc0_.field_comment_value 
as field_co3_5_, bookfieldc0_.delta as delta4_5_, bookfieldc0_.field_comment_format as field_co5_5_, 
bookfieldc0_.langcode as langcode6_5_, bookfieldc0_.revision_id as revision7_5_ from node__field_comment 
bookfieldc0_ where bookfieldc0_.entity_id=1154 
 {executed in 1 msec}
2020-11-25 10:32:07.427 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|--------------------|------|---------------------|---------|------------|
|entity_id |bundle |field_comment_value |delta |field_comment_format |langcode |revision_id |
|----------|-------|--------------------|------|---------------------|---------|------------|
|1154      |book   |                    |0     |full_html            |zh-hans  |1154        |
|----------|-------|--------------------|------|---------------------|---------|------------|

2020-11-25 10:32:07.429 INFO  jdbc.sqltiming Line:373 - update node__field_comment set bundle='book', field_comment_value='<li class="reJj6Thl_0"><img 
src="https://static001.geekbang.org/account/avatar/00/14/0f/53/92a50f01.jpg" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <a>徐洲更</a> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-30 </div> </div> <!----> </div> <div> <div 
class="_3M6kV3zb_0"> 因为同一个ID经过哈希函数会得到多个位置，不同的ID可能会有一些位置overlap。如果ID A和B刚好有一个位置重合，那么删除A的时候，如果直接将它对应的位置清零，就导致B也被认为是不存在。因此bloom 
filter删除操作很麻烦 </div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> 
<div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 是的。bloom filter的删除会很麻烦。我们一般用在数据不删除的场景中（比如文中举的注册ID的场景）。<br>如果真要删除，可以使用上一课提到的re－hash的思路重新生成。（因为bloom 
filter本来就允许错误率，因此可以周期性重新生成）。<br>此外，还可以将bloomfilter改造成带引用计数的。</p> </div> <div class="_1w8H0ktn_0 
_2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> <span>1</span> </div> <div 
class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">2</span> </div> <!----> </div> 
</div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/10/1d/13/31ea1b0b.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>峰</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-30 </div> </div> <!----> </div> <div> 
<div class="_3M6kV3zb_0"> bitmap 是一个集合，每个元素在集合中有一个唯一不冲突的编号(用户自己保证，在数据库中这个编号可以是行号)，是双射关系。而布隆过滤器是一个不准确的集合，而且是一对多的关系，会发生冲突，也就是说布隆过滤器的为1的位可能代表多个元素，自然不能因为一个元素删除就把它干掉？，或者说他就不支持删除操作，感觉它要支持了，反而把它本身的优势给丢了。 
<br> <br>1，其实对布隆过滤器是省了空间，我表示持怀疑态度，可能需要证明下，我可能更多的认为它是一种平衡单个hash 函数对数据分布有偏差性导致最差情况的数据冲突的概率大的一种方法。 
<br>2，bitmap 本身也有很多压缩方法，最有名的应该是roaringbitmap ，大家有兴趣可以了解下。 <br> </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 
你的思考很深入！<br>1.对于布隆过滤器的删除问题，的确无法直接删除。但也有带引用计数的布隆过滤器，存的不是0，1，而是一个计数。其实所有的设计都是trade off。应该视具体使用场景而定。比如一个带4个bit位计数器的布隆过滤器，相比于哈希表依然有优势。<br>2.布隆过滤器是否省空间，要看怎么比较。<br>布隆过滤器 
vs 原始位图:<br>原始位图要存一个int 32的数，就要先准备好512m的空间的长数组。布隆过滤器不用这么长的数组，因此比原始位图省空间。<br>布隆过滤器 vs 哈希表:<br>假设布隆过滤器数组长度和哈希表一样。但是哈希表存的是一个int 
32，而布隆过滤器存的是一个bit，因此比同样长度的哈希表省空间。<br>当然，如果哈希表也改为只存一个bit的数组，那么他们的大小是一样的。这时候就是你说的多个哈希函数的作用场景了。<br>其实，你会发现，只存一个bit的哈希表，其实也可以看做是只有一个哈希函数的布隆过滤器。很多时候，布隆过滤器，哈希表，还有位图，它们的边界是模糊的。我们最重要的是了解清楚他们的特点，知道在什么场景用哪种结构就好了。<br>3.roaring 
bitmap是一个优秀的设计。我在基础篇的加餐中会和大家分享。在这里，我也说一下它和布隆过滤器的差异:<br>布隆过滤器 vs roaring bitmap:<br>所有的设计都是trade 
off。roaring bitmap尽管压缩率很高，还支持精准查找，但是它放弃的是速度。高16位是采用二分查找，array container也是二分查找。因此，在这一点上布隆过滤器是有优势的。此外，它还不能保证压缩空间，它的空间会随着元素增多而变大，极端情况下恢复回bitmap。<br>而布隆过滤器保持了高效的查找能力和空间控制能力，但是放弃了精准查找能力，精准度会随着元素增多而下降。<br>因此，尽管都是对bitmap进行压缩，但是两者的设计思路不一样，使用场景也不同。在不要求精准，但是要求快速和省空间的场景下，布隆过滤器是不错的选择。</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">2</span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/14/9b/d0/86aee34c.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>刘凯</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-30 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 增加可以容忍误判，错误的判断用户存在，换个账号注册就行了，那么删除也会存在误判，可能将真正的用户没有删除掉，这可就不可取了，老师，我蒙对没，算法好头疼 
</div> <!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 你可以看我文中的例子想一想，x和y有共同的位，因此，如果删除x时，把x对应的3个bit位都改为0，就会影响y的查询。因此，对于布隆过滤器，不能直接删除。<br>一般来说，我们可以周期性重建布隆过滤器解决这个问题。<br>算法是不容易。但是不着急，慢慢来，一步一步扎扎实实学，你会收获得更多。</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>一步</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-30 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 位图 一个位置就只有一个元素使用，布隆过滤器一个位置可能多个元素都会使用 </div> <!----> 
<div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 是的。所以布隆过滤器不能直接删除。如果真的发生了删除，可以用类似re－hash的机制重新生成。<br>此外，一些场景会将布隆过滤器改造为带引用计数的结构。通过一个小数值的count进行计数。</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLEGtB7lUzH66b3nibVu3Xat4C0Wfp0umU3slsN32TF3icBwDOpShgdzMhaLW9z5LDFg3TTh0H62qAA/132" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>千里之行</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-30 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 会造成其他元素存在状态的错误判断，因为多个对象可能共用一个元素。但是极端情况下，甚至有可能一个对象对应的K个元素都与其他对象共用，这种情况下不知道该怎么办了，请老师帮忙解答一下，谢谢 
</div> <!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 的确，一般来说布隆过滤器是不能直接删除的。它适用于数据不删除的场景（比如文中举的注册id的场景）。如果真有删除需求，可以像前一课学过的re－hash一样，重新生成。<br>此外，删除频繁的场景下，还可以将布隆过滤器带上计数器。就是将一个bit改为4个bit，可以存一个数。<br>尽管空间变大了，但是依然比哈希表存一个int 
32的元素更省空间。</p> </div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/14/1c/71/2f52da16.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>努力努力再努力Xmn</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-30 </div> </div> <!----> 
</div> <div> <div class="_3M6kV3zb_0"> 对于布隆过滤器，删除元素时如果将对应的k个元素全部设置为0的话，会影响其他元素的判断，我想到一个方法，就是对于每一个数组中每一位，再设置一个标志count，用于记录出现1得次数，删除元素时将count减1，如果count为0的话，再将1设置为0。但是这样做的话，存储count不是又需要花费存储空间，这与布隆过滤器的设计目的不就冲突了吗？想知道布隆过滤器对于删除元素时如何实现的？希望老师解答。 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 布隆过滤器的确是无法直接删除的。要删除的话，有两种思路，一种就是重新生成（和re－hash一个思路）。另一种就是你说的引用计数。<br>其实引用计数是可行的。它的确性能会比原始的布隆过滤器差，但依然好于哈希表。因为我们对于引用计数，完全可以用少数几个bit位来记录，比如说4个比特位就能记录到16。<br>这样的存一个4bit计数值的布隆过滤器，依然会比存int 
32的哈希表更省空间。<br>所有的设计都是要根据具体场景灵活变通。因此，如果应用场景真的有频繁删除的需求，那么这样一种结构也是可以考虑的。</p> </div> <div class="_1w8H0ktn_0 
_2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> <span>1</span> </div> <div 
class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> </div> 
</div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/10/5f/e5/54325854.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>范闲</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-30 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0"> 1.bitmap和bloomfilter都是为了判断状态存在的。 <br>2.bitmap只有一个位置用来判断状态 <br>3.bloomfilter有多个位置用来判断状态 
<br>4.针对bloomfilter来说若果不所在一定不存在，存在不一定存在(因为hash冲突，可能是另外的元素状态) <br>5.如何根据用户数量来确定bitmap或者bloomfilter的bit数组的大小呢？ 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 总结得很好！<br>对于第五个问题，如何确定大小:<br>如果是原始位图，假设id是int 32，如果你不清楚数值分布范围，那么只能覆盖所有int 
32的取值区间。这时候的位图大小是512m。<br>如果是布隆过滤器，你需要预估你的用户数量，<br>此外，还要设置一个你能接受的错误率p，使用这个公式:m =－n ln p / （ln 
2）^2 ，可以算出来bit 位数组m的大小。<br></p> </div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> 
<i class="iconfont"></i> <span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> 
<span class=""></span> </div> <!----> </div> </div> </div></li>', delta=0, field_comment_format='full_html', 
langcode='zh-hans', revision_id=1154 where entity_id=1154 
 {executed in 0 msec}
2020-11-25 10:32:07.432 INFO  jdbc.sqltiming Line:373 - select nodefieldc0_.entity_id as entity_i1_14_0_, nodefieldc0_.bundle as bundle2_14_0_, nodefieldc0_.field_comment_value 
as field_co3_14_0_, nodefieldc0_.delta as delta4_14_0_, nodefieldc0_.field_comment_format as 
field_co5_14_0_, nodefieldc0_.langcode as langcode6_14_0_, nodefieldc0_.revision_id as revision7_14_0_ 
from node_revision__field_comment nodefieldc0_ where nodefieldc0_.entity_id=1154 
 {executed in 0 msec}
2020-11-25 10:32:07.433 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|--------------------|------|---------------------|---------|------------|
|entity_id |bundle |field_comment_value |delta |field_comment_format |langcode |revision_id |
|----------|-------|--------------------|------|---------------------|---------|------------|
|[unread]  |book   |                    |0     |full_html            |zh-hans  |1154        |
|----------|-------|--------------------|------|---------------------|---------|------------|

2020-11-25 10:32:07.435 INFO  jdbc.sqltiming Line:373 - update node_revision__field_comment set bundle='book', field_comment_value='<li class="reJj6Thl_0"><img 
src="https://static001.geekbang.org/account/avatar/00/14/0f/53/92a50f01.jpg" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <a>徐洲更</a> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-30 </div> </div> <!----> </div> <div> <div 
class="_3M6kV3zb_0"> 因为同一个ID经过哈希函数会得到多个位置，不同的ID可能会有一些位置overlap。如果ID A和B刚好有一个位置重合，那么删除A的时候，如果直接将它对应的位置清零，就导致B也被认为是不存在。因此bloom 
filter删除操作很麻烦 </div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> 
<div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 是的。bloom filter的删除会很麻烦。我们一般用在数据不删除的场景中（比如文中举的注册ID的场景）。<br>如果真要删除，可以使用上一课提到的re－hash的思路重新生成。（因为bloom 
filter本来就允许错误率，因此可以周期性重新生成）。<br>此外，还可以将bloomfilter改造成带引用计数的。</p> </div> <div class="_1w8H0ktn_0 
_2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> <span>1</span> </div> <div 
class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">2</span> </div> <!----> </div> 
</div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/10/1d/13/31ea1b0b.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>峰</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-30 </div> </div> <!----> </div> <div> 
<div class="_3M6kV3zb_0"> bitmap 是一个集合，每个元素在集合中有一个唯一不冲突的编号(用户自己保证，在数据库中这个编号可以是行号)，是双射关系。而布隆过滤器是一个不准确的集合，而且是一对多的关系，会发生冲突，也就是说布隆过滤器的为1的位可能代表多个元素，自然不能因为一个元素删除就把它干掉？，或者说他就不支持删除操作，感觉它要支持了，反而把它本身的优势给丢了。 
<br> <br>1，其实对布隆过滤器是省了空间，我表示持怀疑态度，可能需要证明下，我可能更多的认为它是一种平衡单个hash 函数对数据分布有偏差性导致最差情况的数据冲突的概率大的一种方法。 
<br>2，bitmap 本身也有很多压缩方法，最有名的应该是roaringbitmap ，大家有兴趣可以了解下。 <br> </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 
你的思考很深入！<br>1.对于布隆过滤器的删除问题，的确无法直接删除。但也有带引用计数的布隆过滤器，存的不是0，1，而是一个计数。其实所有的设计都是trade off。应该视具体使用场景而定。比如一个带4个bit位计数器的布隆过滤器，相比于哈希表依然有优势。<br>2.布隆过滤器是否省空间，要看怎么比较。<br>布隆过滤器 
vs 原始位图:<br>原始位图要存一个int 32的数，就要先准备好512m的空间的长数组。布隆过滤器不用这么长的数组，因此比原始位图省空间。<br>布隆过滤器 vs 哈希表:<br>假设布隆过滤器数组长度和哈希表一样。但是哈希表存的是一个int 
32，而布隆过滤器存的是一个bit，因此比同样长度的哈希表省空间。<br>当然，如果哈希表也改为只存一个bit的数组，那么他们的大小是一样的。这时候就是你说的多个哈希函数的作用场景了。<br>其实，你会发现，只存一个bit的哈希表，其实也可以看做是只有一个哈希函数的布隆过滤器。很多时候，布隆过滤器，哈希表，还有位图，它们的边界是模糊的。我们最重要的是了解清楚他们的特点，知道在什么场景用哪种结构就好了。<br>3.roaring 
bitmap是一个优秀的设计。我在基础篇的加餐中会和大家分享。在这里，我也说一下它和布隆过滤器的差异:<br>布隆过滤器 vs roaring bitmap:<br>所有的设计都是trade 
off。roaring bitmap尽管压缩率很高，还支持精准查找，但是它放弃的是速度。高16位是采用二分查找，array container也是二分查找。因此，在这一点上布隆过滤器是有优势的。此外，它还不能保证压缩空间，它的空间会随着元素增多而变大，极端情况下恢复回bitmap。<br>而布隆过滤器保持了高效的查找能力和空间控制能力，但是放弃了精准查找能力，精准度会随着元素增多而下降。<br>因此，尽管都是对bitmap进行压缩，但是两者的设计思路不一样，使用场景也不同。在不要求精准，但是要求快速和省空间的场景下，布隆过滤器是不错的选择。</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">2</span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/14/9b/d0/86aee34c.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>刘凯</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-30 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 增加可以容忍误判，错误的判断用户存在，换个账号注册就行了，那么删除也会存在误判，可能将真正的用户没有删除掉，这可就不可取了，老师，我蒙对没，算法好头疼 
</div> <!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 你可以看我文中的例子想一想，x和y有共同的位，因此，如果删除x时，把x对应的3个bit位都改为0，就会影响y的查询。因此，对于布隆过滤器，不能直接删除。<br>一般来说，我们可以周期性重建布隆过滤器解决这个问题。<br>算法是不容易。但是不着急，慢慢来，一步一步扎扎实实学，你会收获得更多。</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>一步</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-30 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 位图 一个位置就只有一个元素使用，布隆过滤器一个位置可能多个元素都会使用 </div> <!----> 
<div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 是的。所以布隆过滤器不能直接删除。如果真的发生了删除，可以用类似re－hash的机制重新生成。<br>此外，一些场景会将布隆过滤器改造为带引用计数的结构。通过一个小数值的count进行计数。</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLEGtB7lUzH66b3nibVu3Xat4C0Wfp0umU3slsN32TF3icBwDOpShgdzMhaLW9z5LDFg3TTh0H62qAA/132" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>千里之行</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-30 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 会造成其他元素存在状态的错误判断，因为多个对象可能共用一个元素。但是极端情况下，甚至有可能一个对象对应的K个元素都与其他对象共用，这种情况下不知道该怎么办了，请老师帮忙解答一下，谢谢 
</div> <!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 的确，一般来说布隆过滤器是不能直接删除的。它适用于数据不删除的场景（比如文中举的注册id的场景）。如果真有删除需求，可以像前一课学过的re－hash一样，重新生成。<br>此外，删除频繁的场景下，还可以将布隆过滤器带上计数器。就是将一个bit改为4个bit，可以存一个数。<br>尽管空间变大了，但是依然比哈希表存一个int 
32的元素更省空间。</p> </div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/14/1c/71/2f52da16.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>努力努力再努力Xmn</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-30 </div> </div> <!----> 
</div> <div> <div class="_3M6kV3zb_0"> 对于布隆过滤器，删除元素时如果将对应的k个元素全部设置为0的话，会影响其他元素的判断，我想到一个方法，就是对于每一个数组中每一位，再设置一个标志count，用于记录出现1得次数，删除元素时将count减1，如果count为0的话，再将1设置为0。但是这样做的话，存储count不是又需要花费存储空间，这与布隆过滤器的设计目的不就冲突了吗？想知道布隆过滤器对于删除元素时如何实现的？希望老师解答。 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 布隆过滤器的确是无法直接删除的。要删除的话，有两种思路，一种就是重新生成（和re－hash一个思路）。另一种就是你说的引用计数。<br>其实引用计数是可行的。它的确性能会比原始的布隆过滤器差，但依然好于哈希表。因为我们对于引用计数，完全可以用少数几个bit位来记录，比如说4个比特位就能记录到16。<br>这样的存一个4bit计数值的布隆过滤器，依然会比存int 
32的哈希表更省空间。<br>所有的设计都是要根据具体场景灵活变通。因此，如果应用场景真的有频繁删除的需求，那么这样一种结构也是可以考虑的。</p> </div> <div class="_1w8H0ktn_0 
_2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> <span>1</span> </div> <div 
class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> </div> <!----> </div> 
</div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/10/5f/e5/54325854.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>范闲</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-03-30 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0"> 1.bitmap和bloomfilter都是为了判断状态存在的。 <br>2.bitmap只有一个位置用来判断状态 <br>3.bloomfilter有多个位置用来判断状态 
<br>4.针对bloomfilter来说若果不所在一定不存在，存在不一定存在(因为hash冲突，可能是另外的元素状态) <br>5.如何根据用户数量来确定bitmap或者bloomfilter的bit数组的大小呢？ 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 总结得很好！<br>对于第五个问题，如何确定大小:<br>如果是原始位图，假设id是int 32，如果你不清楚数值分布范围，那么只能覆盖所有int 
32的取值区间。这时候的位图大小是512m。<br>如果是布隆过滤器，你需要预估你的用户数量，<br>此外，还要设置一个你能接受的错误率p，使用这个公式:m =－n ln p / （ln 
2）^2 ，可以算出来bit 位数组m的大小。<br></p> </div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> 
<i class="iconfont"></i> <span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> 
<span class=""></span> </div> <!----> </div> </div> </div></li>', delta=0, field_comment_format='full_html', 
langcode='zh-hans', revision_id=1154 where entity_id=1154 
 {executed in 0 msec}
2020-11-25 10:32:07.437 INFO  jdbc.sqltiming Line:373 - select bookfieldt0_.entity_id as entity_i1_9_, bookfieldt0_.bundle as bundle2_9_, bookfieldt0_.delta 
as delta3_9_, bookfieldt0_.langcode as langcode4_9_, bookfieldt0_.revision_id as revision5_9_, 
bookfieldt0_.field_thumb_value as field_th6_9_ from node__field_thumb bookfieldt0_ where bookfieldt0_.entity_id=1154 
 {executed in 0 msec}
2020-11-25 10:32:07.438 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------|------------------|
|entity_id |bundle |delta |langcode |revision_id |field_thumb_value |
|----------|-------|------|---------|------------|------------------|
|1154      |book   |0     |zh-hans  |1154        |                  |
|----------|-------|------|---------|------------|------------------|

2020-11-25 10:32:07.439 INFO  jdbc.sqltiming Line:373 - update node__field_thumb set bundle='book', delta=0, langcode='zh-hans', revision_id=1154, 
field_thumb_value='https://static001.geekbang.org/resource/image/b0/99/b0229dd2fbd90ff148b2dc2894a8b599.jpg' 
where entity_id=1154 
 {executed in 0 msec}
2020-11-25 10:32:07.442 INFO  jdbc.sqltiming Line:373 - select nodefieldt0_.entity_id as entity_i1_18_0_, nodefieldt0_.bundle as bundle2_18_0_, nodefieldt0_.delta 
as delta3_18_0_, nodefieldt0_.langcode as langcode4_18_0_, nodefieldt0_.revision_id as revision5_18_0_, 
nodefieldt0_.field_thumb_value as field_th6_18_0_ from node_revision__field_thumb nodefieldt0_ 
where nodefieldt0_.entity_id=1154 
 {executed in 0 msec}
2020-11-25 10:32:07.442 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------|------------------|
|entity_id |bundle |delta |langcode |revision_id |field_thumb_value |
|----------|-------|------|---------|------------|------------------|
|[unread]  |book   |0     |zh-hans  |1154        |                  |
|----------|-------|------|---------|------------|------------------|

2020-11-25 10:32:07.444 INFO  jdbc.sqltiming Line:373 - update node_revision__field_thumb set bundle='book', delta=0, langcode='zh-hans', revision_id=1154, 
field_thumb_value='https://static001.geekbang.org/resource/image/b0/99/b0229dd2fbd90ff148b2dc2894a8b599.jpg' 
where entity_id=1154 
 {executed in 0 msec}
2020-11-25 10:32:07.447 INFO  jdbc.sqltiming Line:373 - select bookfieldf0_.entity_id as entity_i1_6_0_, bookfieldf0_.bundle as bundle2_6_0_, bookfieldf0_.delta 
as delta3_6_0_, bookfieldf0_.field_fenlei_target_id as field_fe4_6_0_, bookfieldf0_.langcode 
as langcode5_6_0_, bookfieldf0_.revision_id as revision6_6_0_ from node__field_fenlei bookfieldf0_ 
where bookfieldf0_.entity_id=1154 
 {executed in 1 msec}
2020-11-25 10:32:07.447 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|-----------------------|---------|------------|
|entity_id |bundle |delta |field_fenlei_target_id |langcode |revision_id |
|----------|-------|------|-----------------------|---------|------------|
|[unread]  |book   |0     |1                      |zh-hans  |1154        |
|----------|-------|------|-----------------------|---------|------------|

2020-11-25 10:32:07.449 INFO  jdbc.sqltiming Line:373 - select nodefieldf0_.entity_id as entity_i1_15_0_, nodefieldf0_.bundle as bundle2_15_0_, nodefieldf0_.delta 
as delta3_15_0_, nodefieldf0_.field_fenlei_target_id as field_fe4_15_0_, nodefieldf0_.langcode 
as langcode5_15_0_, nodefieldf0_.revision_id as revision6_15_0_ from node_revision__field_fenlei 
nodefieldf0_ where nodefieldf0_.entity_id=1154 
 {executed in 0 msec}
2020-11-25 10:32:07.449 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|-----------------------|---------|------------|
|entity_id |bundle |delta |field_fenlei_target_id |langcode |revision_id |
|----------|-------|------|-----------------------|---------|------------|
|[unread]  |book   |0     |1                      |zh-hans  |1154        |
|----------|-------|------|-----------------------|---------|------------|

2020-11-25 10:32:07.451 INFO  jdbc.sqltiming Line:373 - select bookchecke0_.item_id as item_id1_2_, bookchecke0_.fsid as fsid2_2_, bookchecke0_.got 
as got3_2_, bookchecke0_.name as name4_2_, bookchecke0_.parse_fail as parse_fa5_2_, bookchecke0_.parsed 
as parsed6_2_, bookchecke0_.path as path7_2_, bookchecke0_.title as title8_2_, bookchecke0_.vid 
as vid9_2_ from book_check bookchecke0_ where bookchecke0_.fsid='72544342599478' and bookchecke0_.name='net_content' 
 {executed in 0 msec}
2020-11-25 10:32:07.452 INFO  jdbc.resultsettable Line:610 - 
|--------|---------|---------|---------|-----------|---------|---------|---------|---------|
|item_id |fsid     |got      |name     |parse_fail |parsed   |path     |title    |vid      |
|--------|---------|---------|---------|-----------|---------|---------|---------|---------|
|1174    |[unread] |[unread] |[unread] |[unread]   |[unread] |[unread] |[unread] |[unread] |
|--------|---------|---------|---------|-----------|---------|---------|---------|---------|

2020-11-25 10:35:04.530 INFO  jdbc.sqltiming Line:373 - update book_check set fsid='72544342599478', got=1, name='net_content', parse_fail='comment_', 
parsed=0, path='123-检索技术核心20讲/04丨系统案例篇 (4讲)/20丨推荐引擎：没有搜索词，“头条”怎么找到你感兴趣的文章？.html', title='20丨推荐引擎：没有搜索词，“头条”怎么找到你感兴趣的文章？', 
vid=1174 where item_id=1174 
 {executed in 0 msec}
2020-11-25 10:35:04.538 INFO  jdbc.sqltiming Line:373 - select nodebodyen0_.entity_id as entity_i1_4_, nodebodyen0_.body_value as body_val2_4_, nodebodyen0_.body_summary 
as body_sum3_4_, nodebodyen0_.bundle as bundle4_4_, nodebodyen0_.delta as delta5_4_, nodebodyen0_.body_format 
as body_for6_4_, nodebodyen0_.langcode as langcode7_4_, nodebodyen0_.revision_id as revision8_4_ 
from node__body nodebodyen0_ where nodebodyen0_.entity_id=1174 
 {executed in 0 msec}
2020-11-25 10:35:04.539 INFO  jdbc.resultsettable Line:610 - 
|----------|-----------|-------------|-------|------|------------|---------|------------|
|entity_id |body_value |body_summary |bundle |delta |body_format |langcode |revision_id |
|----------|-----------|-------------|-------|------|------------|---------|------------|
|1174      |           |             |book   |0     |full_html   |zh-hans  |1174        |
|----------|-----------|-------------|-------|------|------------|---------|------------|

2020-11-25 10:35:04.539 INFO  jdbc.sqltiming Line:373 - select nodebodyre0_.entity_id as entity_i1_13_0_, nodebodyre0_.body_value as body_val2_13_0_, 
nodebodyre0_.body_summary as body_sum3_13_0_, nodebodyre0_.bundle as bundle4_13_0_, nodebodyre0_.delta 
as delta5_13_0_, nodebodyre0_.body_format as body_for6_13_0_, nodebodyre0_.langcode as langcode7_13_0_, 
nodebodyre0_.revision_id as revision8_13_0_ from node_revision__body nodebodyre0_ where nodebodyre0_.entity_id=1174 
 {executed in 0 msec}
2020-11-25 10:35:04.540 INFO  jdbc.resultsettable Line:610 - 
|----------|-----------|-------------|-------|------|------------|---------|------------|
|entity_id |body_value |body_summary |bundle |delta |body_format |langcode |revision_id |
|----------|-----------|-------------|-------|------|------------|---------|------------|
|[unread]  |           |             |book   |0     |full_html   |zh-hans  |1174        |
|----------|-----------|-------------|-------|------|------------|---------|------------|

2020-11-25 10:35:04.542 INFO  jdbc.sqltiming Line:373 - update node__body set body_value='<div data-slate-editor="true" data-key="771" autocorrect="off" 
spellcheck="false" data-gramm="false" style="outline: none; white-space: pre-wrap; overflow-wrap: 
break-word;"> <div class="se-35476a23 " data-slate-type="paragraph" data-slate-object="block" 
data-key="772"> <span data-slate-object="text" data-key="773"><span data-slate-leaf="true" 
data-offset-key="773:0" data-first-offset="true"><span data-slate-string="true">你好，我是陈东。今天我来和你讲讲推荐引擎。</span></span></span> 
</div> <div class="se-b9d93b01 " data-slate-type="paragraph" data-slate-object="block" data-key="774"> 
<span data-slate-object="text" data-key="775"><span data-slate-leaf="true" data-offset-key="775:0" 
data-first-offset="true"><span data-slate-string="true">我们每天都会接触推荐引擎，最常见的，就是当我们用手机浏览资讯类 App 
的时候，经常会用到的“下拉刷新”功能。你会发现，每次刷新之后，这些 App 都能给你推荐你最关心的“头条信息”。</span></span></span> </div> <div class="se-2fd4826e 
" data-slate-type="paragraph" data-slate-object="block" data-key="776"> <span data-slate-object="text" 
data-key="777"><span data-slate-leaf="true" data-offset-key="777:0" data-first-offset="true"><span 
data-slate-string="true">那这些资讯类的 App，是怎么在没有搜索词的情况下，仅凭下拉刷新就可以在海量的文章中检索出你感兴趣的内容，并且推荐给你的呢？这就和推荐引擎中的检索技术有关了。那今天，我就以资讯类 
App 推荐文章为例，来和你聊一聊推荐引擎中的检索技术。</span></span></span> </div> <h2 class="se-3afea6c8" data-slate-type="heading" 
data-slate-object="block" data-key="778"><span data-slate-object="text" data-key="779"><span 
data-slate-leaf="true" data-offset-key="779:0" data-first-offset="true"><span data-slate-string="true">推荐引擎的整体架构和工作过程</span></span></span></h2> 
<div class="se-70ca7f17 " data-slate-type="paragraph" data-slate-object="block" data-key="780"> 
<span data-slate-object="text" data-key="781"><span data-slate-leaf="true" data-offset-key="781:0" 
data-first-offset="true"><span data-slate-string="true">我们知道，检索引擎的灵活程度和系统的检索约束条件有关。那我们先来看一下针对不同的引擎，系统的检索约束条件分别是什么。</span></span></span> 
</div> <div class="se-a89d3e65 " data-slate-type="paragraph" data-slate-object="block" data-key="782"> 
<span data-slate-object="text" data-key="783"><span data-slate-leaf="true" data-offset-key="783:0" 
data-first-offset="true"><span data-slate-string="true">在搜索引擎中，系统的强约束条件是用户输入的搜索词。而在广告引擎中，系统的强约束条件是广告主设置的定向要求。但是在资讯类 
App 推荐引擎中，因为所有的用户操作只有“下拉刷新”这一个动作，所以外界输入的检索约束条件其实非常少。</span></span></span> </div> <div class="se-56d91b66 
" data-slate-type="paragraph" data-slate-object="block" data-key="784"> <span data-slate-object="text" 
data-key="785"><span data-slate-leaf="true" data-offset-key="785:0" data-first-offset="true"><span 
data-slate-string="true">因此，</span></span></span><span data-slate-object="text" data-key="786"><span 
data-slate-leaf="true" data-offset-key="786:0" data-first-offset="true"><span class="se-8d1bd944" 
data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">相比于搜索引擎和广告引擎，推荐引擎具有更灵活的检索能力，也就是可以使用更灵活的检索技术，来进行文章的召回服务</span></span></span></span><span 
data-slate-object="text" data-key="787"><span data-slate-leaf="true" data-offset-key="787:0" 
data-first-offset="true"><span data-slate-string="true">。这也是推荐引擎相比于搜索引擎和广告引擎最大的不同之处。</span></span></span> 
</div> <div class="se-fd9426c0 " data-slate-type="paragraph" data-slate-object="block" data-key="788"> 
<span data-slate-object="text" data-key="789"><span data-slate-leaf="true" data-offset-key="789:0" 
data-first-offset="true"><span data-slate-string="true">那一个推荐引擎是怎么工作的呢？我按照功能划分，梳理出了推荐引擎的核心模块。</span></span></span> 
</div> <div class="se-5df5eb34" data-slate-type="image" data-slate-object="block" data-key="790"> 
<img class="se-07c1c0b7" src="https://static001.geekbang.org/resource/image/f6/77/f6e2ab9724a4e6c1bb2b5160129b6c77.jpg"> 
<div class="se-b03fb577"> 推荐引擎架构示意图 </div> </div> <div class="se-0b4b3e2a " data-slate-type="paragraph" 
data-slate-object="block" data-key="791"> <span data-slate-object="text" data-key="792"><span 
data-slate-leaf="true" data-offset-key="792:0" data-first-offset="true"><span class="se-bc9ff125" 
data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">那接下来，我就结合这个架构图，来说说推荐引擎的核心工作流程。</span></span></span></span> 
</div> <div class="se-cdfb653c " data-slate-type="paragraph" data-slate-object="block" data-key="793"> 
<span data-slate-object="text" data-key="794"><span data-slate-leaf="true" data-offset-key="794:0" 
data-first-offset="true"><span data-slate-string="true">首先，因为没有搜索词，所以推荐引擎并不能直接得知用户的意图和喜好。为了解决这个问题，推荐引擎会收集用户对不同文章的行为数据，包括曝光、点击、阅读、收藏、点赞和评论等等。</span></span></span> 
</div> <div class="se-3702ad36 " data-slate-type="paragraph" data-slate-object="block" data-key="795"> 
<span data-slate-object="text" data-key="796"><span data-slate-leaf="true" data-offset-key="796:0" 
data-first-offset="true"><span data-slate-string="true">然后，我们会通过这些收集来的数据，在离线环节挖掘每一个用户兴趣，从而能对用户分类来生成完整的用户画像。在用户画像中，一个用户会拥有不同的标签，这些标签会有不同的权重，所有的权重都会随着时间的变化而衰减。比如说，如果一个用户长时间没有继续这个行为，那标签就会逐步弱化。再比如说一个用户的兴趣发生变化了，那最新的兴趣标签的权重就会大于老的兴趣标签。通过这样的机制，我们就能更好地理解用户的喜好了。</span></span></span> 
</div> <div class="se-1fbf176f " data-slate-type="paragraph" data-slate-object="block" data-key="797"> 
<span data-slate-object="text" data-key="798"><span data-slate-leaf="true" data-offset-key="798:0" 
data-first-offset="true"><span data-slate-string="true">但是，只给用户打上标签还不够，我们也要给文章打上标签。在这个过程中，我们除了要提取文章中的关键词以外，更多的要对文章中的内容做语义分析工作，比如，文章分类、主题词提取、主题提取等等。通过这些方式，推荐引擎就能为每一篇文章都生成文章画像了。</span></span></span> 
</div> <div class="se-37d005d0 " data-slate-type="paragraph" data-slate-object="block" data-key="799"> 
<span data-slate-object="text" data-key="800"><span data-slate-leaf="true" data-offset-key="800:0" 
data-first-offset="true"><span data-slate-string="true">有了用户画像、文章画像，以及用户对文章的行为记录以后，我们就可以根据需求，灵活地使用不同的推荐算法来为用户推荐文章了。主要的推荐算法有 
2 大类，分别是基于统计的静态召回算法和个性化召回算法。</span></span></span> </div> <div class="se-4ffaa965 " data-slate-type="paragraph" 
data-slate-object="block" data-key="801"> <span data-slate-object="text" data-key="802"><span 
data-slate-leaf="true" data-offset-key="802:0" data-first-offset="true"><span data-slate-string="true">所谓基于统计的静态召回，指的是根据当前系统对于文章的统计数据来进行推荐。比如说，我们可以在离线环节，提前统计好点击量最大、评论最多、收藏最多、收藏率上升最快的文章等。然后在线上环节将这些热门文章推荐给所有用户。它比较适合作为个性化召回不足时候的补充方案。</span></span></span> 
</div> <div class="se-f6b35edb " data-slate-type="paragraph" data-slate-object="block" data-key="803"> 
<span data-slate-object="text" data-key="804"><span data-slate-leaf="true" data-offset-key="804:0" 
data-first-offset="true"><span data-slate-string="true">接下来，我们重点来讲讲个性化召回算法，因为一般来说，我们提到推荐算法的时候，指的都是个性化召回算法。个性化召回也有许多不同的方案，最有代表性的两种个性化召回，就是基于内容的召回（Content 
Based），以及基于协同过滤的召回（Collaborative Filtering）。</span></span></span> </div> <div class="se-27147c39 
" data-slate-type="paragraph" data-slate-object="block" data-key="805"> <span data-slate-object="text" 
data-key="806"><span data-slate-leaf="true" data-offset-key="806:0" data-first-offset="true"><span 
data-slate-string="true">接下来，我们就重点讲讲这两种个性化召回方案。</span></span></span> </div> <h2 class="se-de6460e5" 
data-slate-type="heading" data-slate-object="block" data-key="807"><span data-slate-object="text" 
data-key="808"><span data-slate-leaf="true" data-offset-key="808:0" data-first-offset="true"><span 
data-slate-string="true">基于内容的召回</span></span></span></h2> <div class="se-19a5d007 " data-slate-type="paragraph" 
data-slate-object="block" data-key="809"> <span data-slate-object="text" data-key="810"><span 
data-slate-leaf="true" data-offset-key="810:0" data-first-offset="true"><span data-slate-string="true">基于内容的召回，就是我们根据文章的内容，判断这篇文章是否符合用户的喜好。具体怎么做呢？我们可以判断用户画像和文章画像中的标签或关键词是否相同，如果相同，就说明这篇文章的内容符合用户喜好，那我们就可以召回这篇文章。</span></span></span> 
</div> <div class="se-498db7c7 " data-slate-type="paragraph" data-slate-object="block" data-key="811"> 
<span data-slate-object="text" data-key="812"><span data-slate-leaf="true" data-offset-key="812:0" 
data-first-offset="true"><span data-slate-string="true">这个时候，我们要解决的问题，其实就又变成了我们熟悉的标签匹配问题（</span></span></span><a 
data-slate-type="link" data-slate-object="inline" data-key="813" class="se-a46fc471 se-0fa21b50"><span 
data-slate-object="text" data-key="814"><span data-slate-leaf="true" data-offset-key="814:0" 
data-first-offset="true"><span data-slate-string="true">第 19 讲</span></span></span></a><span 
data-slate-object="text" data-key="815"><span data-slate-leaf="true" data-offset-key="815:0" 
data-first-offset="true"><span data-slate-string="true">）。因此，我们完全可以用标签和关键词作为 Key，来建立倒排索引。这样，我们就能针对用户的喜好，召回内容匹配的文章了。</span></span></span> 
</div> <div class="se-58a738af " data-slate-type="paragraph" data-slate-object="block" data-key="816"> 
<span data-slate-object="text" data-key="817"><span data-slate-leaf="true" data-offset-key="817:0" 
data-first-offset="true"><span data-slate-string="true">当然，在上一讲中我们也说了，基于标签的召回可能会漏掉许多候选集合。因此，我们可以使用向量空间模型，将标签匹配改为高维向量空间的最近邻检索问题。这样，我们就能达到更灵活的召回目的了。</span></span></span> 
</div> <div class="se-483b28cb " data-slate-type="paragraph" data-slate-object="block" data-key="818"> 
<span data-slate-object="text" data-key="819"><span data-slate-leaf="true" data-offset-key="819:0" 
data-first-offset="true"><span data-slate-string="true">以上就是基于内容的召回的具体方法，对于向量空间的最邻近检索，我们在前面已经详细讲过，这里就不再重复了。不过，如果要将基于内容召回的技术用在推荐系统中，我们就需要充分理解它的特点和效果。那接下来，我们就来说说基于内容的召回在数据依赖、个性化和冷启动方面的优缺点。</span></span></span> 
</div> <div class="se-f5dc6cfe " data-slate-type="paragraph" data-slate-object="block" data-key="820"> 
<span data-slate-object="text" data-key="821"><span data-slate-leaf="true" data-offset-key="821:0" 
data-first-offset="true"><span data-slate-string="true">首先，优点有 3 个，分别是</span></span></span><span 
data-slate-object="text" data-key="822"><span data-slate-leaf="true" data-offset-key="822:0" 
data-first-offset="true"><span class="se-1ebbdf85" data-slate-type="bold" data-slate-object="mark"><span 
data-slate-string="true">不需要其他用户数据，可以针对小众用户给出个性化的推荐，以及可以推荐冷启动的新文章</span></span></span></span><span 
data-slate-object="text" data-key="823"><span data-slate-leaf="true" data-offset-key="823:0" 
data-first-offset="true"><span data-slate-string="true">。同样的，缺点也有 3 个，分别是</span></span></span><span 
data-slate-object="text" data-key="824"><span data-slate-leaf="true" data-offset-key="824:0" 
data-first-offset="true"><span class="se-cba1f528" data-slate-type="bold" data-slate-object="mark"><span 
data-slate-string="true">依赖于用户画像系统和文章画像系统，无法挖掘出用户的潜在兴趣，以及无法给冷启动的新用户推荐文章。</span></span></span></span><span 
data-slate-object="text" data-key="825"><span data-slate-leaf="true" data-offset-key="825:0" 
data-first-offset="true"><span data-slate-string="true">这些优缺点出现的原因，我在下面的表格中都给出了解释，理解起来应该不难，那我在这里就不多说了。</span></span></span> 
</div> <div class="se-e9152c82" data-slate-type="image" data-slate-object="block" data-key="826"> 
<img class="se-a7d21b57" src="https://static001.geekbang.org/resource/image/64/66/64ce4e8c89a2b7b944289f5115783866.jpg"> 
<div class="se-5fbf4672"> 优缺点对照表 </div> </div> <h2 class="se-594c7247" data-slate-type="heading" 
data-slate-object="block" data-key="827"><span data-slate-object="text" data-key="828"><span 
data-slate-leaf="true" data-offset-key="828:0" data-first-offset="true"><span data-slate-string="true">基于协同过滤的召回</span></span></span></h2> 
<div class="se-d91960af " data-slate-type="paragraph" data-slate-object="block" data-key="829"> 
<span data-slate-object="text" data-key="830"><span data-slate-leaf="true" data-offset-key="830:0" 
data-first-offset="true"><span data-slate-string="true">协同过滤是推荐引擎中最具有代表性的方法。协同过滤和基于内容的召回方法最大的区别就在于，它并不依赖内容本身来进行推荐，而是基于大众用户和这篇文章的互动关系来进行推荐。</span></span></span> 
</div> <div class="se-069abb2b " data-slate-type="paragraph" data-slate-object="block" data-key="831"> 
<span data-slate-object="text" data-key="832"><span data-slate-leaf="true" data-offset-key="832:0" 
data-first-offset="true"><span data-slate-string="true">其中，协同过滤还可以分为两大类：一类是传统的基于数据统计的 </span></span></span><span 
data-slate-object="text" data-key="833"><span data-slate-leaf="true" data-offset-key="833:0" 
data-first-offset="true"><span class="se-431a5afe" data-slate-type="bold" data-slate-object="mark"><span 
data-slate-string="true">Memory-based</span></span></span></span><span data-slate-object="text" 
data-key="834"><span data-slate-leaf="true" data-offset-key="834:0" data-first-offset="true"><span 
data-slate-string="true"> 的协同过滤算法，也叫做</span></span></span><span data-slate-object="text" data-key="835"><span 
data-slate-leaf="true" data-offset-key="835:0" data-first-offset="true"><span class="se-d15fd3fe" 
data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">基于邻域的算法</span></span></span></span><span 
data-slate-object="text" data-key="836"><span data-slate-leaf="true" data-offset-key="836:0" 
data-first-offset="true"><span data-slate-string="true">，代表算法有</span></span></span><span data-slate-object="text" 
data-key="837"><span data-slate-leaf="true" data-offset-key="837:0" data-first-offset="true"><span 
class="se-860e2b4f" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">基于用户的协同过滤</span></span></span></span><span 
data-slate-object="text" data-key="838"><span data-slate-leaf="true" data-offset-key="838:0" 
data-first-offset="true"><span data-slate-string="true">（User CF，User Collaboration Filter）和</span></span></span><span 
data-slate-object="text" data-key="839"><span data-slate-leaf="true" data-offset-key="839:0" 
data-first-offset="true"><span class="se-04fa3005" data-slate-type="bold" data-slate-object="mark"><span 
data-slate-string="true">基于物品的协同过滤</span></span></span></span><span data-slate-object="text" 
data-key="840"><span data-slate-leaf="true" data-offset-key="840:0" data-first-offset="true"><span 
data-slate-string="true">（Item CF，Item Collaboration Filter）；另一类是升级版的</span></span></span><span 
data-slate-object="text" data-key="841"><span data-slate-leaf="true" data-offset-key="841:0" 
data-first-offset="true"><span class="se-e5ba8f35" data-slate-type="bold" data-slate-object="mark"><span 
data-slate-string="true">基于模型的 Model-based 的协同过滤算法</span></span></span></span><span data-slate-object="text" 
data-key="842"><span data-slate-leaf="true" data-offset-key="842:0" data-first-offset="true"><span 
data-slate-string="true">。今天，我们还是将重点放在协同过滤的基础算法，也就是 Memory-based 上，其他的就先不展开了。</span></span></span> 
</div> <h3 class="se-831fb7af" data-slate-type="heading" data-slate-object="block" data-key="843"><span 
data-slate-object="text" data-key="844"><span data-slate-leaf="true" data-offset-key="844:0" 
data-first-offset="true"><span data-slate-string="true">1. 基于用户的协同过滤</span></span></span></h3> 
<div class="se-8f19433c " data-slate-type="paragraph" data-slate-object="block" data-key="845"> 
<span data-slate-object="text" data-key="846"><span data-slate-leaf="true" data-offset-key="846:0" 
data-first-offset="true"><span data-slate-string="true">基于用户的协同过滤的思想其实并不复杂，说白了就是将和你相似的用户看过的文章也推荐给你。那在具体操作的时候会分为两步：</span></span></span> 
</div> <div class="se-a2b1c044" data-slate-type="list" data-slate-object="block" data-key="847"> 
<div class="se-2dc5293e" data-slate-type="list-line" data-slate-object="block" data-key="848"> 
<div class="se-12e9f9f4 se-a79162ab" data-code-line-number="1"></div> <div class="se-ceda0040"> 
<span data-slate-object="text" data-key="849"><span data-slate-leaf="true" data-offset-key="849:0" 
data-first-offset="true"><span data-slate-string="true">找到和你最相似的一批用户</span></span></span> </div> 
</div> <div class="se-ac1197d1" data-slate-type="list-line" data-slate-object="block" data-key="850"> 
<div class="se-1c8bbe46 se-5e9b852d" data-code-line-number="2"></div> <div class="se-4c94ce0b"> 
<span data-slate-object="text" data-key="851"><span data-slate-leaf="true" data-offset-key="851:0" 
data-first-offset="true"><span data-slate-string="true">将这批用户看过，但你没看过的文章推荐给你</span></span></span> 
</div> </div> </div> <div class="se-9dabd879 " data-slate-type="paragraph" data-slate-object="block" 
data-key="852"> <span data-slate-object="text" data-key="853"><span data-slate-leaf="true" 
data-offset-key="853:0" data-first-offset="true"><span data-slate-string="true">接下来，我们通过一个例子，来直观感受一下基于用户的协同过滤过程是怎么样的。</span></span></span> 
</div> <div class="se-657fe390 " data-slate-type="paragraph" data-slate-object="block" data-key="854"> 
<span data-slate-object="text" data-key="855"><span data-slate-leaf="true" data-offset-key="855:0" 
data-first-offset="true"><span data-slate-string="true">首先，如果 User 1 看过 Item 1 和 Item 2，而 User 
3 和 User 4 也看过 Item 1 和 Item 2，那么 User 1 和 User 3、User 4 就是相似用户。这样一来，如果 User 3 和 User 4 还分别看过 
Item 3 和 Item 4，我们就可以将 Item 3 和 Item 4 都推荐给 User 1 了。</span></span></span> </div> <div class="se-93f9f137" 
data-slate-type="image" data-slate-object="block" data-key="856"> <img class="se-496230fe" 
src="https://static001.geekbang.org/resource/image/58/9b/58b8909ea3e0b32b40afd4e97bbff79b.jpg"> 
<div class="se-3665dec8"> 基于用户的协同过滤 </div> </div> <div class="se-fe970073 " data-slate-type="paragraph" 
data-slate-object="block" data-key="857"> <span data-slate-object="text" data-key="858"><span 
data-slate-leaf="true" data-offset-key="858:0" data-first-offset="true"><span data-slate-string="true">在这个过程中，定义相似的用户并且将它们找出来是最重要的一步。那具体怎么做呢？我们先将上面的例子变成一个表格，这样看起来更清晰。</span></span></span> 
</div> <div class="se-c39b23ab" data-slate-type="image" data-slate-object="block" data-key="859"> 
<img class="se-10d7d18e" src="https://static001.geekbang.org/resource/image/91/5d/9110418a92bff7b28771b6baad1c0b5d.jpg"> 
</div> <div class="se-dab00839 " data-slate-type="paragraph" data-slate-object="block" data-key="860"> 
<span data-slate-object="text" data-key="861"><span data-slate-leaf="true" data-offset-key="861:0" 
data-first-offset="true"><span data-slate-string="true">你会看到，这个表格里的每篇文章下面都对应着一些数字，这其实就是每个用户对每篇文章的喜爱程度（具体可以通过用户的点击次数、收藏、评论和转发等行为计算出来的）。</span></span></span> 
</div> <div class="se-e8efa094 " data-slate-type="paragraph" data-slate-object="block" data-key="862"> 
<span data-slate-object="text" data-key="863"><span data-slate-leaf="true" data-offset-key="863:0" 
data-first-offset="true"><span data-slate-string="true">那基于这张表，如果要找出和 User 1 相似的用户，我们可以将 Item 
1 到 Item n 看作是一个 n 维空间，那每个用户都可以表示为 n 维空间中的一个向量，然后把他对这个物品的喜好程度，作为每个维度上的值。</span></span></span> 
</div> <div class="se-e36baafb " data-slate-type="paragraph" data-slate-object="block" data-key="864"> 
<span data-slate-object="text" data-key="865"><span data-slate-leaf="true" data-offset-key="865:0" 
data-first-offset="true"><span data-slate-string="true">这样一来，如何找到最相似的一批用户的问题，就变成了如何在 n 维向量空间中，找到和 
User 1 这个点最接近的点的问题。对于向量相似度，我们一般使用余弦距离来计算。</span></span></span> </div> <div class="se-3598db05" 
data-slate-type="image" data-slate-object="block" data-key="866"> <img class="se-b695323f" 
src="https://static001.geekbang.org/resource/image/1b/39/1ba92fde0deb2b95e52cd5feb46e5e39.jpg"> 
<div class="se-28de1b56"> 余弦距离公式 </div> </div> <div class="se-28f9a4c1 " data-slate-type="paragraph" 
data-slate-object="block" data-key="867"> <span data-slate-object="text" data-key="868"><span 
data-slate-leaf="true" data-offset-key="868:0" data-first-offset="true"><span data-slate-string="true">计算的过程我就不多说了，我直接把计算出来的相似度的结果告诉你。</span></span></span> 
</div> <div class="se-d287bf30" data-slate-type="image" data-slate-object="block" data-key="869"></div> 
</div>', body_summary='', bundle='book', delta=0, body_format='full_html', langcode='zh-hans', 
revision_id=1174 where entity_id=1174 
 {executed in 1 msec}
2020-11-25 10:35:04.544 INFO  jdbc.sqltiming Line:373 - update node_revision__body set body_value='<div data-slate-editor="true" data-key="771" autocorrect="off" 
spellcheck="false" data-gramm="false" style="outline: none; white-space: pre-wrap; overflow-wrap: 
break-word;"> <div class="se-35476a23 " data-slate-type="paragraph" data-slate-object="block" 
data-key="772"> <span data-slate-object="text" data-key="773"><span data-slate-leaf="true" 
data-offset-key="773:0" data-first-offset="true"><span data-slate-string="true">你好，我是陈东。今天我来和你讲讲推荐引擎。</span></span></span> 
</div> <div class="se-b9d93b01 " data-slate-type="paragraph" data-slate-object="block" data-key="774"> 
<span data-slate-object="text" data-key="775"><span data-slate-leaf="true" data-offset-key="775:0" 
data-first-offset="true"><span data-slate-string="true">我们每天都会接触推荐引擎，最常见的，就是当我们用手机浏览资讯类 App 
的时候，经常会用到的“下拉刷新”功能。你会发现，每次刷新之后，这些 App 都能给你推荐你最关心的“头条信息”。</span></span></span> </div> <div class="se-2fd4826e 
" data-slate-type="paragraph" data-slate-object="block" data-key="776"> <span data-slate-object="text" 
data-key="777"><span data-slate-leaf="true" data-offset-key="777:0" data-first-offset="true"><span 
data-slate-string="true">那这些资讯类的 App，是怎么在没有搜索词的情况下，仅凭下拉刷新就可以在海量的文章中检索出你感兴趣的内容，并且推荐给你的呢？这就和推荐引擎中的检索技术有关了。那今天，我就以资讯类 
App 推荐文章为例，来和你聊一聊推荐引擎中的检索技术。</span></span></span> </div> <h2 class="se-3afea6c8" data-slate-type="heading" 
data-slate-object="block" data-key="778"><span data-slate-object="text" data-key="779"><span 
data-slate-leaf="true" data-offset-key="779:0" data-first-offset="true"><span data-slate-string="true">推荐引擎的整体架构和工作过程</span></span></span></h2> 
<div class="se-70ca7f17 " data-slate-type="paragraph" data-slate-object="block" data-key="780"> 
<span data-slate-object="text" data-key="781"><span data-slate-leaf="true" data-offset-key="781:0" 
data-first-offset="true"><span data-slate-string="true">我们知道，检索引擎的灵活程度和系统的检索约束条件有关。那我们先来看一下针对不同的引擎，系统的检索约束条件分别是什么。</span></span></span> 
</div> <div class="se-a89d3e65 " data-slate-type="paragraph" data-slate-object="block" data-key="782"> 
<span data-slate-object="text" data-key="783"><span data-slate-leaf="true" data-offset-key="783:0" 
data-first-offset="true"><span data-slate-string="true">在搜索引擎中，系统的强约束条件是用户输入的搜索词。而在广告引擎中，系统的强约束条件是广告主设置的定向要求。但是在资讯类 
App 推荐引擎中，因为所有的用户操作只有“下拉刷新”这一个动作，所以外界输入的检索约束条件其实非常少。</span></span></span> </div> <div class="se-56d91b66 
" data-slate-type="paragraph" data-slate-object="block" data-key="784"> <span data-slate-object="text" 
data-key="785"><span data-slate-leaf="true" data-offset-key="785:0" data-first-offset="true"><span 
data-slate-string="true">因此，</span></span></span><span data-slate-object="text" data-key="786"><span 
data-slate-leaf="true" data-offset-key="786:0" data-first-offset="true"><span class="se-8d1bd944" 
data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">相比于搜索引擎和广告引擎，推荐引擎具有更灵活的检索能力，也就是可以使用更灵活的检索技术，来进行文章的召回服务</span></span></span></span><span 
data-slate-object="text" data-key="787"><span data-slate-leaf="true" data-offset-key="787:0" 
data-first-offset="true"><span data-slate-string="true">。这也是推荐引擎相比于搜索引擎和广告引擎最大的不同之处。</span></span></span> 
</div> <div class="se-fd9426c0 " data-slate-type="paragraph" data-slate-object="block" data-key="788"> 
<span data-slate-object="text" data-key="789"><span data-slate-leaf="true" data-offset-key="789:0" 
data-first-offset="true"><span data-slate-string="true">那一个推荐引擎是怎么工作的呢？我按照功能划分，梳理出了推荐引擎的核心模块。</span></span></span> 
</div> <div class="se-5df5eb34" data-slate-type="image" data-slate-object="block" data-key="790"> 
<img class="se-07c1c0b7" src="https://static001.geekbang.org/resource/image/f6/77/f6e2ab9724a4e6c1bb2b5160129b6c77.jpg"> 
<div class="se-b03fb577"> 推荐引擎架构示意图 </div> </div> <div class="se-0b4b3e2a " data-slate-type="paragraph" 
data-slate-object="block" data-key="791"> <span data-slate-object="text" data-key="792"><span 
data-slate-leaf="true" data-offset-key="792:0" data-first-offset="true"><span class="se-bc9ff125" 
data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">那接下来，我就结合这个架构图，来说说推荐引擎的核心工作流程。</span></span></span></span> 
</div> <div class="se-cdfb653c " data-slate-type="paragraph" data-slate-object="block" data-key="793"> 
<span data-slate-object="text" data-key="794"><span data-slate-leaf="true" data-offset-key="794:0" 
data-first-offset="true"><span data-slate-string="true">首先，因为没有搜索词，所以推荐引擎并不能直接得知用户的意图和喜好。为了解决这个问题，推荐引擎会收集用户对不同文章的行为数据，包括曝光、点击、阅读、收藏、点赞和评论等等。</span></span></span> 
</div> <div class="se-3702ad36 " data-slate-type="paragraph" data-slate-object="block" data-key="795"> 
<span data-slate-object="text" data-key="796"><span data-slate-leaf="true" data-offset-key="796:0" 
data-first-offset="true"><span data-slate-string="true">然后，我们会通过这些收集来的数据，在离线环节挖掘每一个用户兴趣，从而能对用户分类来生成完整的用户画像。在用户画像中，一个用户会拥有不同的标签，这些标签会有不同的权重，所有的权重都会随着时间的变化而衰减。比如说，如果一个用户长时间没有继续这个行为，那标签就会逐步弱化。再比如说一个用户的兴趣发生变化了，那最新的兴趣标签的权重就会大于老的兴趣标签。通过这样的机制，我们就能更好地理解用户的喜好了。</span></span></span> 
</div> <div class="se-1fbf176f " data-slate-type="paragraph" data-slate-object="block" data-key="797"> 
<span data-slate-object="text" data-key="798"><span data-slate-leaf="true" data-offset-key="798:0" 
data-first-offset="true"><span data-slate-string="true">但是，只给用户打上标签还不够，我们也要给文章打上标签。在这个过程中，我们除了要提取文章中的关键词以外，更多的要对文章中的内容做语义分析工作，比如，文章分类、主题词提取、主题提取等等。通过这些方式，推荐引擎就能为每一篇文章都生成文章画像了。</span></span></span> 
</div> <div class="se-37d005d0 " data-slate-type="paragraph" data-slate-object="block" data-key="799"> 
<span data-slate-object="text" data-key="800"><span data-slate-leaf="true" data-offset-key="800:0" 
data-first-offset="true"><span data-slate-string="true">有了用户画像、文章画像，以及用户对文章的行为记录以后，我们就可以根据需求，灵活地使用不同的推荐算法来为用户推荐文章了。主要的推荐算法有 
2 大类，分别是基于统计的静态召回算法和个性化召回算法。</span></span></span> </div> <div class="se-4ffaa965 " data-slate-type="paragraph" 
data-slate-object="block" data-key="801"> <span data-slate-object="text" data-key="802"><span 
data-slate-leaf="true" data-offset-key="802:0" data-first-offset="true"><span data-slate-string="true">所谓基于统计的静态召回，指的是根据当前系统对于文章的统计数据来进行推荐。比如说，我们可以在离线环节，提前统计好点击量最大、评论最多、收藏最多、收藏率上升最快的文章等。然后在线上环节将这些热门文章推荐给所有用户。它比较适合作为个性化召回不足时候的补充方案。</span></span></span> 
</div> <div class="se-f6b35edb " data-slate-type="paragraph" data-slate-object="block" data-key="803"> 
<span data-slate-object="text" data-key="804"><span data-slate-leaf="true" data-offset-key="804:0" 
data-first-offset="true"><span data-slate-string="true">接下来，我们重点来讲讲个性化召回算法，因为一般来说，我们提到推荐算法的时候，指的都是个性化召回算法。个性化召回也有许多不同的方案，最有代表性的两种个性化召回，就是基于内容的召回（Content 
Based），以及基于协同过滤的召回（Collaborative Filtering）。</span></span></span> </div> <div class="se-27147c39 
" data-slate-type="paragraph" data-slate-object="block" data-key="805"> <span data-slate-object="text" 
data-key="806"><span data-slate-leaf="true" data-offset-key="806:0" data-first-offset="true"><span 
data-slate-string="true">接下来，我们就重点讲讲这两种个性化召回方案。</span></span></span> </div> <h2 class="se-de6460e5" 
data-slate-type="heading" data-slate-object="block" data-key="807"><span data-slate-object="text" 
data-key="808"><span data-slate-leaf="true" data-offset-key="808:0" data-first-offset="true"><span 
data-slate-string="true">基于内容的召回</span></span></span></h2> <div class="se-19a5d007 " data-slate-type="paragraph" 
data-slate-object="block" data-key="809"> <span data-slate-object="text" data-key="810"><span 
data-slate-leaf="true" data-offset-key="810:0" data-first-offset="true"><span data-slate-string="true">基于内容的召回，就是我们根据文章的内容，判断这篇文章是否符合用户的喜好。具体怎么做呢？我们可以判断用户画像和文章画像中的标签或关键词是否相同，如果相同，就说明这篇文章的内容符合用户喜好，那我们就可以召回这篇文章。</span></span></span> 
</div> <div class="se-498db7c7 " data-slate-type="paragraph" data-slate-object="block" data-key="811"> 
<span data-slate-object="text" data-key="812"><span data-slate-leaf="true" data-offset-key="812:0" 
data-first-offset="true"><span data-slate-string="true">这个时候，我们要解决的问题，其实就又变成了我们熟悉的标签匹配问题（</span></span></span><a 
data-slate-type="link" data-slate-object="inline" data-key="813" class="se-a46fc471 se-0fa21b50"><span 
data-slate-object="text" data-key="814"><span data-slate-leaf="true" data-offset-key="814:0" 
data-first-offset="true"><span data-slate-string="true">第 19 讲</span></span></span></a><span 
data-slate-object="text" data-key="815"><span data-slate-leaf="true" data-offset-key="815:0" 
data-first-offset="true"><span data-slate-string="true">）。因此，我们完全可以用标签和关键词作为 Key，来建立倒排索引。这样，我们就能针对用户的喜好，召回内容匹配的文章了。</span></span></span> 
</div> <div class="se-58a738af " data-slate-type="paragraph" data-slate-object="block" data-key="816"> 
<span data-slate-object="text" data-key="817"><span data-slate-leaf="true" data-offset-key="817:0" 
data-first-offset="true"><span data-slate-string="true">当然，在上一讲中我们也说了，基于标签的召回可能会漏掉许多候选集合。因此，我们可以使用向量空间模型，将标签匹配改为高维向量空间的最近邻检索问题。这样，我们就能达到更灵活的召回目的了。</span></span></span> 
</div> <div class="se-483b28cb " data-slate-type="paragraph" data-slate-object="block" data-key="818"> 
<span data-slate-object="text" data-key="819"><span data-slate-leaf="true" data-offset-key="819:0" 
data-first-offset="true"><span data-slate-string="true">以上就是基于内容的召回的具体方法，对于向量空间的最邻近检索，我们在前面已经详细讲过，这里就不再重复了。不过，如果要将基于内容召回的技术用在推荐系统中，我们就需要充分理解它的特点和效果。那接下来，我们就来说说基于内容的召回在数据依赖、个性化和冷启动方面的优缺点。</span></span></span> 
</div> <div class="se-f5dc6cfe " data-slate-type="paragraph" data-slate-object="block" data-key="820"> 
<span data-slate-object="text" data-key="821"><span data-slate-leaf="true" data-offset-key="821:0" 
data-first-offset="true"><span data-slate-string="true">首先，优点有 3 个，分别是</span></span></span><span 
data-slate-object="text" data-key="822"><span data-slate-leaf="true" data-offset-key="822:0" 
data-first-offset="true"><span class="se-1ebbdf85" data-slate-type="bold" data-slate-object="mark"><span 
data-slate-string="true">不需要其他用户数据，可以针对小众用户给出个性化的推荐，以及可以推荐冷启动的新文章</span></span></span></span><span 
data-slate-object="text" data-key="823"><span data-slate-leaf="true" data-offset-key="823:0" 
data-first-offset="true"><span data-slate-string="true">。同样的，缺点也有 3 个，分别是</span></span></span><span 
data-slate-object="text" data-key="824"><span data-slate-leaf="true" data-offset-key="824:0" 
data-first-offset="true"><span class="se-cba1f528" data-slate-type="bold" data-slate-object="mark"><span 
data-slate-string="true">依赖于用户画像系统和文章画像系统，无法挖掘出用户的潜在兴趣，以及无法给冷启动的新用户推荐文章。</span></span></span></span><span 
data-slate-object="text" data-key="825"><span data-slate-leaf="true" data-offset-key="825:0" 
data-first-offset="true"><span data-slate-string="true">这些优缺点出现的原因，我在下面的表格中都给出了解释，理解起来应该不难，那我在这里就不多说了。</span></span></span> 
</div> <div class="se-e9152c82" data-slate-type="image" data-slate-object="block" data-key="826"> 
<img class="se-a7d21b57" src="https://static001.geekbang.org/resource/image/64/66/64ce4e8c89a2b7b944289f5115783866.jpg"> 
<div class="se-5fbf4672"> 优缺点对照表 </div> </div> <h2 class="se-594c7247" data-slate-type="heading" 
data-slate-object="block" data-key="827"><span data-slate-object="text" data-key="828"><span 
data-slate-leaf="true" data-offset-key="828:0" data-first-offset="true"><span data-slate-string="true">基于协同过滤的召回</span></span></span></h2> 
<div class="se-d91960af " data-slate-type="paragraph" data-slate-object="block" data-key="829"> 
<span data-slate-object="text" data-key="830"><span data-slate-leaf="true" data-offset-key="830:0" 
data-first-offset="true"><span data-slate-string="true">协同过滤是推荐引擎中最具有代表性的方法。协同过滤和基于内容的召回方法最大的区别就在于，它并不依赖内容本身来进行推荐，而是基于大众用户和这篇文章的互动关系来进行推荐。</span></span></span> 
</div> <div class="se-069abb2b " data-slate-type="paragraph" data-slate-object="block" data-key="831"> 
<span data-slate-object="text" data-key="832"><span data-slate-leaf="true" data-offset-key="832:0" 
data-first-offset="true"><span data-slate-string="true">其中，协同过滤还可以分为两大类：一类是传统的基于数据统计的 </span></span></span><span 
data-slate-object="text" data-key="833"><span data-slate-leaf="true" data-offset-key="833:0" 
data-first-offset="true"><span class="se-431a5afe" data-slate-type="bold" data-slate-object="mark"><span 
data-slate-string="true">Memory-based</span></span></span></span><span data-slate-object="text" 
data-key="834"><span data-slate-leaf="true" data-offset-key="834:0" data-first-offset="true"><span 
data-slate-string="true"> 的协同过滤算法，也叫做</span></span></span><span data-slate-object="text" data-key="835"><span 
data-slate-leaf="true" data-offset-key="835:0" data-first-offset="true"><span class="se-d15fd3fe" 
data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">基于邻域的算法</span></span></span></span><span 
data-slate-object="text" data-key="836"><span data-slate-leaf="true" data-offset-key="836:0" 
data-first-offset="true"><span data-slate-string="true">，代表算法有</span></span></span><span data-slate-object="text" 
data-key="837"><span data-slate-leaf="true" data-offset-key="837:0" data-first-offset="true"><span 
class="se-860e2b4f" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">基于用户的协同过滤</span></span></span></span><span 
data-slate-object="text" data-key="838"><span data-slate-leaf="true" data-offset-key="838:0" 
data-first-offset="true"><span data-slate-string="true">（User CF，User Collaboration Filter）和</span></span></span><span 
data-slate-object="text" data-key="839"><span data-slate-leaf="true" data-offset-key="839:0" 
data-first-offset="true"><span class="se-04fa3005" data-slate-type="bold" data-slate-object="mark"><span 
data-slate-string="true">基于物品的协同过滤</span></span></span></span><span data-slate-object="text" 
data-key="840"><span data-slate-leaf="true" data-offset-key="840:0" data-first-offset="true"><span 
data-slate-string="true">（Item CF，Item Collaboration Filter）；另一类是升级版的</span></span></span><span 
data-slate-object="text" data-key="841"><span data-slate-leaf="true" data-offset-key="841:0" 
data-first-offset="true"><span class="se-e5ba8f35" data-slate-type="bold" data-slate-object="mark"><span 
data-slate-string="true">基于模型的 Model-based 的协同过滤算法</span></span></span></span><span data-slate-object="text" 
data-key="842"><span data-slate-leaf="true" data-offset-key="842:0" data-first-offset="true"><span 
data-slate-string="true">。今天，我们还是将重点放在协同过滤的基础算法，也就是 Memory-based 上，其他的就先不展开了。</span></span></span> 
</div> <h3 class="se-831fb7af" data-slate-type="heading" data-slate-object="block" data-key="843"><span 
data-slate-object="text" data-key="844"><span data-slate-leaf="true" data-offset-key="844:0" 
data-first-offset="true"><span data-slate-string="true">1. 基于用户的协同过滤</span></span></span></h3> 
<div class="se-8f19433c " data-slate-type="paragraph" data-slate-object="block" data-key="845"> 
<span data-slate-object="text" data-key="846"><span data-slate-leaf="true" data-offset-key="846:0" 
data-first-offset="true"><span data-slate-string="true">基于用户的协同过滤的思想其实并不复杂，说白了就是将和你相似的用户看过的文章也推荐给你。那在具体操作的时候会分为两步：</span></span></span> 
</div> <div class="se-a2b1c044" data-slate-type="list" data-slate-object="block" data-key="847"> 
<div class="se-2dc5293e" data-slate-type="list-line" data-slate-object="block" data-key="848"> 
<div class="se-12e9f9f4 se-a79162ab" data-code-line-number="1"></div> <div class="se-ceda0040"> 
<span data-slate-object="text" data-key="849"><span data-slate-leaf="true" data-offset-key="849:0" 
data-first-offset="true"><span data-slate-string="true">找到和你最相似的一批用户</span></span></span> </div> 
</div> <div class="se-ac1197d1" data-slate-type="list-line" data-slate-object="block" data-key="850"> 
<div class="se-1c8bbe46 se-5e9b852d" data-code-line-number="2"></div> <div class="se-4c94ce0b"> 
<span data-slate-object="text" data-key="851"><span data-slate-leaf="true" data-offset-key="851:0" 
data-first-offset="true"><span data-slate-string="true">将这批用户看过，但你没看过的文章推荐给你</span></span></span> 
</div> </div> </div> <div class="se-9dabd879 " data-slate-type="paragraph" data-slate-object="block" 
data-key="852"> <span data-slate-object="text" data-key="853"><span data-slate-leaf="true" 
data-offset-key="853:0" data-first-offset="true"><span data-slate-string="true">接下来，我们通过一个例子，来直观感受一下基于用户的协同过滤过程是怎么样的。</span></span></span> 
</div> <div class="se-657fe390 " data-slate-type="paragraph" data-slate-object="block" data-key="854"> 
<span data-slate-object="text" data-key="855"><span data-slate-leaf="true" data-offset-key="855:0" 
data-first-offset="true"><span data-slate-string="true">首先，如果 User 1 看过 Item 1 和 Item 2，而 User 
3 和 User 4 也看过 Item 1 和 Item 2，那么 User 1 和 User 3、User 4 就是相似用户。这样一来，如果 User 3 和 User 4 还分别看过 
Item 3 和 Item 4，我们就可以将 Item 3 和 Item 4 都推荐给 User 1 了。</span></span></span> </div> <div class="se-93f9f137" 
data-slate-type="image" data-slate-object="block" data-key="856"> <img class="se-496230fe" 
src="https://static001.geekbang.org/resource/image/58/9b/58b8909ea3e0b32b40afd4e97bbff79b.jpg"> 
<div class="se-3665dec8"> 基于用户的协同过滤 </div> </div> <div class="se-fe970073 " data-slate-type="paragraph" 
data-slate-object="block" data-key="857"> <span data-slate-object="text" data-key="858"><span 
data-slate-leaf="true" data-offset-key="858:0" data-first-offset="true"><span data-slate-string="true">在这个过程中，定义相似的用户并且将它们找出来是最重要的一步。那具体怎么做呢？我们先将上面的例子变成一个表格，这样看起来更清晰。</span></span></span> 
</div> <div class="se-c39b23ab" data-slate-type="image" data-slate-object="block" data-key="859"> 
<img class="se-10d7d18e" src="https://static001.geekbang.org/resource/image/91/5d/9110418a92bff7b28771b6baad1c0b5d.jpg"> 
</div> <div class="se-dab00839 " data-slate-type="paragraph" data-slate-object="block" data-key="860"> 
<span data-slate-object="text" data-key="861"><span data-slate-leaf="true" data-offset-key="861:0" 
data-first-offset="true"><span data-slate-string="true">你会看到，这个表格里的每篇文章下面都对应着一些数字，这其实就是每个用户对每篇文章的喜爱程度（具体可以通过用户的点击次数、收藏、评论和转发等行为计算出来的）。</span></span></span> 
</div> <div class="se-e8efa094 " data-slate-type="paragraph" data-slate-object="block" data-key="862"> 
<span data-slate-object="text" data-key="863"><span data-slate-leaf="true" data-offset-key="863:0" 
data-first-offset="true"><span data-slate-string="true">那基于这张表，如果要找出和 User 1 相似的用户，我们可以将 Item 
1 到 Item n 看作是一个 n 维空间，那每个用户都可以表示为 n 维空间中的一个向量，然后把他对这个物品的喜好程度，作为每个维度上的值。</span></span></span> 
</div> <div class="se-e36baafb " data-slate-type="paragraph" data-slate-object="block" data-key="864"> 
<span data-slate-object="text" data-key="865"><span data-slate-leaf="true" data-offset-key="865:0" 
data-first-offset="true"><span data-slate-string="true">这样一来，如何找到最相似的一批用户的问题，就变成了如何在 n 维向量空间中，找到和 
User 1 这个点最接近的点的问题。对于向量相似度，我们一般使用余弦距离来计算。</span></span></span> </div> <div class="se-3598db05" 
data-slate-type="image" data-slate-object="block" data-key="866"> <img class="se-b695323f" 
src="https://static001.geekbang.org/resource/image/1b/39/1ba92fde0deb2b95e52cd5feb46e5e39.jpg"> 
<div class="se-28de1b56"> 余弦距离公式 </div> </div> <div class="se-28f9a4c1 " data-slate-type="paragraph" 
data-slate-object="block" data-key="867"> <span data-slate-object="text" data-key="868"><span 
data-slate-leaf="true" data-offset-key="868:0" data-first-offset="true"><span data-slate-string="true">计算的过程我就不多说了，我直接把计算出来的相似度的结果告诉你。</span></span></span> 
</div> <div class="se-d287bf30" data-slate-type="image" data-slate-object="block" data-key="869"></div> 
</div>', body_summary='', bundle='book', delta=0, body_format='full_html', langcode='zh-hans', 
revision_id=1174 where entity_id=1174 
 {executed in 0 msec}
2020-11-25 10:35:04.548 INFO  jdbc.sqltiming Line:373 - select nodefiledd0_.nid as nid1_10_, nodefiledd0_.changed as changed2_10_, nodefiledd0_.created 
as created3_10_, nodefiledd0_.default_langcode as default_4_10_, nodefiledd0_.langcode as langcode5_10_, 
nodefiledd0_.promote as promote6_10_, nodefiledd0_.revision_translation_affected as revision7_10_, 
nodefiledd0_.status as status8_10_, nodefiledd0_.sticky as sticky9_10_, nodefiledd0_.title 
as title10_10_, nodefiledd0_.type as type11_10_, nodefiledd0_.uid as uid12_10_, nodefiledd0_.vid 
as vid13_10_ from node_field_data nodefiledd0_ where nodefiledd0_.nid=1174 
 {executed in 0 msec}
2020-11-25 10:35:04.548 INFO  jdbc.resultsettable Line:610 - 
|-----|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|-------------------------------|-----|----|-----|
|nid  |changed    |created    |default_langcode |langcode |promote |revision_translation_affected |status |sticky |title                          |type |uid |vid  |
|-----|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|-------------------------------|-----|----|-----|
|1174 |1606115450 |1606115450 |1                |zh-hans  |0       |1                             |1      |0      |20丨推荐引擎：没有搜索词，“头条”怎么找到你感兴趣的文章？ |book |1   |1174 |
|-----|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|-------------------------------|-----|----|-----|

2020-11-25 10:35:04.549 INFO  jdbc.sqltiming Line:373 - select nodefieldr0_.nid as nid1_11_0_, nodefieldr0_.changed as changed2_11_0_, nodefieldr0_.created 
as created3_11_0_, nodefieldr0_.default_langcode as default_4_11_0_, nodefieldr0_.langcode 
as langcode5_11_0_, nodefieldr0_.promote as promote6_11_0_, nodefieldr0_.revision_translation_affected 
as revision7_11_0_, nodefieldr0_.status as status8_11_0_, nodefieldr0_.sticky as sticky9_11_0_, 
nodefieldr0_.title as title10_11_0_, nodefieldr0_.uid as uid11_11_0_, nodefieldr0_.vid as vid12_11_0_ 
from node_field_revision nodefieldr0_ where nodefieldr0_.nid=1174 
 {executed in 0 msec}
2020-11-25 10:35:04.549 INFO  jdbc.resultsettable Line:610 - 
|---------|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|-------------------------------|----|-----|
|nid      |changed    |created    |default_langcode |langcode |promote |revision_translation_affected |status |sticky |title                          |uid |vid  |
|---------|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|-------------------------------|----|-----|
|[unread] |1606115450 |1606115450 |1                |zh-hans  |0       |1                             |1      |0      |20丨推荐引擎：没有搜索词，“头条”怎么找到你感兴趣的文章？ |1   |1174 |
|---------|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|-------------------------------|----|-----|

2020-11-25 10:35:04.551 INFO  jdbc.sqltiming Line:373 - update node_field_data set changed=1606271704, created=1606271704, default_langcode=1, langcode='zh-hans', 
promote=0, revision_translation_affected=1, status=1, sticky=0, title='20丨推荐引擎：没有搜索词，“头条”怎么找到你感兴趣的文章？', 
type='book', uid=1, vid=1174 where nid=1174 
 {executed in 0 msec}
2020-11-25 10:35:04.551 INFO  jdbc.sqltiming Line:373 - update node_field_revision set changed=1606271704, created=1606271704, default_langcode=1, 
langcode='zh-hans', promote=0, revision_translation_affected=1, status=1, sticky=0, title='20丨推荐引擎：没有搜索词，“头条”怎么找到你感兴趣的文章？', 
uid=1, vid=1174 where nid=1174 
 {executed in 0 msec}
2020-11-25 10:35:04.555 INFO  jdbc.sqltiming Line:373 - select bookfieldm0_.entity_id as entity_i1_8_, bookfieldm0_.bundle as bundle2_8_, bookfieldm0_.delta 
as delta3_8_, bookfieldm0_.langcode as langcode4_8_, bookfieldm0_.field_media_value as field_me5_8_, 
bookfieldm0_.revision_id as revision6_8_ from node__field_media bookfieldm0_ where bookfieldm0_.entity_id=1174 
 {executed in 0 msec}
2020-11-25 10:35:04.555 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------------|------------|
|entity_id |bundle |delta |langcode |field_media_value |revision_id |
|----------|-------|------|---------|------------------|------------|
|1174      |book   |0     |zh-hans  |                  |1174        |
|----------|-------|------|---------|------------------|------------|

2020-11-25 10:35:04.557 INFO  jdbc.sqltiming Line:373 - select nodefieldm0_.entity_id as entity_i1_17_0_, nodefieldm0_.bundle as bundle2_17_0_, nodefieldm0_.delta 
as delta3_17_0_, nodefieldm0_.langcode as langcode4_17_0_, nodefieldm0_.field_media_value as 
field_me5_17_0_, nodefieldm0_.revision_id as revision6_17_0_ from node_revision__field_media 
nodefieldm0_ where nodefieldm0_.entity_id=1174 
 {executed in 0 msec}
2020-11-25 10:35:04.557 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------------|------------|
|entity_id |bundle |delta |langcode |field_media_value |revision_id |
|----------|-------|------|---------|------------------|------------|
|[unread]  |book   |0     |zh-hans  |                  |1174        |
|----------|-------|------|---------|------------------|------------|

2020-11-25 10:35:04.559 INFO  jdbc.sqltiming Line:373 - select bookfieldc0_.entity_id as entity_i1_5_, bookfieldc0_.bundle as bundle2_5_, bookfieldc0_.field_comment_value 
as field_co3_5_, bookfieldc0_.delta as delta4_5_, bookfieldc0_.field_comment_format as field_co5_5_, 
bookfieldc0_.langcode as langcode6_5_, bookfieldc0_.revision_id as revision7_5_ from node__field_comment 
bookfieldc0_ where bookfieldc0_.entity_id=1174 
 {executed in 0 msec}
2020-11-25 10:35:04.559 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|--------------------|------|---------------------|---------|------------|
|entity_id |bundle |field_comment_value |delta |field_comment_format |langcode |revision_id |
|----------|-------|--------------------|------|---------------------|---------|------------|
|1174      |book   |                    |0     |full_html            |zh-hans  |1174        |
|----------|-------|--------------------|------|---------------------|---------|------------|

2020-11-25 10:35:04.561 INFO  jdbc.sqltiming Line:373 - select nodefieldc0_.entity_id as entity_i1_14_0_, nodefieldc0_.bundle as bundle2_14_0_, nodefieldc0_.field_comment_value 
as field_co3_14_0_, nodefieldc0_.delta as delta4_14_0_, nodefieldc0_.field_comment_format as 
field_co5_14_0_, nodefieldc0_.langcode as langcode6_14_0_, nodefieldc0_.revision_id as revision7_14_0_ 
from node_revision__field_comment nodefieldc0_ where nodefieldc0_.entity_id=1174 
 {executed in 0 msec}
2020-11-25 10:35:04.562 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|--------------------|------|---------------------|---------|------------|
|entity_id |bundle |field_comment_value |delta |field_comment_format |langcode |revision_id |
|----------|-------|--------------------|------|---------------------|---------|------------|
|[unread]  |book   |                    |0     |full_html            |zh-hans  |1174        |
|----------|-------|--------------------|------|---------------------|---------|------------|

2020-11-25 10:35:04.563 INFO  jdbc.sqltiming Line:373 - select bookfieldt0_.entity_id as entity_i1_9_, bookfieldt0_.bundle as bundle2_9_, bookfieldt0_.delta 
as delta3_9_, bookfieldt0_.langcode as langcode4_9_, bookfieldt0_.revision_id as revision5_9_, 
bookfieldt0_.field_thumb_value as field_th6_9_ from node__field_thumb bookfieldt0_ where bookfieldt0_.entity_id=1174 
 {executed in 0 msec}
2020-11-25 10:35:04.564 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------|------------------|
|entity_id |bundle |delta |langcode |revision_id |field_thumb_value |
|----------|-------|------|---------|------------|------------------|
|1174      |book   |0     |zh-hans  |1174        |                  |
|----------|-------|------|---------|------------|------------------|

2020-11-25 10:35:04.565 INFO  jdbc.sqltiming Line:373 - update node__field_thumb set bundle='book', delta=0, langcode='zh-hans', revision_id=1174, 
field_thumb_value='https://static001.geekbang.org/resource/image/1c/79/1cfb90f210b8014c9c183c93c2c05d79.jpg' 
where entity_id=1174 
 {executed in 0 msec}
2020-11-25 10:35:04.568 INFO  jdbc.sqltiming Line:373 - select nodefieldt0_.entity_id as entity_i1_18_0_, nodefieldt0_.bundle as bundle2_18_0_, nodefieldt0_.delta 
as delta3_18_0_, nodefieldt0_.langcode as langcode4_18_0_, nodefieldt0_.revision_id as revision5_18_0_, 
nodefieldt0_.field_thumb_value as field_th6_18_0_ from node_revision__field_thumb nodefieldt0_ 
where nodefieldt0_.entity_id=1174 
 {executed in 0 msec}
2020-11-25 10:35:04.568 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------|------------------|
|entity_id |bundle |delta |langcode |revision_id |field_thumb_value |
|----------|-------|------|---------|------------|------------------|
|[unread]  |book   |0     |zh-hans  |1174        |                  |
|----------|-------|------|---------|------------|------------------|

2020-11-25 10:35:04.570 INFO  jdbc.sqltiming Line:373 - update node_revision__field_thumb set bundle='book', delta=0, langcode='zh-hans', revision_id=1174, 
field_thumb_value='https://static001.geekbang.org/resource/image/1c/79/1cfb90f210b8014c9c183c93c2c05d79.jpg' 
where entity_id=1174 
 {executed in 0 msec}
2020-11-25 10:35:04.573 INFO  jdbc.sqltiming Line:373 - select bookfieldf0_.entity_id as entity_i1_6_0_, bookfieldf0_.bundle as bundle2_6_0_, bookfieldf0_.delta 
as delta3_6_0_, bookfieldf0_.field_fenlei_target_id as field_fe4_6_0_, bookfieldf0_.langcode 
as langcode5_6_0_, bookfieldf0_.revision_id as revision6_6_0_ from node__field_fenlei bookfieldf0_ 
where bookfieldf0_.entity_id=1174 
 {executed in 1 msec}
2020-11-25 10:35:04.573 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|-----------------------|---------|------------|
|entity_id |bundle |delta |field_fenlei_target_id |langcode |revision_id |
|----------|-------|------|-----------------------|---------|------------|
|[unread]  |book   |0     |1                      |zh-hans  |1174        |
|----------|-------|------|-----------------------|---------|------------|

2020-11-25 10:35:04.575 INFO  jdbc.sqltiming Line:373 - select nodefieldf0_.entity_id as entity_i1_15_0_, nodefieldf0_.bundle as bundle2_15_0_, nodefieldf0_.delta 
as delta3_15_0_, nodefieldf0_.field_fenlei_target_id as field_fe4_15_0_, nodefieldf0_.langcode 
as langcode5_15_0_, nodefieldf0_.revision_id as revision6_15_0_ from node_revision__field_fenlei 
nodefieldf0_ where nodefieldf0_.entity_id=1174 
 {executed in 1 msec}
2020-11-25 10:35:04.575 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|-----------------------|---------|------------|
|entity_id |bundle |delta |field_fenlei_target_id |langcode |revision_id |
|----------|-------|------|-----------------------|---------|------------|
|[unread]  |book   |0     |1                      |zh-hans  |1174        |
|----------|-------|------|-----------------------|---------|------------|

2020-11-25 10:35:04.577 INFO  jdbc.sqltiming Line:373 - select bookchecke0_.item_id as item_id1_2_, bookchecke0_.fsid as fsid2_2_, bookchecke0_.got 
as got3_2_, bookchecke0_.name as name4_2_, bookchecke0_.parse_fail as parse_fa5_2_, bookchecke0_.parsed 
as parsed6_2_, bookchecke0_.path as path7_2_, bookchecke0_.title as title8_2_, bookchecke0_.vid 
as vid9_2_ from book_check bookchecke0_ where bookchecke0_.fsid='18053060793446' and bookchecke0_.name='net_content' 
 {executed in 0 msec}
2020-11-25 10:35:04.577 INFO  jdbc.resultsettable Line:610 - 
|--------|---------|---------|---------|-----------|---------|---------|---------|---------|
|item_id |fsid     |got      |name     |parse_fail |parsed   |path     |title    |vid      |
|--------|---------|---------|---------|-----------|---------|---------|---------|---------|
|1175    |[unread] |[unread] |[unread] |[unread]   |[unread] |[unread] |[unread] |[unread] |
|--------|---------|---------|---------|-----------|---------|---------|---------|---------|

2020-11-25 10:35:32.853 INFO  jdbc.sqltiming Line:373 - update book_check set fsid='18053060793446', got=1, name='net_content', parse_fail='', parsed=1, 
path='123-检索技术核心20讲/05丨结束语 (2讲)/结束语丨成长和进化，技术如此，我们亦如此.html', title='结束语丨成长和进化，技术如此，我们亦如此', vid=1175 
where item_id=1175 
 {executed in 0 msec}
2020-11-25 10:35:32.861 INFO  jdbc.sqltiming Line:373 - select nodebodyen0_.entity_id as entity_i1_4_, nodebodyen0_.body_value as body_val2_4_, nodebodyen0_.body_summary 
as body_sum3_4_, nodebodyen0_.bundle as bundle4_4_, nodebodyen0_.delta as delta5_4_, nodebodyen0_.body_format 
as body_for6_4_, nodebodyen0_.langcode as langcode7_4_, nodebodyen0_.revision_id as revision8_4_ 
from node__body nodebodyen0_ where nodebodyen0_.entity_id=1175 
 {executed in 0 msec}
2020-11-25 10:35:32.862 INFO  jdbc.resultsettable Line:610 - 
|----------|-----------|-------------|-------|------|------------|---------|------------|
|entity_id |body_value |body_summary |bundle |delta |body_format |langcode |revision_id |
|----------|-----------|-------------|-------|------|------------|---------|------------|
|1175      |           |             |book   |0     |full_html   |zh-hans  |1175        |
|----------|-----------|-------------|-------|------|------------|---------|------------|

2020-11-25 10:35:32.862 INFO  jdbc.sqltiming Line:373 - select nodebodyre0_.entity_id as entity_i1_13_0_, nodebodyre0_.body_value as body_val2_13_0_, 
nodebodyre0_.body_summary as body_sum3_13_0_, nodebodyre0_.bundle as bundle4_13_0_, nodebodyre0_.delta 
as delta5_13_0_, nodebodyre0_.body_format as body_for6_13_0_, nodebodyre0_.langcode as langcode7_13_0_, 
nodebodyre0_.revision_id as revision8_13_0_ from node_revision__body nodebodyre0_ where nodebodyre0_.entity_id=1175 
 {executed in 0 msec}
2020-11-25 10:35:32.862 INFO  jdbc.resultsettable Line:610 - 
|----------|-----------|-------------|-------|------|------------|---------|------------|
|entity_id |body_value |body_summary |bundle |delta |body_format |langcode |revision_id |
|----------|-----------|-------------|-------|------|------------|---------|------------|
|[unread]  |           |             |book   |0     |full_html   |zh-hans  |1175        |
|----------|-----------|-------------|-------|------|------------|---------|------------|

2020-11-25 10:35:32.864 INFO  jdbc.sqltiming Line:373 - update node__body set body_value='<div data-slate-editor="true" data-key="1249" autocorrect="off" 
spellcheck="false" data-gramm="false" style="outline: none; white-space: pre-wrap; overflow-wrap: 
break-word;"> <div class="se-a2b000d5 " data-slate-type="paragraph" data-slate-object="block" 
data-key="1250"> <span data-slate-object="text" data-key="1251"><span data-slate-leaf="true" 
data-offset-key="1251:0" data-first-offset="true"><span data-slate-string="true">你好，我是陈东。今天，我们走到了这个专栏的最后一个篇章。</span></span></span> 
</div> <div class="se-c74c2c5b " data-slate-type="paragraph" data-slate-object="block" data-key="1252"> 
<span data-slate-object="text" data-key="1253"><span data-slate-leaf="true" data-offset-key="1253:0" 
data-first-offset="true"><span data-slate-string="true">一起学习的五十多个日夜，我们从熟悉的数组和链表开始，学到了搜索引擎、广告引擎以及推荐引擎。这就像一场长途跋涉，一路上景色不停切换，不变的，是我们探索这个信息世界的好奇心。</span></span></span> 
</div> <div class="se-b345e45f " data-slate-type="paragraph" data-slate-object="block" data-key="1254"> 
<span data-slate-object="text" data-key="1255"><span data-slate-leaf="true" data-offset-key="1255:0" 
data-first-offset="true"><span data-slate-string="true">在我看来，信息是构成世界的一个重要维度。实际上，人类文明的开始，就是以拥有了语言和文字为标志的。因为语言和文字的出现，才使得信息可以被记录和传播，文明得以传承和发展。</span></span></span> 
</div> <div class="se-17d14088 " data-slate-type="paragraph" data-slate-object="block" data-key="1256"> 
<span data-slate-object="text" data-key="1257"><span data-slate-leaf="true" data-offset-key="1257:0" 
data-first-offset="true"><span data-slate-string="true">而随着 IT 技术的发展，信息的产生速度也越来越快。有报告说，现在 18 
个月产生的信息比过去 5000 年产生的信息总量还大。并且，随着互联网的普及和发展，最近每年的信息增长率达到了 50% 以上。我们可以预见 5G 普及之后的未来，信息生产的速度只会越来越快。那么，这么多的信息都有用吗？我觉得不见得。当信息变得庞杂了以后，相应地，信息的含金量就变低了。只有高效地将信息进行检索和提炼，才能取出我们需要的信息，这样的信息才是最有价值的。</span></span></span> 
</div> <div class="se-5c4b1381 " data-slate-type="paragraph" data-slate-object="block" data-key="1258"> 
<span data-slate-object="text" data-key="1259"><span data-slate-leaf="true" data-offset-key="1259:0" 
data-first-offset="true"><span data-slate-string="true">在专栏中，我们提到的许多系统都为了“如何高效检索信息”这个基础却又终极的问题，做了精心的设计，从而帮助我们高效地处理信息。</span></span></span><span 
data-slate-object="text" data-key="1260"><span data-slate-leaf="true" data-offset-key="1260:0" 
data-first-offset="true"><span class="se-c2c28f91" data-slate-type="bold" data-slate-object="mark"><span 
data-slate-string="true">系统如此，人亦是如此</span></span></span></span><span data-slate-object="text" 
data-key="1261"><span data-slate-leaf="true" data-offset-key="1261:0" data-first-offset="true"><span 
data-slate-string="true">。</span></span></span> </div> <div class="se-2166ecaf " data-slate-type="paragraph" 
data-slate-object="block" data-key="1262"> <span data-slate-object="text" data-key="1263"><span 
data-slate-leaf="true" data-offset-key="1263:0" data-first-offset="true"><span data-slate-string="true">在信息泛滥的时代，每个人都有大量的渠道可以接触到大量的信息。如果不进行筛选处理，你的 
CPU 根本负荷不过来。比如说，如果你接触的信息都是各种八卦新闻、娱乐视频。那么，你能花在处理专业知识信息上的时间就会变少。甚至在遇到一些虚假信息的时候，如果你不加辨别就接收，这很可能会带来一些负面影响。</span></span></span> 
</div> <div class="se-2dba6c0f " data-slate-type="paragraph" data-slate-object="block" data-key="1264"> 
<span data-slate-object="text" data-key="1265"><span data-slate-leaf="true" data-offset-key="1265:0" 
data-first-offset="true"><span data-slate-string="true">所以我们说</span></span></span><span data-slate-object="text" 
data-key="1266"><span data-slate-leaf="true" data-offset-key="1266:0" data-first-offset="true"><span 
class="se-cbb9a7a1" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">这是一个最好的时代，这也是一个最坏的时代</span></span></span></span><span 
data-slate-object="text" data-key="1267"><span data-slate-leaf="true" data-offset-key="1267:0" 
data-first-offset="true"><span data-slate-string="true">。好的地方在于，有了足够的信息供我们学习和娱乐；坏的地方在于，对于信息的选择和使用，会变成一个更困难的事情，利用不好，甚至会带来负面影响。</span></span></span><span 
data-slate-object="text" data-key="1268"><span data-slate-leaf="true" data-offset-key="1268:0" 
data-first-offset="true"><span class="se-2b18ab71" data-slate-type="bold" data-slate-object="mark"><span 
data-slate-string="true">因此，我们也要构建起自己思维的检索引擎，学会将有价值的信息提取出来，并加以处理和使用。这样，我们才会不断地前进</span></span></span></span><span 
data-slate-object="text" data-key="1269"><span data-slate-leaf="true" data-offset-key="1269:0" 
data-first-offset="true"><span data-slate-string="true">。</span></span></span> </div> <div 
class="se-ecebac84 " data-slate-type="paragraph" data-slate-object="block" data-key="1270"> 
<span data-slate-object="text" data-key="1271"><span data-slate-leaf="true" data-offset-key="1271:0" 
data-first-offset="true"><span data-slate-string="true">那无论是系统还是人，我们的前进都必须是跟随着时代的脚步。如果你研究过某一个技术的发展史，你就会对这一点有更深的体会了。其实，在专栏中就隐藏着一条检索技术发展进化的时间线。下面，我来带你回顾一下。</span></span></span> 
</div> <div class="se-c22d8d20 " data-slate-type="paragraph" data-slate-object="block" data-key="1272"> 
<span data-slate-object="text" data-key="1273"><span data-slate-leaf="true" data-offset-key="1273:0" 
data-first-offset="true"><span data-slate-string="true">在人类发明了文字以后，书的目录索引和图书馆的图书分类管理，其实就是检索技术在印刷时代的体现。</span></span></span> 
</div> <div class="se-cb1fcb63 " data-slate-type="paragraph" data-slate-object="block" data-key="1274"> 
<span data-slate-object="text" data-key="1275"><span data-slate-leaf="true" data-offset-key="1275:0" 
data-first-offset="true"><span data-slate-string="true">随着 IT 技术的兴起，信息数字化的变革开始催生出了像数据库这样的系统和 
B+ 树这些检索技术。</span></span></span> </div> <div class="se-0b2f5657 " data-slate-type="paragraph" 
data-slate-object="block" data-key="1276"> <span data-slate-object="text" data-key="1277"><span 
data-slate-leaf="true" data-offset-key="1277:0" data-first-offset="true"><span data-slate-string="true">进入互联网时代后，我们开始处理大数据。无论是基于 
LSM 树的存储系统，还是以搜索引擎为代表的检索技术，都是互联网时代的结晶。</span></span></span> </div> <div class="se-84339855 
" data-slate-type="paragraph" data-slate-object="block" data-key="1278"> <span data-slate-object="text" 
data-key="1279"><span data-slate-leaf="true" data-offset-key="1279:0" data-first-offset="true"><span 
data-slate-string="true">到了移动互联网时代，各种基于地理位置的服务不断出现，让我们开始将物理世界和信息世界更紧密地连接在一起。</span></span></span> 
</div> <div class="se-b05c0f30 " data-slate-type="paragraph" data-slate-object="block" data-key="1280"> 
<span data-slate-object="text" data-key="1281"><span data-slate-leaf="true" data-offset-key="1281:0" 
data-first-offset="true"><span data-slate-string="true">现在到了 AI 时代，图像识别、人脸识别和智能推荐的发展，又催生出了和深度学习结合的检索系统。</span></span></span> 
</div> <div class="se-f3f7b2e8 " data-slate-type="paragraph" data-slate-object="block" data-key="1282"> 
<span data-slate-object="text" data-key="1283"><span data-slate-leaf="true" data-offset-key="1283:0" 
data-first-offset="true"><span data-slate-string="true">检索技术越发展，涉及的知识越新，你就会感觉越陌生。实际上这很正常，毕竟新生事物要变得普及需要经过时间的发酵。但我们必须保证，我们的认知是随着时代的前进一起进化的。因为一旦我们放弃去学习、去进化，那我们不可避免地就会错过很多机会，甚至会做错许多决策。</span></span></span> 
</div> <div class="se-89e1c1b5 " data-slate-type="paragraph" data-slate-object="block" data-key="1284"> 
<span data-slate-object="text" data-key="1285"><span data-slate-leaf="true" data-offset-key="1285:0" 
data-first-offset="true"><span data-slate-string="true">因此，面对新生的事物，我们在保持好奇心的同时，还要去升级自己思维的检索引擎，使得我们的认知能跟得上时代的发展。甚至，如果学习的过程能够快人一步，那我们就会享受到时代更多的红利。</span></span></span> 
</div> <div class="se-86d434e8 " data-slate-type="paragraph" data-slate-object="block" data-key="1286"> 
<span data-slate-object="text" data-key="1287"><span data-slate-leaf="true" data-offset-key="1287:0" 
data-first-offset="true"><span data-slate-string="true">好了，说了这么多自我进化的好处。那不断地升级自己的检索引擎，是不是一件很困难的事情呢？完全重构系统的确是一个代价很大的事情，但是在已有系统上进行迭代升级，相对来说会容易许多。</span></span></span> 
</div> <div class="se-2454cb60 " data-slate-type="paragraph" data-slate-object="block" data-key="1288"> 
<span data-slate-object="text" data-key="1289"><span data-slate-leaf="true" data-offset-key="1289:0" 
data-first-offset="true"><span data-slate-string="true">因为，许多所谓的新技术和新系统，都是在一些基础技术上进行组合和微创新得到的。比如，我在加餐 
1 中提到的 Roaring Bitmap。它在 2016 年才被发明出来，但是它用到的技术，其实就是很成熟的检索系统中的位图法、哈希表法、跳表法以及倒排索引。还有我们说过的向量检索，其实向量这个数学工具也不是新东西了，只是在近期随着 
AI 的发展，才被更广泛地应用起来。</span></span></span> </div> <div class="se-d0e6c95b " data-slate-type="paragraph" 
data-slate-object="block" data-key="1290"> <span data-slate-object="text" data-key="1291"><span 
data-slate-leaf="true" data-offset-key="1291:0" data-first-offset="true"><span data-slate-string="true">既然新的技术和系统并不难学，那我们到底该怎么学呢？其实，学习和成长就像是爬台阶。高处的目标虽然看上去遥不可及，但只要我们一个台阶一个台阶地往上走，等我们站到了一个足够的高度上再前进就会容易很多。就像让你直接学习 
AVL 树和红黑树会很难，但当你了解了二叉检索树的原理和问题以后，再去学习就会简单很多。因此，当你了解了检索中的各种问题和相应技术以后，再去搭建自己的检索系统，或者学习使用开源的检索工具，也就更容易上手。</span></span></span> 
</div> <div class="se-c2c86293 " data-slate-type="paragraph" data-slate-object="block" data-key="1292"> 
<span data-slate-object="text" data-key="1293"><span data-slate-leaf="true" data-offset-key="1293:0" 
data-first-offset="true"><span data-slate-string="true">也正是因为如此，许多高手在面对新事物的时候，能使用自己思维的检索引擎，快速找到核心点去学习和消化，从而可以更上一层楼。</span></span></span> 
</div> <div class="se-8e3d826b " data-slate-type="paragraph" data-slate-object="block" data-key="1294"> 
<span data-slate-object="text" data-key="1295"><span data-slate-leaf="true" data-offset-key="1295:0" 
data-first-offset="true"><span data-slate-string="true">总结来说，成长和进化从来不是一件容易的事情，但只要你能构建起自己认知的检索思维，不断地从海量的信息中快速汲取新的知识，并且从打好地基做起，构建起自己的知识体系。我相信，迈上一个更高的台阶，是一个完全可以预期的事情。</span></span></span> 
</div> <div class="se-f0186966 " data-slate-type="paragraph" data-slate-object="block" data-key="1296"> 
<span data-slate-object="text" data-key="1297"><span data-slate-leaf="true" data-offset-key="1297:0" 
data-first-offset="true"><span data-slate-string="true">虽然检索技术专栏结束了，但是我希望这个专栏对你的帮助并没有就此停止。学习之路没有终点，保持探索和进化，才是我们成长的终极密码。</span></span></span> 
</div> <div class="se-d15fdb66" data-slate-type="image" data-slate-object="block" data-key="1298"> 
<a href="https://jinshuju.net/f/Rrc1Tx"><img class="se-c2f45446" src="https://static001.geekbang.org/resource/image/a7/0b/a7ff072d8c6648b327824882fedc1e0b.jpg"></a> 
</div> </div>', body_summary='', bundle='book', delta=0, body_format='full_html', langcode='zh-hans', 
revision_id=1175 where entity_id=1175 
 {executed in 1 msec}
2020-11-25 10:35:32.865 INFO  jdbc.sqltiming Line:373 - update node_revision__body set body_value='<div data-slate-editor="true" data-key="1249" autocorrect="off" 
spellcheck="false" data-gramm="false" style="outline: none; white-space: pre-wrap; overflow-wrap: 
break-word;"> <div class="se-a2b000d5 " data-slate-type="paragraph" data-slate-object="block" 
data-key="1250"> <span data-slate-object="text" data-key="1251"><span data-slate-leaf="true" 
data-offset-key="1251:0" data-first-offset="true"><span data-slate-string="true">你好，我是陈东。今天，我们走到了这个专栏的最后一个篇章。</span></span></span> 
</div> <div class="se-c74c2c5b " data-slate-type="paragraph" data-slate-object="block" data-key="1252"> 
<span data-slate-object="text" data-key="1253"><span data-slate-leaf="true" data-offset-key="1253:0" 
data-first-offset="true"><span data-slate-string="true">一起学习的五十多个日夜，我们从熟悉的数组和链表开始，学到了搜索引擎、广告引擎以及推荐引擎。这就像一场长途跋涉，一路上景色不停切换，不变的，是我们探索这个信息世界的好奇心。</span></span></span> 
</div> <div class="se-b345e45f " data-slate-type="paragraph" data-slate-object="block" data-key="1254"> 
<span data-slate-object="text" data-key="1255"><span data-slate-leaf="true" data-offset-key="1255:0" 
data-first-offset="true"><span data-slate-string="true">在我看来，信息是构成世界的一个重要维度。实际上，人类文明的开始，就是以拥有了语言和文字为标志的。因为语言和文字的出现，才使得信息可以被记录和传播，文明得以传承和发展。</span></span></span> 
</div> <div class="se-17d14088 " data-slate-type="paragraph" data-slate-object="block" data-key="1256"> 
<span data-slate-object="text" data-key="1257"><span data-slate-leaf="true" data-offset-key="1257:0" 
data-first-offset="true"><span data-slate-string="true">而随着 IT 技术的发展，信息的产生速度也越来越快。有报告说，现在 18 
个月产生的信息比过去 5000 年产生的信息总量还大。并且，随着互联网的普及和发展，最近每年的信息增长率达到了 50% 以上。我们可以预见 5G 普及之后的未来，信息生产的速度只会越来越快。那么，这么多的信息都有用吗？我觉得不见得。当信息变得庞杂了以后，相应地，信息的含金量就变低了。只有高效地将信息进行检索和提炼，才能取出我们需要的信息，这样的信息才是最有价值的。</span></span></span> 
</div> <div class="se-5c4b1381 " data-slate-type="paragraph" data-slate-object="block" data-key="1258"> 
<span data-slate-object="text" data-key="1259"><span data-slate-leaf="true" data-offset-key="1259:0" 
data-first-offset="true"><span data-slate-string="true">在专栏中，我们提到的许多系统都为了“如何高效检索信息”这个基础却又终极的问题，做了精心的设计，从而帮助我们高效地处理信息。</span></span></span><span 
data-slate-object="text" data-key="1260"><span data-slate-leaf="true" data-offset-key="1260:0" 
data-first-offset="true"><span class="se-c2c28f91" data-slate-type="bold" data-slate-object="mark"><span 
data-slate-string="true">系统如此，人亦是如此</span></span></span></span><span data-slate-object="text" 
data-key="1261"><span data-slate-leaf="true" data-offset-key="1261:0" data-first-offset="true"><span 
data-slate-string="true">。</span></span></span> </div> <div class="se-2166ecaf " data-slate-type="paragraph" 
data-slate-object="block" data-key="1262"> <span data-slate-object="text" data-key="1263"><span 
data-slate-leaf="true" data-offset-key="1263:0" data-first-offset="true"><span data-slate-string="true">在信息泛滥的时代，每个人都有大量的渠道可以接触到大量的信息。如果不进行筛选处理，你的 
CPU 根本负荷不过来。比如说，如果你接触的信息都是各种八卦新闻、娱乐视频。那么，你能花在处理专业知识信息上的时间就会变少。甚至在遇到一些虚假信息的时候，如果你不加辨别就接收，这很可能会带来一些负面影响。</span></span></span> 
</div> <div class="se-2dba6c0f " data-slate-type="paragraph" data-slate-object="block" data-key="1264"> 
<span data-slate-object="text" data-key="1265"><span data-slate-leaf="true" data-offset-key="1265:0" 
data-first-offset="true"><span data-slate-string="true">所以我们说</span></span></span><span data-slate-object="text" 
data-key="1266"><span data-slate-leaf="true" data-offset-key="1266:0" data-first-offset="true"><span 
class="se-cbb9a7a1" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">这是一个最好的时代，这也是一个最坏的时代</span></span></span></span><span 
data-slate-object="text" data-key="1267"><span data-slate-leaf="true" data-offset-key="1267:0" 
data-first-offset="true"><span data-slate-string="true">。好的地方在于，有了足够的信息供我们学习和娱乐；坏的地方在于，对于信息的选择和使用，会变成一个更困难的事情，利用不好，甚至会带来负面影响。</span></span></span><span 
data-slate-object="text" data-key="1268"><span data-slate-leaf="true" data-offset-key="1268:0" 
data-first-offset="true"><span class="se-2b18ab71" data-slate-type="bold" data-slate-object="mark"><span 
data-slate-string="true">因此，我们也要构建起自己思维的检索引擎，学会将有价值的信息提取出来，并加以处理和使用。这样，我们才会不断地前进</span></span></span></span><span 
data-slate-object="text" data-key="1269"><span data-slate-leaf="true" data-offset-key="1269:0" 
data-first-offset="true"><span data-slate-string="true">。</span></span></span> </div> <div 
class="se-ecebac84 " data-slate-type="paragraph" data-slate-object="block" data-key="1270"> 
<span data-slate-object="text" data-key="1271"><span data-slate-leaf="true" data-offset-key="1271:0" 
data-first-offset="true"><span data-slate-string="true">那无论是系统还是人，我们的前进都必须是跟随着时代的脚步。如果你研究过某一个技术的发展史，你就会对这一点有更深的体会了。其实，在专栏中就隐藏着一条检索技术发展进化的时间线。下面，我来带你回顾一下。</span></span></span> 
</div> <div class="se-c22d8d20 " data-slate-type="paragraph" data-slate-object="block" data-key="1272"> 
<span data-slate-object="text" data-key="1273"><span data-slate-leaf="true" data-offset-key="1273:0" 
data-first-offset="true"><span data-slate-string="true">在人类发明了文字以后，书的目录索引和图书馆的图书分类管理，其实就是检索技术在印刷时代的体现。</span></span></span> 
</div> <div class="se-cb1fcb63 " data-slate-type="paragraph" data-slate-object="block" data-key="1274"> 
<span data-slate-object="text" data-key="1275"><span data-slate-leaf="true" data-offset-key="1275:0" 
data-first-offset="true"><span data-slate-string="true">随着 IT 技术的兴起，信息数字化的变革开始催生出了像数据库这样的系统和 
B+ 树这些检索技术。</span></span></span> </div> <div class="se-0b2f5657 " data-slate-type="paragraph" 
data-slate-object="block" data-key="1276"> <span data-slate-object="text" data-key="1277"><span 
data-slate-leaf="true" data-offset-key="1277:0" data-first-offset="true"><span data-slate-string="true">进入互联网时代后，我们开始处理大数据。无论是基于 
LSM 树的存储系统，还是以搜索引擎为代表的检索技术，都是互联网时代的结晶。</span></span></span> </div> <div class="se-84339855 
" data-slate-type="paragraph" data-slate-object="block" data-key="1278"> <span data-slate-object="text" 
data-key="1279"><span data-slate-leaf="true" data-offset-key="1279:0" data-first-offset="true"><span 
data-slate-string="true">到了移动互联网时代，各种基于地理位置的服务不断出现，让我们开始将物理世界和信息世界更紧密地连接在一起。</span></span></span> 
</div> <div class="se-b05c0f30 " data-slate-type="paragraph" data-slate-object="block" data-key="1280"> 
<span data-slate-object="text" data-key="1281"><span data-slate-leaf="true" data-offset-key="1281:0" 
data-first-offset="true"><span data-slate-string="true">现在到了 AI 时代，图像识别、人脸识别和智能推荐的发展，又催生出了和深度学习结合的检索系统。</span></span></span> 
</div> <div class="se-f3f7b2e8 " data-slate-type="paragraph" data-slate-object="block" data-key="1282"> 
<span data-slate-object="text" data-key="1283"><span data-slate-leaf="true" data-offset-key="1283:0" 
data-first-offset="true"><span data-slate-string="true">检索技术越发展，涉及的知识越新，你就会感觉越陌生。实际上这很正常，毕竟新生事物要变得普及需要经过时间的发酵。但我们必须保证，我们的认知是随着时代的前进一起进化的。因为一旦我们放弃去学习、去进化，那我们不可避免地就会错过很多机会，甚至会做错许多决策。</span></span></span> 
</div> <div class="se-89e1c1b5 " data-slate-type="paragraph" data-slate-object="block" data-key="1284"> 
<span data-slate-object="text" data-key="1285"><span data-slate-leaf="true" data-offset-key="1285:0" 
data-first-offset="true"><span data-slate-string="true">因此，面对新生的事物，我们在保持好奇心的同时，还要去升级自己思维的检索引擎，使得我们的认知能跟得上时代的发展。甚至，如果学习的过程能够快人一步，那我们就会享受到时代更多的红利。</span></span></span> 
</div> <div class="se-86d434e8 " data-slate-type="paragraph" data-slate-object="block" data-key="1286"> 
<span data-slate-object="text" data-key="1287"><span data-slate-leaf="true" data-offset-key="1287:0" 
data-first-offset="true"><span data-slate-string="true">好了，说了这么多自我进化的好处。那不断地升级自己的检索引擎，是不是一件很困难的事情呢？完全重构系统的确是一个代价很大的事情，但是在已有系统上进行迭代升级，相对来说会容易许多。</span></span></span> 
</div> <div class="se-2454cb60 " data-slate-type="paragraph" data-slate-object="block" data-key="1288"> 
<span data-slate-object="text" data-key="1289"><span data-slate-leaf="true" data-offset-key="1289:0" 
data-first-offset="true"><span data-slate-string="true">因为，许多所谓的新技术和新系统，都是在一些基础技术上进行组合和微创新得到的。比如，我在加餐 
1 中提到的 Roaring Bitmap。它在 2016 年才被发明出来，但是它用到的技术，其实就是很成熟的检索系统中的位图法、哈希表法、跳表法以及倒排索引。还有我们说过的向量检索，其实向量这个数学工具也不是新东西了，只是在近期随着 
AI 的发展，才被更广泛地应用起来。</span></span></span> </div> <div class="se-d0e6c95b " data-slate-type="paragraph" 
data-slate-object="block" data-key="1290"> <span data-slate-object="text" data-key="1291"><span 
data-slate-leaf="true" data-offset-key="1291:0" data-first-offset="true"><span data-slate-string="true">既然新的技术和系统并不难学，那我们到底该怎么学呢？其实，学习和成长就像是爬台阶。高处的目标虽然看上去遥不可及，但只要我们一个台阶一个台阶地往上走，等我们站到了一个足够的高度上再前进就会容易很多。就像让你直接学习 
AVL 树和红黑树会很难，但当你了解了二叉检索树的原理和问题以后，再去学习就会简单很多。因此，当你了解了检索中的各种问题和相应技术以后，再去搭建自己的检索系统，或者学习使用开源的检索工具，也就更容易上手。</span></span></span> 
</div> <div class="se-c2c86293 " data-slate-type="paragraph" data-slate-object="block" data-key="1292"> 
<span data-slate-object="text" data-key="1293"><span data-slate-leaf="true" data-offset-key="1293:0" 
data-first-offset="true"><span data-slate-string="true">也正是因为如此，许多高手在面对新事物的时候，能使用自己思维的检索引擎，快速找到核心点去学习和消化，从而可以更上一层楼。</span></span></span> 
</div> <div class="se-8e3d826b " data-slate-type="paragraph" data-slate-object="block" data-key="1294"> 
<span data-slate-object="text" data-key="1295"><span data-slate-leaf="true" data-offset-key="1295:0" 
data-first-offset="true"><span data-slate-string="true">总结来说，成长和进化从来不是一件容易的事情，但只要你能构建起自己认知的检索思维，不断地从海量的信息中快速汲取新的知识，并且从打好地基做起，构建起自己的知识体系。我相信，迈上一个更高的台阶，是一个完全可以预期的事情。</span></span></span> 
</div> <div class="se-f0186966 " data-slate-type="paragraph" data-slate-object="block" data-key="1296"> 
<span data-slate-object="text" data-key="1297"><span data-slate-leaf="true" data-offset-key="1297:0" 
data-first-offset="true"><span data-slate-string="true">虽然检索技术专栏结束了，但是我希望这个专栏对你的帮助并没有就此停止。学习之路没有终点，保持探索和进化，才是我们成长的终极密码。</span></span></span> 
</div> <div class="se-d15fdb66" data-slate-type="image" data-slate-object="block" data-key="1298"> 
<a href="https://jinshuju.net/f/Rrc1Tx"><img class="se-c2f45446" src="https://static001.geekbang.org/resource/image/a7/0b/a7ff072d8c6648b327824882fedc1e0b.jpg"></a> 
</div> </div>', body_summary='', bundle='book', delta=0, body_format='full_html', langcode='zh-hans', 
revision_id=1175 where entity_id=1175 
 {executed in 1 msec}
2020-11-25 10:35:32.870 INFO  jdbc.sqltiming Line:373 - select nodefiledd0_.nid as nid1_10_, nodefiledd0_.changed as changed2_10_, nodefiledd0_.created 
as created3_10_, nodefiledd0_.default_langcode as default_4_10_, nodefiledd0_.langcode as langcode5_10_, 
nodefiledd0_.promote as promote6_10_, nodefiledd0_.revision_translation_affected as revision7_10_, 
nodefiledd0_.status as status8_10_, nodefiledd0_.sticky as sticky9_10_, nodefiledd0_.title 
as title10_10_, nodefiledd0_.type as type11_10_, nodefiledd0_.uid as uid12_10_, nodefiledd0_.vid 
as vid13_10_ from node_field_data nodefiledd0_ where nodefiledd0_.nid=1175 
 {executed in 0 msec}
2020-11-25 10:35:32.870 INFO  jdbc.resultsettable Line:610 - 
|-----|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|---------------------|-----|----|-----|
|nid  |changed    |created    |default_langcode |langcode |promote |revision_translation_affected |status |sticky |title                |type |uid |vid  |
|-----|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|---------------------|-----|----|-----|
|1175 |1606115457 |1606115457 |1                |zh-hans  |0       |1                             |1      |0      |结束语丨成长和进化，技术如此，我们亦如此 |book |1   |1175 |
|-----|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|---------------------|-----|----|-----|

2020-11-25 10:35:32.871 INFO  jdbc.sqltiming Line:373 - select nodefieldr0_.nid as nid1_11_0_, nodefieldr0_.changed as changed2_11_0_, nodefieldr0_.created 
as created3_11_0_, nodefieldr0_.default_langcode as default_4_11_0_, nodefieldr0_.langcode 
as langcode5_11_0_, nodefieldr0_.promote as promote6_11_0_, nodefieldr0_.revision_translation_affected 
as revision7_11_0_, nodefieldr0_.status as status8_11_0_, nodefieldr0_.sticky as sticky9_11_0_, 
nodefieldr0_.title as title10_11_0_, nodefieldr0_.uid as uid11_11_0_, nodefieldr0_.vid as vid12_11_0_ 
from node_field_revision nodefieldr0_ where nodefieldr0_.nid=1175 
 {executed in 0 msec}
2020-11-25 10:35:32.872 INFO  jdbc.resultsettable Line:610 - 
|---------|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|---------------------|----|-----|
|nid      |changed    |created    |default_langcode |langcode |promote |revision_translation_affected |status |sticky |title                |uid |vid  |
|---------|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|---------------------|----|-----|
|[unread] |1606115457 |1606115457 |1                |zh-hans  |0       |1                             |1      |0      |结束语丨成长和进化，技术如此，我们亦如此 |1   |1175 |
|---------|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|---------------------|----|-----|

2020-11-25 10:35:32.874 INFO  jdbc.sqltiming Line:373 - update node_field_data set changed=1606271732, created=1606271732, default_langcode=1, langcode='zh-hans', 
promote=0, revision_translation_affected=1, status=1, sticky=0, title='结束语丨成长和进化，技术如此，我们亦如此', 
type='book', uid=1, vid=1175 where nid=1175 
 {executed in 1 msec}
2020-11-25 10:35:32.874 INFO  jdbc.sqltiming Line:373 - update node_field_revision set changed=1606271732, created=1606271732, default_langcode=1, 
langcode='zh-hans', promote=0, revision_translation_affected=1, status=1, sticky=0, title='结束语丨成长和进化，技术如此，我们亦如此', 
uid=1, vid=1175 where nid=1175 
 {executed in 0 msec}
2020-11-25 10:35:32.879 INFO  jdbc.sqltiming Line:373 - select bookfieldm0_.entity_id as entity_i1_8_, bookfieldm0_.bundle as bundle2_8_, bookfieldm0_.delta 
as delta3_8_, bookfieldm0_.langcode as langcode4_8_, bookfieldm0_.field_media_value as field_me5_8_, 
bookfieldm0_.revision_id as revision6_8_ from node__field_media bookfieldm0_ where bookfieldm0_.entity_id=1175 
 {executed in 0 msec}
2020-11-25 10:35:32.879 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------------|------------|
|entity_id |bundle |delta |langcode |field_media_value |revision_id |
|----------|-------|------|---------|------------------|------------|
|1175      |book   |0     |zh-hans  |                  |1175        |
|----------|-------|------|---------|------------------|------------|

2020-11-25 10:35:32.881 INFO  jdbc.sqltiming Line:373 - select nodefieldm0_.entity_id as entity_i1_17_0_, nodefieldm0_.bundle as bundle2_17_0_, nodefieldm0_.delta 
as delta3_17_0_, nodefieldm0_.langcode as langcode4_17_0_, nodefieldm0_.field_media_value as 
field_me5_17_0_, nodefieldm0_.revision_id as revision6_17_0_ from node_revision__field_media 
nodefieldm0_ where nodefieldm0_.entity_id=1175 
 {executed in 0 msec}
2020-11-25 10:35:32.881 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------------|------------|
|entity_id |bundle |delta |langcode |field_media_value |revision_id |
|----------|-------|------|---------|------------------|------------|
|[unread]  |book   |0     |zh-hans  |                  |1175        |
|----------|-------|------|---------|------------------|------------|

2020-11-25 10:35:32.883 INFO  jdbc.sqltiming Line:373 - select bookfieldc0_.entity_id as entity_i1_5_, bookfieldc0_.bundle as bundle2_5_, bookfieldc0_.field_comment_value 
as field_co3_5_, bookfieldc0_.delta as delta4_5_, bookfieldc0_.field_comment_format as field_co5_5_, 
bookfieldc0_.langcode as langcode6_5_, bookfieldc0_.revision_id as revision7_5_ from node__field_comment 
bookfieldc0_ where bookfieldc0_.entity_id=1175 
 {executed in 0 msec}
2020-11-25 10:35:32.884 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|--------------------|------|---------------------|---------|------------|
|entity_id |bundle |field_comment_value |delta |field_comment_format |langcode |revision_id |
|----------|-------|--------------------|------|---------------------|---------|------------|
|1175      |book   |                    |0     |full_html            |zh-hans  |1175        |
|----------|-------|--------------------|------|---------------------|---------|------------|

2020-11-25 10:35:32.886 INFO  jdbc.sqltiming Line:373 - update node__field_comment set bundle='book', field_comment_value='<li class="reJj6Thl_0"><img 
src="https://static001.geekbang.org/account/avatar/00/1b/9d/8a/c2cd19da.jpg" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <a>一野（wx:abley1874...</a> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2020-05-28 </div> </div> <!----> </div> <div> <div 
class="_3M6kV3zb_0"> 一路学完，真的非常棒，感谢老师细心指导。同时大量的例子、图解，真正做到了深入浅出。期待老师下一次的专栏 </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 
也谢谢你的一路的陪伴和坚持。深入浅出其实也是我写专栏的时候给自己定的目标之一，你的这个评价让我备受鼓舞。如果文章中有不清楚的地方，也欢迎继续留言讨论</p> </div> <div 
class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> <span></span> 
</div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> </div> <!----> 
</div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/10/de/d3/2aa0177f.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>paulhaoyi</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-05-20 </div> </div> <!----> 
</div> <div> <div class="_3M6kV3zb_0"> 感谢老师精彩的课程，也期待后面更多更好的系列课程，结合AI，最新技术趋势。 <br>哈哈，赶紧出新课吧，我迫不及待订阅了。😄 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 哈哈，感谢你的支持。结合AI的检索引擎是一个蛮大和蛮新的话题，是最新的趋势。但这个领域也涉及了很多的知识基础，可能很多人不太好理解。我得想想要如何写才好。如果有新课了，我会第一时间发预告的。</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/12/3a/82/1ff83a38.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>牛牛</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-05-19 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0"> 首先感谢老师、我觉得这个专栏的质量非常高, 至少在我的心里、它与丁奇老师的MySQL、王争老师的数据结构、文浩老师的计算机原理一样深深影响了我, 
用了四期`一周免费读`默默的跟完了课, 收益匪浅, 决定买下来思思品味, 值得反复阅读的一门课, 强烈推荐~~~~ </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 
也非常感谢你的认可和鼓励！我相信专栏中多少会有不完善的地方，但整体来说，我也希望这个专栏能从一个不一样的角度，让我们能一起探索检索技术是什么和该怎么做。如果能给你带来更多的思考和收获，那么我也会觉得非常开心和鼓舞。<br></p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>一步</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-05-18 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0"> 感谢老师的付出，感谢老师认真回答了每一个评论。 </div> <div class="_2r3UB1GX_0"> <span>展开</span><i 
class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 也谢谢你一直以来积极的提问。其实好的问题，不仅仅帮助自己更好地理解专栏内容，也帮助作者将专栏没讲清楚的内容进行补充说明。从这个角度讲，每个积极提问的人，都是专栏的共建者。谢谢你的支持！</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/1b/96/47/a083d4ea.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>青生先森</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-05-19 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 首先谢谢老师的付出，经过《数据结构与算法之美》《MySQL实战45讲》以及陈老师的专栏，我越来越喜欢数据库方面的开发，希望老师多出一些专栏，一定支持，期待。 
</div> <!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 谢谢你的支持。现在我们对于数据库的使用也是混合的机制，从关系数据库，kv数据库到时序数据库都有(MySQL+TiDB+Redis+aerospike+opentsdb)。你会看到，数据库相关的技术也是一直在发展。</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/0f/4f/3f/b353603a.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>王坤祥</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-05-18 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0"> 作为一个转行的程序猿，通过这门课，我从整体上对计算机技术有了更深入的理解。 <br> <br>既然入行了，需要学习很多的计算机的知识，前段时间在看资料的时候突然想到在老师的课程中曾经涉及到了一些知识，然后来到本课程中寻找关联，知识点相互补充，我顿时有种豁然开朗的感觉。因为老师的课程是与工程实践紧密联系的，能够从实际应用的角度分析问题，而不仅仅是单纯的理论解释。总之，收货还是不少的，感谢老师~~~ 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 很高兴看到这个专栏对你有帮助。我也一直觉得许多理论的知识和实际工作结合不够紧密，导致很多人之前在学校学习教材的时候，会疑惑这些知识，比如说各种高级数据结构有什么用。但实际上，你会发现，在某些应用场景中，还真必须使用这样的数据结构才合适。<br>因此，这个专栏，我其实也希望能将知识点更好地串起来，让你能理解这些技术的来龙去脉和相互之间的关系。当然，由于篇幅限制，还有许多知识点没有提到。但我相信，你能掌握好合理的学习方法，将更多的新知识吸收到自己的知识体系中。</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/10/1d/13/31ea1b0b.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>峰</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-05-18 </div> </div> <!----> </div> <div> 
<div class="_3M6kV3zb_0"> 舍不得技术思维比口音还厉害的陈东老师！！！！！！！！！我想再听老师讲课肿么办！！！！！！！！！！！！！ </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 
哈哈，不介意口音的话可以多听几遍~<br>而且未来说不定我也可能在更多的场合和大家继续分享。</p> </div> <div class="_1w8H0ktn_0 _2A421P4G_0"> 
<div class="_2jsFl-X0_0"> <i class="iconfont"></i> <span></span> </div> <div class="_2P4B1Hdm_0"> 
<i class="iconfont"></i> <span class=""></span> </div> <!----> </div> </div> </div></li> <li 
class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/0f/46/19/3c447209.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>张和祥</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-05-18 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 感谢！虽然只学了一小部分，但是了解到了很多搜索相关的技术信息和处理方式，剩下的就是实践技术了。 
</div> <!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 谢谢你的支持。专栏的内容其实覆盖面有一定的广度，不过也有着一定的连续性。因此，对于已经学习的部分，希望对你直接的工作有帮助;而还没有学习的部分，以后可以慢慢看，希望可以对你的视野和思考有所帮助。</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Ia8qXKLnJJbHjsYNQnlQgnzwZL6j3WvbcYEZaaLtg2iagYaiajPCvqaCVvicA4ibtNsQTshWu5ibhQeGyWHLJhzjd3A/132" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>子一</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-05-18 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0"> 感谢老师的辛勤付出 </div> <div class="_2r3UB1GX_0"> <span>展开</span><i 
class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 也谢谢你们的支持和鼓励，这也是我更新的动力。希望专栏内容对你有帮助。</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/11/8f/cf/890f82d6.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>那时刻</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-05-18 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0"> 感谢老师的分享，尤其是老师对于每篇文章的讨论问题和疑问都进行详细的回答，是我们对于问题有了清晰的认识。再次感谢。 </div> 
<div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 也感谢你积极地提出各种问题，帮助我将文章中没有讲到或没有讲清楚的知识点提出来，让我能进行补充说明。<br>专栏结束了，但是学习没有结束。有问题依然可以留言。我也会继续回答。</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> 
</div> <!----> </div> </div> </div></li>', delta=0, field_comment_format='full_html', langcode='zh-hans', 
revision_id=1175 where entity_id=1175 
 {executed in 1 msec}
2020-11-25 10:35:32.890 INFO  jdbc.sqltiming Line:373 - select nodefieldc0_.entity_id as entity_i1_14_0_, nodefieldc0_.bundle as bundle2_14_0_, nodefieldc0_.field_comment_value 
as field_co3_14_0_, nodefieldc0_.delta as delta4_14_0_, nodefieldc0_.field_comment_format as 
field_co5_14_0_, nodefieldc0_.langcode as langcode6_14_0_, nodefieldc0_.revision_id as revision7_14_0_ 
from node_revision__field_comment nodefieldc0_ where nodefieldc0_.entity_id=1175 
 {executed in 1 msec}
2020-11-25 10:35:32.890 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|--------------------|------|---------------------|---------|------------|
|entity_id |bundle |field_comment_value |delta |field_comment_format |langcode |revision_id |
|----------|-------|--------------------|------|---------------------|---------|------------|
|[unread]  |book   |                    |0     |full_html            |zh-hans  |1175        |
|----------|-------|--------------------|------|---------------------|---------|------------|

2020-11-25 10:35:32.892 INFO  jdbc.sqltiming Line:373 - update node_revision__field_comment set bundle='book', field_comment_value='<li class="reJj6Thl_0"><img 
src="https://static001.geekbang.org/account/avatar/00/1b/9d/8a/c2cd19da.jpg" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <a>一野（wx:abley1874...</a> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2020-05-28 </div> </div> <!----> </div> <div> <div 
class="_3M6kV3zb_0"> 一路学完，真的非常棒，感谢老师细心指导。同时大量的例子、图解，真正做到了深入浅出。期待老师下一次的专栏 </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 
也谢谢你的一路的陪伴和坚持。深入浅出其实也是我写专栏的时候给自己定的目标之一，你的这个评价让我备受鼓舞。如果文章中有不清楚的地方，也欢迎继续留言讨论</p> </div> <div 
class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> <span></span> 
</div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> </div> <!----> 
</div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/10/de/d3/2aa0177f.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>paulhaoyi</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-05-20 </div> </div> <!----> 
</div> <div> <div class="_3M6kV3zb_0"> 感谢老师精彩的课程，也期待后面更多更好的系列课程，结合AI，最新技术趋势。 <br>哈哈，赶紧出新课吧，我迫不及待订阅了。😄 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 哈哈，感谢你的支持。结合AI的检索引擎是一个蛮大和蛮新的话题，是最新的趋势。但这个领域也涉及了很多的知识基础，可能很多人不太好理解。我得想想要如何写才好。如果有新课了，我会第一时间发预告的。</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/12/3a/82/1ff83a38.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>牛牛</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-05-19 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0"> 首先感谢老师、我觉得这个专栏的质量非常高, 至少在我的心里、它与丁奇老师的MySQL、王争老师的数据结构、文浩老师的计算机原理一样深深影响了我, 
用了四期`一周免费读`默默的跟完了课, 收益匪浅, 决定买下来思思品味, 值得反复阅读的一门课, 强烈推荐~~~~ </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 
也非常感谢你的认可和鼓励！我相信专栏中多少会有不完善的地方，但整体来说，我也希望这个专栏能从一个不一样的角度，让我们能一起探索检索技术是什么和该怎么做。如果能给你带来更多的思考和收获，那么我也会觉得非常开心和鼓舞。<br></p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>一步</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-05-18 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0"> 感谢老师的付出，感谢老师认真回答了每一个评论。 </div> <div class="_2r3UB1GX_0"> <span>展开</span><i 
class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 也谢谢你一直以来积极的提问。其实好的问题，不仅仅帮助自己更好地理解专栏内容，也帮助作者将专栏没讲清楚的内容进行补充说明。从这个角度讲，每个积极提问的人，都是专栏的共建者。谢谢你的支持！</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class="">1</span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/1b/96/47/a083d4ea.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>青生先森</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-05-19 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 首先谢谢老师的付出，经过《数据结构与算法之美》《MySQL实战45讲》以及陈老师的专栏，我越来越喜欢数据库方面的开发，希望老师多出一些专栏，一定支持，期待。 
</div> <!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 谢谢你的支持。现在我们对于数据库的使用也是混合的机制，从关系数据库，kv数据库到时序数据库都有(MySQL+TiDB+Redis+aerospike+opentsdb)。你会看到，数据库相关的技术也是一直在发展。</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/0f/4f/3f/b353603a.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>王坤祥</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-05-18 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0"> 作为一个转行的程序猿，通过这门课，我从整体上对计算机技术有了更深入的理解。 <br> <br>既然入行了，需要学习很多的计算机的知识，前段时间在看资料的时候突然想到在老师的课程中曾经涉及到了一些知识，然后来到本课程中寻找关联，知识点相互补充，我顿时有种豁然开朗的感觉。因为老师的课程是与工程实践紧密联系的，能够从实际应用的角度分析问题，而不仅仅是单纯的理论解释。总之，收货还是不少的，感谢老师~~~ 
</div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 很高兴看到这个专栏对你有帮助。我也一直觉得许多理论的知识和实际工作结合不够紧密，导致很多人之前在学校学习教材的时候，会疑惑这些知识，比如说各种高级数据结构有什么用。但实际上，你会发现，在某些应用场景中，还真必须使用这样的数据结构才合适。<br>因此，这个专栏，我其实也希望能将知识点更好地串起来，让你能理解这些技术的来龙去脉和相互之间的关系。当然，由于篇幅限制，还有许多知识点没有提到。但我相信，你能掌握好合理的学习方法，将更多的新知识吸收到自己的知识体系中。</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/10/1d/13/31ea1b0b.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>峰</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-05-18 </div> </div> <!----> </div> <div> 
<div class="_3M6kV3zb_0"> 舍不得技术思维比口音还厉害的陈东老师！！！！！！！！！我想再听老师讲课肿么办！！！！！！！！！！！！！ </div> <div class="_2r3UB1GX_0"> 
<span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 
哈哈，不介意口音的话可以多听几遍~<br>而且未来说不定我也可能在更多的场合和大家继续分享。</p> </div> <div class="_1w8H0ktn_0 _2A421P4G_0"> 
<div class="_2jsFl-X0_0"> <i class="iconfont"></i> <span></span> </div> <div class="_2P4B1Hdm_0"> 
<i class="iconfont"></i> <span class=""></span> </div> <!----> </div> </div> </div></li> <li 
class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/0f/46/19/3c447209.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>张和祥</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-05-18 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0 _3D2NkqD6_0"> 感谢！虽然只学了一小部分，但是了解到了很多搜索相关的技术信息和处理方式，剩下的就是实践技术了。 
</div> <!----> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 谢谢你的支持。专栏的内容其实覆盖面有一定的广度，不过也有着一定的连续性。因此，对于已经学习的部分，希望对你直接的工作有帮助;而还没有学习的部分，以后可以慢慢看，希望可以对你的视野和思考有所帮助。</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Ia8qXKLnJJbHjsYNQnlQgnzwZL6j3WvbcYEZaaLtg2iagYaiajPCvqaCVvicA4ibtNsQTshWu5ibhQeGyWHLJhzjd3A/132" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>子一</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-05-18 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0"> 感谢老师的辛勤付出 </div> <div class="_2r3UB1GX_0"> <span>展开</span><i 
class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 也谢谢你们的支持和鼓励，这也是我更新的动力。希望专栏内容对你有帮助。</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> 
</div> <!----> </div> </div> </div></li> <li class="reJj6Thl_0"><img src="https://static001.geekbang.org/account/avatar/00/11/8f/cf/890f82d6.jpg" 
class="_2273kGdT_0"> <div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> 
<a>那时刻</a> <!----> </div> <div class="_1H1Z49Dr_0"> 2020-05-18 </div> </div> <!----> </div> 
<div> <div class="_3M6kV3zb_0"> 感谢老师的分享，尤其是老师对于每篇文章的讨论问题和疑问都进行详细的回答，是我们对于问题有了清晰的认识。再次感谢。 </div> 
<div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> </div> <div class="_2xNIY4NG_0"> 
<p class="_33BLbmw4_0">作者回复: 也感谢你积极地提出各种问题，帮助我将文章中没有讲到或没有讲清楚的知识点提出来，让我能进行补充说明。<br>专栏结束了，但是学习没有结束。有问题依然可以留言。我也会继续回答。</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> 
</div> <!----> </div> </div> </div></li>', delta=0, field_comment_format='full_html', langcode='zh-hans', 
revision_id=1175 where entity_id=1175 
 {executed in 0 msec}
2020-11-25 10:35:32.896 INFO  jdbc.sqltiming Line:373 - select bookfieldt0_.entity_id as entity_i1_9_, bookfieldt0_.bundle as bundle2_9_, bookfieldt0_.delta 
as delta3_9_, bookfieldt0_.langcode as langcode4_9_, bookfieldt0_.revision_id as revision5_9_, 
bookfieldt0_.field_thumb_value as field_th6_9_ from node__field_thumb bookfieldt0_ where bookfieldt0_.entity_id=1175 
 {executed in 0 msec}
2020-11-25 10:35:32.897 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------|------------------|
|entity_id |bundle |delta |langcode |revision_id |field_thumb_value |
|----------|-------|------|---------|------------|------------------|
|1175      |book   |0     |zh-hans  |1175        |                  |
|----------|-------|------|---------|------------|------------------|

2020-11-25 10:35:32.898 INFO  jdbc.sqltiming Line:373 - update node__field_thumb set bundle='book', delta=0, langcode='zh-hans', revision_id=1175, 
field_thumb_value='https://static001.geekbang.org/resource/image/1c/77/1cfac5f2a57714d97981954ecbe7e377.jpg' 
where entity_id=1175 
 {executed in 0 msec}
2020-11-25 10:35:32.902 INFO  jdbc.sqltiming Line:373 - select nodefieldt0_.entity_id as entity_i1_18_0_, nodefieldt0_.bundle as bundle2_18_0_, nodefieldt0_.delta 
as delta3_18_0_, nodefieldt0_.langcode as langcode4_18_0_, nodefieldt0_.revision_id as revision5_18_0_, 
nodefieldt0_.field_thumb_value as field_th6_18_0_ from node_revision__field_thumb nodefieldt0_ 
where nodefieldt0_.entity_id=1175 
 {executed in 0 msec}
2020-11-25 10:35:32.903 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------|------------------|
|entity_id |bundle |delta |langcode |revision_id |field_thumb_value |
|----------|-------|------|---------|------------|------------------|
|[unread]  |book   |0     |zh-hans  |1175        |                  |
|----------|-------|------|---------|------------|------------------|

2020-11-25 10:35:32.904 INFO  jdbc.sqltiming Line:373 - update node_revision__field_thumb set bundle='book', delta=0, langcode='zh-hans', revision_id=1175, 
field_thumb_value='https://static001.geekbang.org/resource/image/1c/77/1cfac5f2a57714d97981954ecbe7e377.jpg' 
where entity_id=1175 
 {executed in 0 msec}
2020-11-25 10:35:32.913 INFO  jdbc.sqltiming Line:373 - select bookfieldf0_.entity_id as entity_i1_6_0_, bookfieldf0_.bundle as bundle2_6_0_, bookfieldf0_.delta 
as delta3_6_0_, bookfieldf0_.field_fenlei_target_id as field_fe4_6_0_, bookfieldf0_.langcode 
as langcode5_6_0_, bookfieldf0_.revision_id as revision6_6_0_ from node__field_fenlei bookfieldf0_ 
where bookfieldf0_.entity_id=1175 
 {executed in 0 msec}
2020-11-25 10:35:32.913 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|-----------------------|---------|------------|
|entity_id |bundle |delta |field_fenlei_target_id |langcode |revision_id |
|----------|-------|------|-----------------------|---------|------------|
|[unread]  |book   |0     |1                      |zh-hans  |1175        |
|----------|-------|------|-----------------------|---------|------------|

2020-11-25 10:35:32.915 INFO  jdbc.sqltiming Line:373 - select nodefieldf0_.entity_id as entity_i1_15_0_, nodefieldf0_.bundle as bundle2_15_0_, nodefieldf0_.delta 
as delta3_15_0_, nodefieldf0_.field_fenlei_target_id as field_fe4_15_0_, nodefieldf0_.langcode 
as langcode5_15_0_, nodefieldf0_.revision_id as revision6_15_0_ from node_revision__field_fenlei 
nodefieldf0_ where nodefieldf0_.entity_id=1175 
 {executed in 0 msec}
2020-11-25 10:35:32.916 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|-----------------------|---------|------------|
|entity_id |bundle |delta |field_fenlei_target_id |langcode |revision_id |
|----------|-------|------|-----------------------|---------|------------|
|[unread]  |book   |0     |1                      |zh-hans  |1175        |
|----------|-------|------|-----------------------|---------|------------|

2020-11-25 10:35:32.918 INFO  jdbc.sqltiming Line:373 - select bookchecke0_.item_id as item_id1_2_, bookchecke0_.fsid as fsid2_2_, bookchecke0_.got 
as got3_2_, bookchecke0_.name as name4_2_, bookchecke0_.parse_fail as parse_fa5_2_, bookchecke0_.parsed 
as parsed6_2_, bookchecke0_.path as path7_2_, bookchecke0_.title as title8_2_, bookchecke0_.vid 
as vid9_2_ from book_check bookchecke0_ where bookchecke0_.fsid='897380553874887' and bookchecke0_.name='net_content' 
 {executed in 0 msec}
2020-11-25 10:35:32.919 INFO  jdbc.resultsettable Line:610 - 
|--------|---------|---------|---------|-----------|---------|---------|---------|---------|
|item_id |fsid     |got      |name     |parse_fail |parsed   |path     |title    |vid      |
|--------|---------|---------|---------|-----------|---------|---------|---------|---------|
|1176    |[unread] |[unread] |[unread] |[unread]   |[unread] |[unread] |[unread] |[unread] |
|--------|---------|---------|---------|-----------|---------|---------|---------|---------|

2020-11-25 10:36:11.547 INFO  jdbc.sqltiming Line:373 - update book_check set fsid='897380553874887', got=1, name='net_content', parse_fail='', parsed=1, 
path='123-检索技术核心20讲/05丨结束语 (2讲)/结课测试丨这些检索知识，你都掌握了吗？.html', title='结课测试丨这些检索知识，你都掌握了吗？', vid=1176 
where item_id=1176 
 {executed in 0 msec}
2020-11-25 10:36:11.556 INFO  jdbc.sqltiming Line:373 - select nodebodyen0_.entity_id as entity_i1_4_, nodebodyen0_.body_value as body_val2_4_, nodebodyen0_.body_summary 
as body_sum3_4_, nodebodyen0_.bundle as bundle4_4_, nodebodyen0_.delta as delta5_4_, nodebodyen0_.body_format 
as body_for6_4_, nodebodyen0_.langcode as langcode7_4_, nodebodyen0_.revision_id as revision8_4_ 
from node__body nodebodyen0_ where nodebodyen0_.entity_id=1176 
 {executed in 0 msec}
2020-11-25 10:36:11.557 INFO  jdbc.resultsettable Line:610 - 
|----------|-----------|-------------|-------|------|------------|---------|------------|
|entity_id |body_value |body_summary |bundle |delta |body_format |langcode |revision_id |
|----------|-----------|-------------|-------|------|------------|---------|------------|
|1176      |           |             |book   |0     |full_html   |zh-hans  |1176        |
|----------|-----------|-------------|-------|------|------------|---------|------------|

2020-11-25 10:36:11.558 INFO  jdbc.sqltiming Line:373 - select nodebodyre0_.entity_id as entity_i1_13_0_, nodebodyre0_.body_value as body_val2_13_0_, 
nodebodyre0_.body_summary as body_sum3_13_0_, nodebodyre0_.bundle as bundle4_13_0_, nodebodyre0_.delta 
as delta5_13_0_, nodebodyre0_.body_format as body_for6_13_0_, nodebodyre0_.langcode as langcode7_13_0_, 
nodebodyre0_.revision_id as revision8_13_0_ from node_revision__body nodebodyre0_ where nodebodyre0_.entity_id=1176 
 {executed in 1 msec}
2020-11-25 10:36:11.558 INFO  jdbc.resultsettable Line:610 - 
|----------|-----------|-------------|-------|------|------------|---------|------------|
|entity_id |body_value |body_summary |bundle |delta |body_format |langcode |revision_id |
|----------|-----------|-------------|-------|------|------------|---------|------------|
|[unread]  |           |             |book   |0     |full_html   |zh-hans  |1176        |
|----------|-----------|-------------|-------|------|------------|---------|------------|

2020-11-25 10:36:11.560 INFO  jdbc.sqltiming Line:373 - update node__body set body_value='<div data-slate-editor="true" data-key="68" autocorrect="off" 
spellcheck="false" data-gramm="false" style="outline: none; white-space: pre-wrap; overflow-wrap: 
break-word;"> <div class="se-b74840d2 " data-slate-type="paragraph" data-slate-object="block" 
data-key="69"> <span data-slate-object="text" data-key="70"><span data-slate-leaf="true" data-offset-key="70:0" 
data-first-offset="true"><span data-slate-string="true">你好，我是陈东。</span></span></span> </div> 
<div class="se-80004769 " data-slate-type="paragraph" data-slate-object="block" data-key="71"> 
<span data-slate-object="text" data-key="72"><span data-slate-leaf="true" data-offset-key="72:0" 
data-first-offset="true"><span data-slate-string="true">《检索技术核心 20 讲》这门课程就正式完结了，很感谢你一直以来的认真学习和支持！</span></span></span> 
</div> <div class="se-8de6a889 " data-slate-type="paragraph" data-slate-object="block" data-key="73"> 
<span data-slate-object="text" data-key="74"><span data-slate-leaf="true" data-offset-key="74:0" 
data-first-offset="true"><span data-slate-string="true">那为了帮助你检验自己的学习效果，我特别给你准备了一套结课测试题。这套测试题一共有 
20 道题目，包括 10 道单选题和 10 道多选题，满分 100 分，我建议你在 30 分钟以内完成。</span></span></span> </div> <div class="se-26997bfe 
" data-slate-type="paragraph" data-slate-object="block" data-key="75"> <span data-slate-object="text" 
data-key="76"><span data-slate-leaf="true" data-offset-key="76:0" data-first-offset="true"><span 
data-slate-string="true">还等什么，快点击下面的按钮开始测试吧！</span></span></span> </div> <div class="se-1169401d" 
data-slate-type="image" data-slate-object="block" data-key="77"> <a href="http://time.geekbang.org/quiz/intro?act_id=161&amp;exam_id=359"><img 
class="se-f8374194" src="https://static001.geekbang.org/resource/image/28/a4/28d1be62669b4f3cc01c36466bf811a4.png"></a> 
</div> </div>', body_summary='', bundle='book', delta=0, body_format='full_html', langcode='zh-hans', 
revision_id=1176 where entity_id=1176 
 {executed in 0 msec}
2020-11-25 10:36:11.561 INFO  jdbc.sqltiming Line:373 - update node_revision__body set body_value='<div data-slate-editor="true" data-key="68" autocorrect="off" 
spellcheck="false" data-gramm="false" style="outline: none; white-space: pre-wrap; overflow-wrap: 
break-word;"> <div class="se-b74840d2 " data-slate-type="paragraph" data-slate-object="block" 
data-key="69"> <span data-slate-object="text" data-key="70"><span data-slate-leaf="true" data-offset-key="70:0" 
data-first-offset="true"><span data-slate-string="true">你好，我是陈东。</span></span></span> </div> 
<div class="se-80004769 " data-slate-type="paragraph" data-slate-object="block" data-key="71"> 
<span data-slate-object="text" data-key="72"><span data-slate-leaf="true" data-offset-key="72:0" 
data-first-offset="true"><span data-slate-string="true">《检索技术核心 20 讲》这门课程就正式完结了，很感谢你一直以来的认真学习和支持！</span></span></span> 
</div> <div class="se-8de6a889 " data-slate-type="paragraph" data-slate-object="block" data-key="73"> 
<span data-slate-object="text" data-key="74"><span data-slate-leaf="true" data-offset-key="74:0" 
data-first-offset="true"><span data-slate-string="true">那为了帮助你检验自己的学习效果，我特别给你准备了一套结课测试题。这套测试题一共有 
20 道题目，包括 10 道单选题和 10 道多选题，满分 100 分，我建议你在 30 分钟以内完成。</span></span></span> </div> <div class="se-26997bfe 
" data-slate-type="paragraph" data-slate-object="block" data-key="75"> <span data-slate-object="text" 
data-key="76"><span data-slate-leaf="true" data-offset-key="76:0" data-first-offset="true"><span 
data-slate-string="true">还等什么，快点击下面的按钮开始测试吧！</span></span></span> </div> <div class="se-1169401d" 
data-slate-type="image" data-slate-object="block" data-key="77"> <a href="http://time.geekbang.org/quiz/intro?act_id=161&amp;exam_id=359"><img 
class="se-f8374194" src="https://static001.geekbang.org/resource/image/28/a4/28d1be62669b4f3cc01c36466bf811a4.png"></a> 
</div> </div>', body_summary='', bundle='book', delta=0, body_format='full_html', langcode='zh-hans', 
revision_id=1176 where entity_id=1176 
 {executed in 0 msec}
2020-11-25 10:36:11.565 INFO  jdbc.sqltiming Line:373 - select nodefiledd0_.nid as nid1_10_, nodefiledd0_.changed as changed2_10_, nodefiledd0_.created 
as created3_10_, nodefiledd0_.default_langcode as default_4_10_, nodefiledd0_.langcode as langcode5_10_, 
nodefiledd0_.promote as promote6_10_, nodefiledd0_.revision_translation_affected as revision7_10_, 
nodefiledd0_.status as status8_10_, nodefiledd0_.sticky as sticky9_10_, nodefiledd0_.title 
as title10_10_, nodefiledd0_.type as type11_10_, nodefiledd0_.uid as uid12_10_, nodefiledd0_.vid 
as vid13_10_ from node_field_data nodefiledd0_ where nodefiledd0_.nid=1176 
 {executed in 0 msec}
2020-11-25 10:36:11.566 INFO  jdbc.resultsettable Line:610 - 
|-----|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|--------------------|-----|----|-----|
|nid  |changed    |created    |default_langcode |langcode |promote |revision_translation_affected |status |sticky |title               |type |uid |vid  |
|-----|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|--------------------|-----|----|-----|
|1176 |1606115464 |1606115464 |1                |zh-hans  |0       |1                             |1      |0      |结课测试丨这些检索知识，你都掌握了吗？ |book |1   |1176 |
|-----|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|--------------------|-----|----|-----|

2020-11-25 10:36:11.567 INFO  jdbc.sqltiming Line:373 - select nodefieldr0_.nid as nid1_11_0_, nodefieldr0_.changed as changed2_11_0_, nodefieldr0_.created 
as created3_11_0_, nodefieldr0_.default_langcode as default_4_11_0_, nodefieldr0_.langcode 
as langcode5_11_0_, nodefieldr0_.promote as promote6_11_0_, nodefieldr0_.revision_translation_affected 
as revision7_11_0_, nodefieldr0_.status as status8_11_0_, nodefieldr0_.sticky as sticky9_11_0_, 
nodefieldr0_.title as title10_11_0_, nodefieldr0_.uid as uid11_11_0_, nodefieldr0_.vid as vid12_11_0_ 
from node_field_revision nodefieldr0_ where nodefieldr0_.nid=1176 
 {executed in 1 msec}
2020-11-25 10:36:11.567 INFO  jdbc.resultsettable Line:610 - 
|---------|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|--------------------|----|-----|
|nid      |changed    |created    |default_langcode |langcode |promote |revision_translation_affected |status |sticky |title               |uid |vid  |
|---------|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|--------------------|----|-----|
|[unread] |1606115464 |1606115464 |1                |zh-hans  |0       |1                             |1      |0      |结课测试丨这些检索知识，你都掌握了吗？ |1   |1176 |
|---------|-----------|-----------|-----------------|---------|--------|------------------------------|-------|-------|--------------------|----|-----|

2020-11-25 10:36:11.569 INFO  jdbc.sqltiming Line:373 - update node_field_data set changed=1606271771, created=1606271771, default_langcode=1, langcode='zh-hans', 
promote=0, revision_translation_affected=1, status=1, sticky=0, title='结课测试丨这些检索知识，你都掌握了吗？', 
type='book', uid=1, vid=1176 where nid=1176 
 {executed in 1 msec}
2020-11-25 10:36:11.569 INFO  jdbc.sqltiming Line:373 - update node_field_revision set changed=1606271771, created=1606271771, default_langcode=1, 
langcode='zh-hans', promote=0, revision_translation_affected=1, status=1, sticky=0, title='结课测试丨这些检索知识，你都掌握了吗？', 
uid=1, vid=1176 where nid=1176 
 {executed in 0 msec}
2020-11-25 10:36:11.573 INFO  jdbc.sqltiming Line:373 - select bookfieldm0_.entity_id as entity_i1_8_, bookfieldm0_.bundle as bundle2_8_, bookfieldm0_.delta 
as delta3_8_, bookfieldm0_.langcode as langcode4_8_, bookfieldm0_.field_media_value as field_me5_8_, 
bookfieldm0_.revision_id as revision6_8_ from node__field_media bookfieldm0_ where bookfieldm0_.entity_id=1176 
 {executed in 0 msec}
2020-11-25 10:36:11.573 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------------|------------|
|entity_id |bundle |delta |langcode |field_media_value |revision_id |
|----------|-------|------|---------|------------------|------------|
|1176      |book   |0     |zh-hans  |                  |1176        |
|----------|-------|------|---------|------------------|------------|

2020-11-25 10:36:11.575 INFO  jdbc.sqltiming Line:373 - select nodefieldm0_.entity_id as entity_i1_17_0_, nodefieldm0_.bundle as bundle2_17_0_, nodefieldm0_.delta 
as delta3_17_0_, nodefieldm0_.langcode as langcode4_17_0_, nodefieldm0_.field_media_value as 
field_me5_17_0_, nodefieldm0_.revision_id as revision6_17_0_ from node_revision__field_media 
nodefieldm0_ where nodefieldm0_.entity_id=1176 
 {executed in 0 msec}
2020-11-25 10:36:11.575 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------------|------------|
|entity_id |bundle |delta |langcode |field_media_value |revision_id |
|----------|-------|------|---------|------------------|------------|
|[unread]  |book   |0     |zh-hans  |                  |1176        |
|----------|-------|------|---------|------------------|------------|

2020-11-25 10:36:11.577 INFO  jdbc.sqltiming Line:373 - select bookfieldc0_.entity_id as entity_i1_5_, bookfieldc0_.bundle as bundle2_5_, bookfieldc0_.field_comment_value 
as field_co3_5_, bookfieldc0_.delta as delta4_5_, bookfieldc0_.field_comment_format as field_co5_5_, 
bookfieldc0_.langcode as langcode6_5_, bookfieldc0_.revision_id as revision7_5_ from node__field_comment 
bookfieldc0_ where bookfieldc0_.entity_id=1176 
 {executed in 0 msec}
2020-11-25 10:36:11.577 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|--------------------|------|---------------------|---------|------------|
|entity_id |bundle |field_comment_value |delta |field_comment_format |langcode |revision_id |
|----------|-------|--------------------|------|---------------------|---------|------------|
|1176      |book   |                    |0     |full_html            |zh-hans  |1176        |
|----------|-------|--------------------|------|---------------------|---------|------------|

2020-11-25 10:36:11.579 INFO  jdbc.sqltiming Line:373 - update node__field_comment set bundle='book', field_comment_value='<li class="reJj6Thl_0"><img 
src="https://static001.geekbang.org/account/avatar/00/10/5f/e5/54325854.jpg" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <a>范闲</a> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2020-05-18 </div> </div> <!----> </div> <div> <div 
class="_3M6kV3zb_0"> 结束的好快啊，意犹未尽 </div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> 
</div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 谢谢你对专栏的支持。专栏的内容毕竟是有限的，而知识是无限的，并且也一直在更新。其实光是系统篇的每一类系统，本身都可以写一个专栏。<br>这个专栏，更多的还是关注于检索技术的基础和方向，希望能让你对检索技术有一个更全面的了解和认知，同时也介绍了一些已经沉淀下来的解决方案。你可以认为这个专栏也是对检索技术的一个索引。如果要深入研究的话，其实每一篇提到的内容，都有许多细节和优化空间，都可以继续去深入学习的。</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> 
</div> <!----> </div> </div> </div></li>', delta=0, field_comment_format='full_html', langcode='zh-hans', 
revision_id=1176 where entity_id=1176 
 {executed in 0 msec}
2020-11-25 10:36:11.582 INFO  jdbc.sqltiming Line:373 - select nodefieldc0_.entity_id as entity_i1_14_0_, nodefieldc0_.bundle as bundle2_14_0_, nodefieldc0_.field_comment_value 
as field_co3_14_0_, nodefieldc0_.delta as delta4_14_0_, nodefieldc0_.field_comment_format as 
field_co5_14_0_, nodefieldc0_.langcode as langcode6_14_0_, nodefieldc0_.revision_id as revision7_14_0_ 
from node_revision__field_comment nodefieldc0_ where nodefieldc0_.entity_id=1176 
 {executed in 0 msec}
2020-11-25 10:36:11.582 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|--------------------|------|---------------------|---------|------------|
|entity_id |bundle |field_comment_value |delta |field_comment_format |langcode |revision_id |
|----------|-------|--------------------|------|---------------------|---------|------------|
|[unread]  |book   |                    |0     |full_html            |zh-hans  |1176        |
|----------|-------|--------------------|------|---------------------|---------|------------|

2020-11-25 10:36:11.584 INFO  jdbc.sqltiming Line:373 - update node_revision__field_comment set bundle='book', field_comment_value='<li class="reJj6Thl_0"><img 
src="https://static001.geekbang.org/account/avatar/00/10/5f/e5/54325854.jpg" class="_2273kGdT_0"> 
<div class="_2CG0SquK_0"> <div class="_304R4gla_0"> <div> <div class="_18Dng5rT_0"> <a>范闲</a> 
<!----> </div> <div class="_1H1Z49Dr_0"> 2020-05-18 </div> </div> <!----> </div> <div> <div 
class="_3M6kV3zb_0"> 结束的好快啊，意犹未尽 </div> <div class="_2r3UB1GX_0"> <span>展开</span><i class="iconfont"></i> 
</div> <div class="_2xNIY4NG_0"> <p class="_33BLbmw4_0">作者回复: 谢谢你对专栏的支持。专栏的内容毕竟是有限的，而知识是无限的，并且也一直在更新。其实光是系统篇的每一类系统，本身都可以写一个专栏。<br>这个专栏，更多的还是关注于检索技术的基础和方向，希望能让你对检索技术有一个更全面的了解和认知，同时也介绍了一些已经沉淀下来的解决方案。你可以认为这个专栏也是对检索技术的一个索引。如果要深入研究的话，其实每一篇提到的内容，都有许多细节和优化空间，都可以继续去深入学习的。</p> 
</div> <div class="_1w8H0ktn_0 _2A421P4G_0"> <div class="_2jsFl-X0_0"> <i class="iconfont"></i> 
<span></span> </div> <div class="_2P4B1Hdm_0"> <i class="iconfont"></i> <span class=""></span> 
</div> <!----> </div> </div> </div></li>', delta=0, field_comment_format='full_html', langcode='zh-hans', 
revision_id=1176 where entity_id=1176 
 {executed in 0 msec}
2020-11-25 10:36:11.587 INFO  jdbc.sqltiming Line:373 - select bookfieldt0_.entity_id as entity_i1_9_, bookfieldt0_.bundle as bundle2_9_, bookfieldt0_.delta 
as delta3_9_, bookfieldt0_.langcode as langcode4_9_, bookfieldt0_.revision_id as revision5_9_, 
bookfieldt0_.field_thumb_value as field_th6_9_ from node__field_thumb bookfieldt0_ where bookfieldt0_.entity_id=1176 
 {executed in 1 msec}
2020-11-25 10:36:11.587 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------|------------------|
|entity_id |bundle |delta |langcode |revision_id |field_thumb_value |
|----------|-------|------|---------|------------|------------------|
|1176      |book   |0     |zh-hans  |1176        |                  |
|----------|-------|------|---------|------------|------------------|

2020-11-25 10:36:11.589 INFO  jdbc.sqltiming Line:373 - update node__field_thumb set bundle='book', delta=0, langcode='zh-hans', revision_id=1176, 
field_thumb_value='https://static001.geekbang.org/resource/image/0e/05/0ee00d588edd9d0ac63a62cff2e49905.jpg' 
where entity_id=1176 
 {executed in 1 msec}
2020-11-25 10:36:11.591 INFO  jdbc.sqltiming Line:373 - select nodefieldt0_.entity_id as entity_i1_18_0_, nodefieldt0_.bundle as bundle2_18_0_, nodefieldt0_.delta 
as delta3_18_0_, nodefieldt0_.langcode as langcode4_18_0_, nodefieldt0_.revision_id as revision5_18_0_, 
nodefieldt0_.field_thumb_value as field_th6_18_0_ from node_revision__field_thumb nodefieldt0_ 
where nodefieldt0_.entity_id=1176 
 {executed in 0 msec}
2020-11-25 10:36:11.592 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|---------|------------|------------------|
|entity_id |bundle |delta |langcode |revision_id |field_thumb_value |
|----------|-------|------|---------|------------|------------------|
|[unread]  |book   |0     |zh-hans  |1176        |                  |
|----------|-------|------|---------|------------|------------------|

2020-11-25 10:36:11.593 INFO  jdbc.sqltiming Line:373 - update node_revision__field_thumb set bundle='book', delta=0, langcode='zh-hans', revision_id=1176, 
field_thumb_value='https://static001.geekbang.org/resource/image/0e/05/0ee00d588edd9d0ac63a62cff2e49905.jpg' 
where entity_id=1176 
 {executed in 0 msec}
2020-11-25 10:36:11.596 INFO  jdbc.sqltiming Line:373 - select bookfieldf0_.entity_id as entity_i1_6_0_, bookfieldf0_.bundle as bundle2_6_0_, bookfieldf0_.delta 
as delta3_6_0_, bookfieldf0_.field_fenlei_target_id as field_fe4_6_0_, bookfieldf0_.langcode 
as langcode5_6_0_, bookfieldf0_.revision_id as revision6_6_0_ from node__field_fenlei bookfieldf0_ 
where bookfieldf0_.entity_id=1176 
 {executed in 1 msec}
2020-11-25 10:36:11.596 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|-----------------------|---------|------------|
|entity_id |bundle |delta |field_fenlei_target_id |langcode |revision_id |
|----------|-------|------|-----------------------|---------|------------|
|[unread]  |book   |0     |1                      |zh-hans  |1176        |
|----------|-------|------|-----------------------|---------|------------|

2020-11-25 10:36:11.598 INFO  jdbc.sqltiming Line:373 - select nodefieldf0_.entity_id as entity_i1_15_0_, nodefieldf0_.bundle as bundle2_15_0_, nodefieldf0_.delta 
as delta3_15_0_, nodefieldf0_.field_fenlei_target_id as field_fe4_15_0_, nodefieldf0_.langcode 
as langcode5_15_0_, nodefieldf0_.revision_id as revision6_15_0_ from node_revision__field_fenlei 
nodefieldf0_ where nodefieldf0_.entity_id=1176 
 {executed in 0 msec}
2020-11-25 10:36:11.598 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|-----------------------|---------|------------|
|entity_id |bundle |delta |field_fenlei_target_id |langcode |revision_id |
|----------|-------|------|-----------------------|---------|------------|
|[unread]  |book   |0     |1                      |zh-hans  |1176        |
|----------|-------|------|-----------------------|---------|------------|

2020-11-25 10:36:11.600 INFO  jdbc.sqltiming Line:373 - select bookchecke0_.item_id as item_id1_2_, bookchecke0_.fsid as fsid2_2_, bookchecke0_.got 
as got3_2_, bookchecke0_.name as name4_2_, bookchecke0_.parse_fail as parse_fa5_2_, bookchecke0_.parsed 
as parsed6_2_, bookchecke0_.path as path7_2_, bookchecke0_.title as title8_2_, bookchecke0_.vid 
as vid9_2_ from book_check bookchecke0_ where bookchecke0_.got=0 limit 60, 20 
 {executed in 0 msec}
2020-11-25 10:36:11.601 INFO  jdbc.resultsettable Line:610 - 
|--------|-----|----|-----|-----------|-------|-----|------|----|
|item_id |fsid |got |name |parse_fail |parsed |path |title |vid |
|--------|-----|----|-----|-----------|-------|-----|------|----|
|--------|-----|----|-----|-----------|-------|-----|------|----|

2020-11-25 10:36:11.601 INFO  jdbc.sqltiming Line:373 - select count(bookchecke0_.item_id) as col_0_0_ from book_check bookchecke0_ where bookchecke0_.got=0 
 {executed in 0 msec}
2020-11-25 10:36:11.602 INFO  jdbc.resultsettable Line:610 - 
|---------|
|col_0_0_ |
|---------|
|40       |
|---------|

2020-11-25 10:36:11.610 INFO  jdbc.sqltiming Line:373 - select bookchecke0_.item_id as item_id1_2_, bookchecke0_.fsid as fsid2_2_, bookchecke0_.got 
as got3_2_, bookchecke0_.name as name4_2_, bookchecke0_.parse_fail as parse_fa5_2_, bookchecke0_.parsed 
as parsed6_2_, bookchecke0_.path as path7_2_, bookchecke0_.title as title8_2_, bookchecke0_.vid 
as vid9_2_ from book_check bookchecke0_ where bookchecke0_.got=0 order by bookchecke0_.item_id 
desc limit 1 
 {executed in 0 msec}
2020-11-25 10:36:11.610 INFO  jdbc.resultsettable Line:610 - 
|--------|----------------|----|------------|-----------|-------|--------------------------------------------------|------------------|-----|
|item_id |fsid            |got |name        |parse_fail |parsed |path                                              |title             |vid  |
|--------|----------------|----|------------|-----------|-------|--------------------------------------------------|------------------|-----|
|1150    |310963293930012 |0   |net_content |           |0      |123-检索技术核心20讲/01丨课前必学 (2讲)/00丨开篇词丨学会检索，快人一步！.html |00丨开篇词丨学会检索，快人一步！ |1150 |
|--------|----------------|----|------------|-----------|-------|--------------------------------------------------|------------------|-----|

2020-11-25 10:36:11.613 INFO  jdbc.sqltiming Line:373 - select bookentity0_.nid as nid1_1_, bookentity0_.bid as bid2_1_, bookentity0_.depth as depth3_1_, 
bookentity0_.has_children as has_chil4_1_, bookentity0_.p1 as p5_1_, bookentity0_.p2 as p6_1_, 
bookentity0_.p3 as p7_1_, bookentity0_.p4 as p8_1_, bookentity0_.p5 as p9_1_, bookentity0_.pid 
as pid10_1_, bookentity0_.weight as weight11_1_ from book bookentity0_ where bookentity0_.nid=1150 
 {executed in 1 msec}
2020-11-25 10:36:11.613 INFO  jdbc.resultsettable Line:610 - 
|-----|-----|------|-------------|-----|-----|-----|---|---|-----|-------|
|nid  |bid  |depth |has_children |p1   |p2   |p3   |p4 |p5 |pid  |weight |
|-----|-----|------|-------------|-----|-----|-----|---|---|-----|-------|
|1150 |1143 |3     |0            |1143 |1144 |1150 |0  |0  |1144 |0      |
|-----|-----|------|-------------|-----|-----|-----|---|---|-----|-------|

2020-11-25 10:36:11.616 INFO  jdbc.sqltiming Line:373 - select bookfieldf0_.entity_id as entity_i1_7_, bookfieldf0_.bundle as bundle2_7_, bookfieldf0_.delta 
as delta3_7_, bookfieldf0_.field_fsid_value as field_fs4_7_, bookfieldf0_.langcode as langcode5_7_, 
bookfieldf0_.revision_id as revision6_7_ from node__field_fsid bookfieldf0_ where bookfieldf0_.entity_id=1143 
 {executed in 1 msec}
2020-11-25 10:36:11.616 INFO  jdbc.resultsettable Line:610 - 
|----------|-------|------|-----------------|---------|------------|
|entity_id |bundle |delta |field_fsid_value |langcode |revision_id |
|----------|-------|------|-----------------|---------|------------|
|1143      |book   |0     |524148747141596  |zh-hans  |1143        |
|----------|-------|------|-----------------|---------|------------|

2020-11-25 10:54:55.379 INFO  org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean Line:598 - Closing JPA EntityManagerFactory for persistence unit 'default'
2020-11-25 10:54:55.381 INFO  org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor Line:218 - Shutting down ExecutorService 'applicationTaskExecutor'
2020-11-25 10:54:55.381 INFO  com.zaxxer.hikari.HikariDataSource Line:350 - HikariPool-1 - Shutdown initiated...
2020-11-25 10:54:55.383 INFO  com.zaxxer.hikari.HikariDataSource Line:352 - HikariPool-1 - Shutdown completed.
